<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大模型时代的Audio Tokenizer总结与思考</title>
    <link href="/2025/07/25/audio-codec/"/>
    <url>/2025/07/25/audio-codec/</url>
    
    <content type="html"><![CDATA[<h1 id="大模型时代的-Audio-Tokenizer-总结与思考"><a href="#大模型时代的-Audio-Tokenizer-总结与思考" class="headerlink" title="大模型时代的 Audio Tokenizer 总结与思考"></a>大模型时代的 Audio Tokenizer 总结与思考</h1><p>写在最前面：访问<a href="https://zhuanlan.zhihu.com/p/1931648584375341758">我的知乎同款文章</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>大语言模型拉开了大模型时代的序幕。大语言模型的核心机制是对文本序列建模：通过预测下一个词或字，实现对语言结构和语义的理解与生成。由于文字已经是高度抽象的、符号化的表达，适合直接建模。</p><p>随着大模型能力的拓展，多模态融合逐渐成为研究热点。在众多模态中，<strong>音频是最重要、最常见的模态之一</strong>，广泛出现在语音识别、合成、声纹、增强、音频检索、人机交互等应用中。</p><p>然而，相较于文本，音频具有以下特点：</p><ul><li><strong>连续性强</strong></li><li><strong>冗余度高</strong></li><li><strong>信息密度不均衡</strong></li></ul><p>这些特性使得音频难以直接建模，需要转化为系统或模型所能接受的表示形式，同时降低冗余信息并保留有用信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">思考问题1：声音是一种波，计算机中用什么方式存储？注：语音是连续信号，一般经数字化表示，电话8KHz采样率（即每秒8000个采样点，人声频率范围一般小于1KHz，8KHz满足香农采样定理要求），普通音质16KHz，高音质24KHz、48KHz甚至更高。<br></code></pre></td></tr></table></figure><p>在过去的几十年中，音频的表示形式经历了从人工特征工程到深度学习特征表示再到Neural Audio Codec的演进：</p><ul><li><strong>传统特征工程</strong>：如 MFCC、FBank 等，借鉴人类听觉机制设计，具有实现简单、计算高效等优势，但表达能力有限。</li><li><strong>深度学习表示</strong>：如自编码器（AE）、变分自编码器（VAE）的 latent 向量，或是基于 Transformer 的 HuBERT、Wav2Vec 等模型，在捕捉语音中的高层语义结构上表现更强。</li><li><strong>Neural Audio Codec</strong>：最近成为主流方向。这类方法将音频压缩为离散 token 序列，不仅方便大模型以自回归方式建模，还支持语音的高质量重建，使得音频的理解与生成任务可以统一建模。</li></ul><p><img src="/image/audiocodec_discrete.png" alt="音频离散token化(https://ravinkumar.com/GenAiGuidebook/audio/audio_tokenization.html)"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">思考问题<span class="hljs-number">2</span>：大模型建模如何融合文本和语音？一般人说话过程中平均每秒说几个字？哪种音频表示方法更适合大模型？注：每秒语音有<span class="hljs-number">16000</span>个采样点（以常见<span class="hljs-number">16</span>KHz语音为例），传统特征每秒<span class="hljs-number">40</span>~<span class="hljs-number">100</span>帧连续特征，Hubert等网络表示特征每秒<span class="hljs-number">50</span>帧连续特征，Neural <span class="hljs-built_in">Audio</span> Codec每秒<span class="hljs-number">26</span>~<span class="hljs-number">1000</span> 离散Token。<br></code></pre></td></tr></table></figure><hr><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>对目前出现的 Audio Tokenizer 进行整理，并详细列出码本数、码率等特性，便于对比分析。</p><table><thead><tr><th>Tokenizer</th><th>时间 &amp; 作者</th><th>码本数</th><th>Token Rate (Hz)</th><th>Bit Rate (kbps)</th><th>采样率 (kHz)</th><th>训练数据</th><th>应用</th></tr></thead><tbody><tr><td>SoundStream</td><td>2021.07 Google</td><td>8~80</td><td>75×码本数</td><td>3~18</td><td>24</td><td>LibriTTS、音乐</td><td>AudioLM</td></tr><tr><td>Encodec</td><td>2022.10 Facebook</td><td>2,4,8,16,32</td><td>75×码本数 / 150×码本数</td><td>1.5,3,6,12,24 / 3,6,12,24</td><td>24 / 48</td><td>Common-Voice, DAPS, Jamendo, AudioSet, FSD50K</td><td>VALLE</td></tr><tr><td>AudioDec</td><td>2023.05 Meta</td><td>8</td><td>1280</td><td>12.8</td><td>48</td><td>Valentini</td><td>-</td></tr><tr><td>AcademiCodec</td><td>2023.05 北大 &amp; 腾讯</td><td>4</td><td>-</td><td>2,3</td><td>16</td><td>LibriTTS, VCTK, AISHELL</td><td>-</td></tr><tr><td>DAC</td><td>2023.06 Descript</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>SpeechTokenizer</td><td>2023.08 复旦</td><td>8</td><td>-</td><td>4</td><td>16</td><td>LibriSpeech</td><td>SpeechGPT, AnyGPT</td></tr><tr><td>Funcodec</td><td>2023.09 阿里</td><td>32</td><td>-</td><td>16</td><td>16</td><td>LibriTTS、25K hours others</td><td>LauraGPT</td></tr><tr><td>CosyToken</td><td>2024.07 阿里</td><td>1</td><td>-</td><td>-</td><td>16</td><td>13wh ZH、3wh EN、5kh Yue、4.6kh JP、2.2kh KO</td><td>CosyVoice</td></tr><tr><td>Xcodec</td><td>2024.08 港科大 &amp; Microsoft</td><td>8</td><td>-</td><td>4</td><td>16</td><td>LibriSpeech</td><td>-</td></tr><tr><td>WavTokenizer</td><td>2024.08 浙大</td><td>1</td><td>40, 75</td><td>0.5, 0.9</td><td>24</td><td>LibriTTS、VCTK、CommonVoice、LibriLight 共80k小时</td><td>-</td></tr><tr><td>SemantiCodec</td><td>2024.05 萨里大学 &amp; 上海交大</td><td>-</td><td>25,50,100</td><td>0.31~1.40</td><td>16</td><td>GigaSpeech, VoiceFixer, Million Song, MedleyDB, MUSDB18, AudioSet</td><td>-</td></tr><tr><td>Mimi codec</td><td>2024.10 Kyutai</td><td>8</td><td>-</td><td>1.1</td><td>24</td><td>-</td><td>Moshi</td></tr><tr><td>Stable Codec</td><td>2024.11 Stability-AI</td><td>3</td><td>25, 50</td><td>0.4, 0.7</td><td>16</td><td>-</td><td></td></tr><tr><td>Step-Audio-Tokenizer</td><td>2025.02 stepfun-ai</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>BiCodec</td><td>2025.03 SparkAudio</td><td>1</td><td>50</td><td>0.65</td><td>16</td><td>LibriSpeech, Emilia-CN, Emilia-EN</td><td>Spark-TTS</td></tr><tr><td>ALMTokenizer</td><td>2025.04 港中大</td><td>3</td><td>37.5</td><td>0.41</td><td>24</td><td>LibriTTS, MLS, AudioSet, Million Song</td><td>-</td></tr><tr><td>higgs-audio-v2-tokenizer</td><td>2025.07 BosonAI</td><td>8</td><td>25×8</td><td>2.0</td><td>24</td><td>-</td><td>higgs-audio</td></tr></tbody></table><hr><h2 id="Neural-Audio-Codec-模型详解"><a href="#Neural-Audio-Codec-模型详解" class="headerlink" title="Neural Audio Codec 模型详解"></a>Neural Audio Codec 模型详解</h2><h3 id="SoundStream-2021-07"><a href="#SoundStream-2021-07" class="headerlink" title="SoundStream (2021.07)  "></a>SoundStream (2021.07) <a href="https://arxiv.org/pdf/2107.03312"><img src="https://img.shields.io/badge/arXiv-2107.03312-b31b1b.svg?logo=arXiv" alt="arXiv"></a> <a href="https://github.com/lucidrains/vector-quantize-pytorch"><img src="https://img.shields.io/badge/Github-Unofficial-lucidrains/vector--quantize--pytorch.svg?logo=github" alt="code"></a></h3><p>SoundStream 是由 Google Research 的 Neil Zeghidour 等人在 2021 年提出的，可以说是 Neural Audio Codec 方向的开山之作。值得一提的是，Neil Zeghidour 也是 Moshi 的主要作者，在音频建模领域贡献颇多。<br>SoundStream 的提出标志着一种新范式的开始：利用端到端神经网络对音频进行压缩，并生成离散化的 token 表达，以支持下游建模任务，特别适合与大语言模型对接。</p><h4 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h4><p>整体架构采用 编码器-量化器-解码器（Encoder-RVQ-Decoder） 的方式，具体来说：</p><ul><li>Encoder 将原始波形压缩为低维表示；</li><li>Residual Vector Quantization（RVQ） 将连续表示离散化为多组 token；分多级量化器，每级负责编码残差信息，逐步逼近原始向量。</li><li>Decoder 从离散 token 重建出原始音频。</li></ul><p><img src="/image/audiocodec_soundstream.png" alt="SoundStream模块框架"></p><h4 id="RVQ算法"><a href="#RVQ算法" class="headerlink" title="RVQ算法"></a>RVQ算法</h4><p>在 Neural Audio Codec 中，最关键的一步是如何将连续信号离散化为 token 表示。SoundStream 使用了 Residual Vector Quantization（RVQ） 技术，其主要思想是分多级量化器，每级负责编码残差信息，从而逐步逼近原始向量。更多详细解读<br><img src="/image/audiocodec_soundstream_rvq.png" alt="RVQ"></p><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>SoundStream 在语音重建质量上优于传统压缩方法（如 Opus），尤其在低比特率下依然保持不错的主观听感。其强大的表示能力也使其适用于后续的语音合成、生成、编辑等任务。<br><img src="/image/audiocodec_soundstream_result.png" alt="SoundStream效果"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>SoundStream 是 Neural Audio Codec 方向的奠基之作，不仅首次系统性地提出神经音频压缩框架，也确立了 RVQ 作为音频离散化的核心技术路径。虽然机制并不复杂，但在实际中非常高效，影响了后续整个音频tokenization领域的发展。</p><hr><h3 id="EnCodec-2022-10"><a href="#EnCodec-2022-10" class="headerlink" title="EnCodec(2022.10)   "></a>EnCodec(2022.10) <a href="https://arxiv.org/abs/2210.13438"><img src="https://img.shields.io/badge/arXiv-2210.13441-b31b1b.svg?logo=arXiv" alt="arXiv"></a> <a href="https://github.com/facebookresearch/encodec"><img src="https://img.shields.io/badge/Github-Code-facebookresearch/encodec.svg?logo=github" alt="code"></a> <a href="https://github.com/facebookresearch/encodec"><img src="https://img.shields.io/badge/%F0%9F%A4%97%20Hugging_Face-EnCodec-blue.svg" alt="model"></a></h3><p>EnCodec 是 Meta AI 于 2022 年提出的 Neural Audio Codec 模型，作为对 SoundStream 框架的延续和改进，它同样采用了 Residual Vector Quantization（RVQ） 技术，并在音频质量、适用范围和开源支持方面做了全面升级:</p><ul><li><strong>多采样率支持</strong>：EnCodec 同时支持 24kHz 和 48kHz 音频信号，覆盖语音和高保真音频等不同应用场景；</li><li><strong>多比特率可调</strong>：提供从 1.5 到 24 kbps 的多个比特率选项，适用于不同带宽和重建质量的需求；</li><li><strong>延续 RVQ 框架</strong>：与 SoundStream 一样，EnCodec 使用多层残差量化器将音频编码为离散 token 序列，使得大模型可以直接用于建模；</li><li><strong>开源可复现性强</strong>：Meta 提供了完整的代码、模型权重与示例脚本，极大地推动了社区在音频离散化方向的研究与落地。</li><li><strong>影响力广泛</strong>：微软提出的端到端语音合成模型VALLE，直接采用 EnCodec 生成离散语音 token；Meta 的音乐生成模型MusicGen，也使用 EnCodec 作为音乐 tokenization 的底层模块；</li></ul><h4 id="模型架构-1"><a href="#模型架构-1" class="headerlink" title="模型架构"></a>模型架构</h4><p>EnCodec 仍采用编码器-量化器-解码器的标准框架。相比 SoundStream，EnCodec 在编码器与解码器的架构上进行了优化，引入了更深层次的卷积模块与归一化技术，提升了压缩后的重建质量。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>EnCodec 在保持高压缩效率的同时提供更高的可控性和更好的重建质量，是 Neural Audio Codec 技术的重要里程碑。其高质量开源实现加速了音频 tokenization 技术的工程化应用，也为大模型时代的多模态建模奠定了坚实基础。</p><hr><h3 id="SemantiCodec-2024-05"><a href="#SemantiCodec-2024-05" class="headerlink" title="SemantiCodec (2024.05)   "></a>SemantiCodec (2024.05) <a href="https://arxiv.org/pdf/2405.00233"><img src="https://img.shields.io/badge/arXiv-2405.00233-b31b1b.svg?logo=arXiv" alt="arXiv"></a> <a href="https://github.com/haoheliu/SemantiCodec-inference"><img src="https://img.shields.io/badge/Github-Code-haoheliu/SemantiCodec--inference.svg?logo=github" alt="code"></a> <a href="https://haoheliu.github.io/SemantiCodec/"><img src="https://img.shields.io/badge/%F0%9F%93%BA%20Demo-SemantiCodec-blue.svg" alt="demo"></a></h3><p>SemantiCodec 是由萨里大学与上海交通大学联合提出的一种极低码率的开源 Audio Tokenizer，专为语义理解与生成任务设计。其核心创新在于显式建模语义与声学特征的联合表示，以支持更强的语义能力与灵活的压缩率选择。<br>强语义建模能力：通过引入 AudioMAE 语义嵌入，提升离散表示的语义表达力；<br>丰富的 TokenRate 与 BitRate 选择：支持 25、50、100 tokens/s 三档 TokenRate，对应比特率范围为 0.31~1.43 Kbps，便于适配不同带宽和任务需求。具体如下图所示：</p><p><img src="/image/audiocodec_semantic_codec_rate.png" alt="SemantiCodec TokenRate and BitRate"></p><h4 id="模型架构-2"><a href="#模型架构-2" class="headerlink" title="模型架构"></a>模型架构</h4><ul><li>语义编码：首先从输入音频中提取 AudioMAE 嵌入，并通过 K-Means 聚类量化为语义表示 $E_s$；</li><li>声学补全：将原始音频帧 $Y$ 与语义表示 $E_s$ 拼接输入 Residual Encoder，提取细粒度声学信息；</li><li>向量量化：上述声学向量经 VQ 模块量化为 $E_a$；</li><li>融合表示：最终音频表示 $E$ 由 $E_s$ 与 $E_a$ 拼接构成，用于音频重建；</li><li>生成器：使用 Latent Diffusion Model 在条件表示 $E$ 上进行音频生成。</li></ul><p><img src="/image/audiocodec_semantic_codec.png" alt="SemantiCodec模型框架"></p><h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><p>在主观音质评估基准 MUSHRA 上，SemantiCodec 明显优于 Encodec、Descript 等方法，尤其在低码率条件下表现出更好的听感质量。</p><p><img src="/image/audiocodec_semantic_codec_result.png" alt="SemantiCodec效果"></p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>SemantiCodec 是一款支持 极低 BitRate 与 TokenRate 的开源 Audio Codec，具备可调节压缩粒度、显式语义建模、高保真语音重建等特点，非常适合用于语音理解、多模态交互等大模型应用场景。</p><hr><h3 id="WavTokenizer-2024-08"><a href="#WavTokenizer-2024-08" class="headerlink" title="WavTokenizer (2024.08)   "></a>WavTokenizer (2024.08) <a href="https://arxiv.org/pdf/2408.16532"><img src="https://img.shields.io/badge/arXiv-2408.16532-b31b1b.svg?logo=arXiv" alt="arXiv"></a> <a href="https://github.com/jishengpeng/WavTokenizer"><img src="https://img.shields.io/badge/Github-Code-jishengpeng/WavTokenizer.svg?logo=github" alt="code"></a> <a href="https://huggingface.co/novateur/WavTokenizer"><img src="https://img.shields.io/badge/%F0%9F%A4%97%20Hugging_Face-WavTokenizer-blue.svg" alt="model"></a></h3><p>WavTokenizer 是浙江大学联合阿里巴巴于 2024 年 8 月提出的一种面向大语言模型的 Neural Audio Codec，后被 ICLR 2025 接收。该方法以约 8000 小时多语种语音数据训练为基础，核心目标是更好地服务于多模态大模型需求。其设计强调两大核心指标：</p><ul><li><strong>更高的压缩率</strong>：支持 40 或 75 tokens/s 的极低 Token Rate，显著减少下游模型的计算开销。</li><li><strong>更丰富的语义表达</strong>：在主观语义评估中取得 SOTA 表现，提升了生成任务中的理解与控制能力。</li></ul><h4 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h4><ul><li>Encoder：基于卷积网络将输入音频编码为潜在连续特征表示$Z$</li><li>A single quantizer：将 $Z$ 单层量化，得到离散表示  $Z_g$</li><li>Decoder：将 $Z_g$ 重构成语音信号</li></ul><h4 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h4><p>WavTokenizer重构语音的UTMOS得分达到SOTA<br><img src="/image/audiocodec_wavtokenizer_result.png" alt="WavTokenizer 效果"></p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>WavTokenizer 具备<strong>极低的 Token Rate（最低可达 40 tokens/s）</strong>，高度契合多模态大模型的建模需求。同时，依托大规模语音数据训练，其离散表示包含丰富的语义信息，支持语义理解与语音生成双重任务，在语音重构质量上也达到了当前最优水平。</p><hr><h3 id="Stable-Codec-2024-11"><a href="#Stable-Codec-2024-11" class="headerlink" title="Stable Codec (2024.11)   "></a>Stable Codec (2024.11) <a href="https://arxiv.org/pdf/2411.19842v1"><img src="https://img.shields.io/badge/arXiv-2411.19842-b31b1b.svg?logo=arXiv" alt="arXiv"></a> <a href="https://github.com/Stability-AI/stable-codec"><img src="https://img.shields.io/badge/Github-Code-Stability--AI/stable--codec.svg?logo=github" alt="code"></a> <a href="https://huggingface.co/stabilityai/stable-codec-speech-16k"><img src="https://img.shields.io/badge/%F0%9F%A4%97%20Hugging_Face-stable--codec--speech--16k-blue.svg" alt="model"></a></h3><p>Stable Codec 是 Stability AI 于 2024 年 11 月发布的开源 Neural Audio Codec，专为大模型时代的语音建模需求而设计。该模型在超低码率（400bps / 700bps）下仍保持高保真度重建，为多模态大模型中的音频输入提供了极具竞争力的离散表示方案。</p><h4 id="模型架构-3"><a href="#模型架构-3" class="headerlink" title="模型架构"></a>模型架构</h4><ul><li><strong>Encoder / Decoder</strong>：基于自注意力机制的对称结构；</li><li><strong>Finite Scalar Quantization（FSQ）</strong>：替代传统 RVQ 的新型量化方式，采用固定范围标量量化，将连续表示压缩为离散 token。FSQ 简洁高效，推理速度快，且更适用于低码率场景；</li><li><strong>极低码率支持</strong>：支持 400bps、700bps 等超低比特率设置，在极限压缩下仍保持较高音质。</li></ul><p><img src="/image/audiocodec_stable_codec.png" alt="Stable Codec 模型框架"></p><h4 id="FSQ-V-S-VQ"><a href="#FSQ-V-S-VQ" class="headerlink" title="FSQ V.S. VQ"></a>FSQ V.S. VQ</h4><p>这里提到了FSQ，为了有更直观的认识，这里列出二者的差异。</p><p>下图举例对比FSQ和VQ的差异：</p><p><img src="/image/audiocodec_fsq.png" alt="FSQ V.S. VQ(https://github.com/lucidrains/vector-quantize-pytorch/blob/master/images/fsq.png)"></p><p>下表从不同维度详细对比FSQ和VQ的差异：</p><table><thead><tr><th>属性</th><th>FSQ</th><th>VQ</th></tr></thead><tbody><tr><td>量化方式</td><td>round(f(z))</td><td>argmin_c || z-c ||</td></tr><tr><td>量化单位</td><td>每个维度单独量化</td><td>整个向量最近邻</td></tr><tr><td>编码方式</td><td>标量量化（整数）</td><td>码本索引</td></tr><tr><td>并行性</td><td>高（可并行）</td><td>低（需查找）</td></tr><tr><td>表达粒度</td><td>粗，从坐标轴限制（维度独立）</td><td>细，全局表示能力较强（跨维度）</td></tr><tr><td>实现复杂度</td><td>低</td><td>高</td></tr></tbody></table><p>整体而言：</p><ul><li>FSQ 是把高维输出按坐标轴切割成格子，每维分别处理；</li><li>VQ 是把输出投到一个高维超立方体的码本格点上，整体处理。</li></ul><h4 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4><p>在MUSHRA 主观评测中，Stable Codec 的表现优于其他同类模型如 Mimi 和 SemanticCodec，其音质在主观评分中接近真实语音（Ground Truth）。<br><img src="/image/audiocodec_stable_codec_mushra.png" alt="Stable Codec MUSHRA效果对比"></p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>Stable Codec 凭借其<strong>超低码率、高音质、Transformer 架构与 FSQ 创新量化方式</strong>，是语音大模型中的<strong>潜力型</strong> Audio Tokenizer 方案。其设计思路代表了 Neural Audio Codec 向更轻量、更高效、更大模型友好方向的发展趋势。</p><hr><h3 id="XY-Tokenizer-2025-07"><a href="#XY-Tokenizer-2025-07" class="headerlink" title="XY-Tokenizer (2025.07)   "></a>XY-Tokenizer (2025.07) <a href="https://www.open-moss.com/cn/moss-ttsd/"><img src="https://img.shields.io/badge/Blog-MOSS--TTSD-blue.svg?logo=googlechrome" alt="blog"></a> <a href="https://github.com/OpenMOSS/MOSS-TTSD"><img src="https://img.shields.io/badge/Github-Code-OpenMOSS/MOSS--TTSD.svg?logo=github" alt="code"></a> <a href="https://huggingface.co/fnlp/MOSS-TTSD-v0.5"><img src="https://img.shields.io/badge/%F0%9F%A4%97%20Hugging_Face-XY__Tokenizer__TTSD__V0.5-blue.svg" alt="model"></a></h3><p>XY-Tokenizer是复旦大学邱锡鹏团队推出的MOSS-TTSD项目中提出的离散Tokenizer。<br>实现了统一建模语音的语义和声学信息，支持低比特率（1 Kbps）与低帧率（12.5Hz），适用于高效语音生成任务。</p><h4 id="模型框架-1"><a href="#模型框架-1" class="headerlink" title="模型框架"></a>模型框架</h4><p>模型使用了双路 Whisper Encoder 进行语音编码，8层 RVQ 量化。<br>训练分为两个阶段，采用多任务学习策略：<br>阶段一：语义对齐 + 声学保持训练。ASR任务和重建任务，让编码器在编码语义信息的同时保留粗粒度的声学信息。<br>阶段二：生成式声学细化。固定住编码器和量化层部分，只训练解码器部分。通过重建损失和 GAN 损失，利用生成式模型的能力补充细粒度声学信息。<br><img src="/image/audiocodec_xy_tokenizer.png" alt="XY-Tokenizer"></p><h4 id="效果-4"><a href="#效果-4" class="headerlink" title="效果"></a>效果</h4><ul><li>使用 10 万小时转录语音数据进行基础训练，确保语义编码质量；</li><li>引入 50 万小时无标注语音数据 进行扩展训练，有效增强模型对复杂对话语音及多场景语音的建模能力；</li><li>支持最长 960 秒语音输入，在超长语音建模方面表现出色。<br><img src="/image/audiocodec_xy_tokenizer_result.png" alt="XY-Tokenizer效果"></li></ul><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>XY-Tokenizer 在低比特率（1 Kbps）和低帧率（12.5 Hz）下，同时实现了高质量的语义表示和声学重建能力。其两阶段训练策略和海量多样化数据的支持，使其在真实对话音频生成与理解任务中具有较高潜力。</p><hr><h3 id="higgs-audio-v2-tokenizer-2025-07"><a href="#higgs-audio-v2-tokenizer-2025-07" class="headerlink" title="higgs-audio-v2-tokenizer (2025.07)   "></a>higgs-audio-v2-tokenizer (2025.07) <a href="https://github.com/boson-ai/higgs-audio/blob/main/tech_blogs/TOKENIZER_BLOG.md"><img src="https://img.shields.io/badge/Blog-Github-blue.svg?logo=github" alt="blog"></a> <a href="https://github.com/boson-ai/higgs-audio"><img src="https://img.shields.io/badge/Github-Code-boson--ai/higgs--audio.svg?logo=github" alt="code"></a> <a href="https://huggingface.co/bosonai/higgs-audio-v2-tokenizer"><img src="https://img.shields.io/badge/%F0%9F%A4%97%20Hugging_Face-higgs--audio--v2--tokenizer-blue.svg" alt="model"></a></h3><p>higgs-audio-v2-tokenizer是李沐老师创业公司BosonAI于2025年7月发布的开源Audio Codec，具备极低帧率、适合多模态大模型建模。</p><h4 id="模型架构-4"><a href="#模型架构-4" class="headerlink" title="模型架构"></a>模型架构</h4><ul><li><strong>语义-声学分离融合建模</strong>：分别对 语义信息（Semantic） 和 声学信息（Acoustic） 进行独立建模，然后在量化前进行融合，使得 token 表达同时具备语义可控性与音频细节；</li><li><strong>Residual Vector Quantization（RVQ）</strong>：延续了业界主流的离散化方式，保证生成质量与 token 稠密度的平衡；</li><li><strong>极低帧率（25fps）</strong>：极大减少了 token 数量，更适合接入 LLM 进行多模态建模和语音生成任务。</li></ul><p><img src="/image/audiocodec_higgs_audio_tokenizer.png" alt="higgs-audio-v2-tokenizer 模型框架"></p><h4 id="效果-5"><a href="#效果-5" class="headerlink" title="效果"></a>效果</h4><p>语义效果评估采用了（Seed-TTS eval）作为评测集，在更低比特率（BitRate）设定下，模型在语义一致性方面可与 Mimi 相媲美，表现出良好的生成对齐能力。 </p><p><img src="/image/audiocodec_higgs_audio_tokenizer_semantic.png" alt="higgs-audio-v2-tokenizer 语义效果"></p><p>在声学效果评估方面，采用了 STFT metric 作为评估指标。评测集由 4 个子集组成： <a href="https://ccrma.stanford.edu/~gautham/Site/daps.html">DAPS</a>（Speech）、<a href="https://sigsep.github.io/datasets/musdb.html">MUSDB</a>（Music）、<a href="https://research.google.com/audioset/index.html">AudioSet</a>（Sound Event）以及 Audiophile（高保真音乐）。在多种类型音频上，模型在细节保留与主观感知质量上均达到高水平。</p><p><img src="/image/audiocodec_higgs_audio_tokenizer_acoustic.png" alt="higgs-audio-v2-tokenizer 声学效果"></p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>higgs-audio-v2-tokenizer 是一款专为语音大模型设计的高效 Audio Tokenizer，其创新的语义-声学分离融合机制和极低帧率设计，显著降低了建模成本，同时保持了出色的语音还原质量。它不仅为 Higgs Audio 提供Tokenizer支持，也为语音大模型的Tokenizer提供了有价值的借鉴。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Audio-Tokenizer成为大模型的关键技术"><a href="#Audio-Tokenizer成为大模型的关键技术" class="headerlink" title="Audio Tokenizer成为大模型的关键技术"></a>Audio Tokenizer成为大模型的关键技术</h3><p>随着大模型能力的不断延展，多模态甚至全模态的大模型正在深刻变革语音技术的传统范式。语音任务正在从以模块化、定制化为主的架构，逐步转向由统一大模型驱动的端到端解决方案。</p><p>单点的语音能力也在向大模型方向演进，以语音识别为例，OpenAI 的 Whisper 模型在通用场景下的表现已显著优于传统的定制小模型，凭借大数据预训练和强鲁棒性，在多语言、多口音、嘈杂环境下依然具备出色性能。这类“预训练+指令微调”的语音大模型方案，正逐渐成为语音识别的新主流， 具体可以参考：<a href="https://zhuanlan.zhihu.com/p/662906303">OpenAI Whisper 新一代语音技术(更新至v3-turbo)</a></p><p>大模型已不再局限于感知层的“识别”，而是逐步向“理解”和“生成”扩展。语音模态和大模型深度融合，也已经有很多相关工作了，虽然在端到端语音交互能力方面和传统级联方案略有逊色，但是在语音理解和生成能力方面已经远超过传统的单一能力模型，具体可以参考语音大模型概述：<a href="https://zhuanlan.zhihu.com/p/14831605089">语音大模型概述</a></p><p>尽管当前端到端语音交互模型在一些低资源场景下仍存在响应速度或精度的差距，但其多任务泛化能力和统一建模框架的优势，已在多个应用方向展现出巨大的潜力。</p><p>展望未来，<strong>音频模态与大模型的深度融合</strong>已成为语音领域的技术主旋律，而 <strong>Audio Tokenizer 的演进</strong>，则是这一趋势背后的关键基石。</p><h3 id="Audio-Tokenizer的演进趋势"><a href="#Audio-Tokenizer的演进趋势" class="headerlink" title="Audio Tokenizer的演进趋势"></a>Audio Tokenizer的演进趋势</h3><ul><li><strong>极致压缩、更低的TokenRate</strong>：开篇提到的挑战，语音相比文本有更长的序列，即便目前较低的tokenrate，达到25token/s，相比于文本的大概3-4token/s，仍然有6倍的差异。继续把语音压缩到更低的TokenRate，有助于语音与文本的模态融合与对齐。</li><li><strong>全面的信息表示</strong>：在极致压缩下，保留语义信息、副语言信息、声学信息等，才能实现后续的音频相关各项任务。</li></ul><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://ravinkumar.com/GenAiGuidebook/audio/audio_tokenization.html">Audio Tokenization: An Overview</a></li><li><a href="https://arxiv.org/pdf/2406.10735v1">How Should We Extract Discrete Audio Tokens from Self-Supervised Models?</a></li><li><a href="https://github.com/lucidrains/vector-quantize-pytorch">Vector Quantization in PyTorch</a></li><li><a href="https://drscotthawley.github.io/blog/posts/2023-06-12-RVQ.html">Residual Vector Quantization: An exploration of the heart of neural audio codecs</a></li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>大模型</tag>
      
      <tag>多模态</tag>
      
      <tag>Tokenizer</tag>
      
      <tag>audio codec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语音大模型概述</title>
    <link href="/2024/12/23/speech-llm/"/>
    <url>/2024/12/23/speech-llm/</url>
    
    <content type="html"><![CDATA[<p>写在最前面：访问<a href="https://zhuanlan.zhihu.com/p/14831605089">我的知乎同款文章</a></p><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h2 id="语音大模型是什么？"><a href="#语音大模型是什么？" class="headerlink" title="语音大模型是什么？"></a>语音大模型是什么？</h2><p>2024年5月，OpenAI的GPT-4o发布，自然流畅的人机对话、强大的语音理解与多样化的语音回复、极低的延迟（0.3秒，与人类相当）让人印象深刻。<br>这使得研究者们重拾了对语音交互的热情，而且由于大语言模型的加持，语音交互的能力边界大幅提升。理想的语音大模型像人一样，应该具备：高质量语音理解（听）与回复（说）、多轮对话、低延迟、实时对话。<br>语音大模型（speech large language model, SpeechLLMs）亦有称之为语音对话模型（spoken dialogue models），本文统称之为语音大模型。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The fundamental definition <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> spoken dialogue model refers <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> dialogue <span class="hljs-keyword">system</span> capable <span class="hljs-keyword">of</span> generating intelligent verbal responses based <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">input</span> <span class="hljs-title">speech</span>. <br></code></pre></td></tr></table></figure><p>上面是对语音大模型的一种定义，可以简单地定义为：和人一样能听会说的智能系统。</p><h2 id="历史回顾"><a href="#历史回顾" class="headerlink" title="历史回顾"></a>历史回顾</h2><p>在大模型时代之前（Pre-LLM Stage），语音技术各个细分方向相对独立，包括语音识别、语音合成、语音增强、语音分离、声音事件监测、说话人识别等等。<br>随着深度学习的发展(Early-LLM Stage)，语音技术开始进入预训练阶段，基于模型和大数据量的语音特征和表示。例如wav2vec、Hubert，大幅提升了模型效果。<br>进入大模型时代(SpeechLLM Stage)，语音技术各个细分方向开始融合，更细分的任务融合成一个任务，例如声音复刻和语音合成融合为Zero-Shot TTS。语音技术开始走向“大一统”：语音大模型。<br><img src="/image/speechllm_timeline_1.png" alt="语音技术演进，图片参考A SURVEY ON SPEECH LARGE LANGUAGE MODELS"></p><h2 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h2><p>2022年之前，语音技术结合LLMs的工作开始萌芽。<br>2023年，紧跟LLMs的步伐，语音大模型相关工作开始涌现。<br>2024年，语音大模型相关研究更加深入，围绕高质量语音、全双工交互等热点难点。<br><img src="/image/speechllm_timeline.png" alt="语音大模型时间线，图片参考WavChat"></p><h2 id="技术路径"><a href="#技术路径" class="headerlink" title="技术路径"></a>技术路径</h2><p>在大模型时代之前，实现一个人机语音对话系统是非常繁杂的，涉及多个模块：语音识别、意图识别、对话管理、对话生成、语音合成等模块。<br><img src="/image/speechllm_traditional_dialog.jpg" alt="传统人机语音交互"></p><p>在大模型时代，使用LLMs取代意图识别、对话管理、对话生成等多个模块，让人机对话系统变得简单且更加强大。根据模型是否能够直接理解和生成语音，分为级联、端到端两种技术路径：</p><ul><li><strong>级联(Cascaded)</strong>: 语音识别（ASR）、LLM、语音合成（TTS）三部分级联构成。构建成本较低、各模块成熟且相对独立；但是能力潜力小、信息丢失（例如丢失情感信息）、延迟较大。典型例子有<a href="https://github.com/AIGC-Audio/AudioGPT">AudioGPT</a>。</li><li><strong>端到端(End-to-end)</strong>: 一个模型实现语音的输入和输出。系统简单、能力（潜力）强、延迟低；构建成本较大、依赖大量的训练数据。典型例子有<a href="https://github.com/kyutai-labs/moshi/">Moshi</a>。</li></ul><p>下图是级联系统与端到端系统的对比，可以看到两种系统中也分别有两种不同的技术路径，从上到下从完全的级联到完全的端到端。<br><img src="/image/speechllm_system_cmp.png" alt="级联与端到端系统对比，图片参考WavChat"></p><p>下表是OpenAI的语音模式，GPT-4o是端到端的方式，GPT-3.5和GPT-4都是级联的方式，无论是副语言信息的理解和多样化表达，还是整体的延迟，GPT-4o都大幅领先，使用体验提升明显。</p><table><thead><tr><th>Feature</th><th>GPT-3.5</th><th>GPT-4</th><th>GPT-4o</th><th>Moshi</th></tr></thead><tbody><tr><td><strong>Architecture</strong></td><td>ASR + GPT-3.5 + TTS</td><td>ASR + GPT-4 + TTS</td><td>A single end-to-end model</td><td>A single end-to-end model</td></tr><tr><td><strong>Acoustic Information</strong></td><td>×</td><td>×</td><td>√ (speaker, background, emotion…)</td><td>√</td></tr><tr><td><strong>Expressive Audio Response</strong></td><td>×</td><td>×</td><td>√ (laughter, emotion, singing…)</td><td>Multi emotions &amp; styles</td></tr><tr><td><strong>Latency</strong></td><td>2.8s</td><td>5.4s</td><td>0.32s</td><td>0.23s average (minimum 0.16s)</td></tr></tbody></table><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>这部分先介绍语音大模型的一般模块组成，然后介绍几个典型的语音大模型。</p><h2 id="模块组成"><a href="#模块组成" class="headerlink" title="模块组成"></a>模块组成</h2><p>语音大模型一般由三个模块组成：</p><ul><li>语音编码器(Speech Tokenizer): 有两类典型的Tokenizer，一种是Whisper Encoder，连续空间表示语音；另一种是RVQ结构的Neural Codec Encoder，离散空间表示语音。</li><li>大语言模型(Large Language Models): 各种语言模型均可。</li><li>语音合成器(Token-to-Speech Synthesizer): 和上述Speech Tokenizer相对应，前者对应典型的合成器，例如HiFi-GAN等；后者对应Neural Codec Decoder。</li></ul><p><img src="/image/speechllm_component.png" alt="语音大模型模块组成，图片参考Recent Advances in Speech Language Models: A Survey"></p><h2 id="SpeechGPT"><a href="#SpeechGPT" class="headerlink" title="SpeechGPT  "></a>SpeechGPT <a href="https://arxiv.org/abs/2305.11000"><img src="https://img.shields.io/badge/arXiv-2305.11000-b31b1b.svg?logo=arXiv" alt="arXiv"></a> <a href="https://github.com/0nutation/SpeechGPT"><img src="https://img.shields.io/badge/Github-Code-keygen.svg?logo=github" alt="code"></a></h2><p>SpeechGPT是于2023年5月份，复旦大学提出来的语音大模型。</p><h3 id="模块组成-1"><a href="#模块组成-1" class="headerlink" title="模块组成"></a>模块组成</h3><table><thead><tr><th>Speech Tokenizer</th><th>LLM</th><th>Speech Detokenizer</th></tr></thead><tbody><tr><td>Hubert</td><td>LLaMA-13B</td><td>unit based HiFi-GAN</td></tr></tbody></table><h3 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="/image/speechllm_speechgpt.png" alt="SpeechGPT模型框架"></p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><ol><li>阶段1：词表扩充&amp;模态自适应。基于6万小时的无标注LibriLight语音数据。</li><li>阶段2：跨模态指令微调。训练数据包括1万小时GigaSpeech、3千小时CommonVoice、1千小时LibriSpeech。</li><li>阶段3：Chain-of-Modality Instruction Fine-Tuning。从moss-002-sft-data数据集中挑选的37,969条样本。</li></ol><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>SpeechGPT 是将文本和语音模态融合到LLMs的一次尝试，让LLMs具备了语音理解和生成能力。</li><li>由于Chain-of-Modality的机制，SpeechGPT无法实现实时交互，只能是半双工交互。</li></ul><h2 id="VITA"><a href="#VITA" class="headerlink" title="VITA   "></a>VITA <a href="https://arxiv.org/abs/2408.05211"><img src="https://img.shields.io/badge/arXiv-2408.05211-b31b1b.svg?logo=arXiv" alt="arXiv"></a>  <a href="https://github.com/VITA-MLLM/VITA"><img src="https://img.shields.io/badge/Github-Code-keygen.svg?logo=github" alt="code"></a></h2><p>VITA是2024年8月由腾讯优图推出的多模态交互模型。</p><h2 id="LLaMA-Omni"><a href="#LLaMA-Omni" class="headerlink" title="LLaMA-Omni  "></a>LLaMA-Omni <a href="https://arxiv.org/abs/2409.06666"><img src="https://img.shields.io/badge/arXiv-2409.06666-b31b1b.svg?logo=arXiv" alt="arXiv"></a> <a href="https://github.com/ictnlp/LLaMA-Omni"><img src="https://img.shields.io/badge/Github-Code-keygen.svg?logo=github" alt="code"></a></h2><p>LLaMA-Omni 是中科院计算所于2024年9月份发布出来的语音大模型。<br>LLaMA-Omni用少量的数据和算力成本，构建了LLaMA的语音模态能力。</p><h3 id="模块组成-2"><a href="#模块组成-2" class="headerlink" title="模块组成"></a>模块组成</h3><table><thead><tr><th>Speech Tokenizer</th><th>LLM</th><th>Speech Detokenizer</th></tr></thead><tbody><tr><td>whisper-large-v3 encoder</td><td>LLaMA-3.1</td><td>unit base HiFi-GAN</td></tr></tbody></table><h3 id="模型框架-1"><a href="#模型框架-1" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="/image/speechllm_llamaomni.png" alt="LLaMA-Omni模型框架"></p><h3 id="模型训练-1"><a href="#模型训练-1" class="headerlink" title="模型训练"></a>模型训练</h3><p>LLaMA-Omni采用两阶段训练：</p><ol><li>阶段1：基于语音指令，生成文本回复。Speech Adaptor、LLMs参与模型训练。</li><li>阶段2：基于语音指令，生成语音回复。LLMs、Speech Decoder参与模型训练。</li></ol><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li>基于Whisper Encoder融合语音模态，最大程度减少了对LLMs的影响，保持了LLMs本身的能力。较少的训练数据即可实现模型搭建。</li><li>引入CTC、采用chunk机制合成语音，降低语音回复的延迟。</li><li>虽然LLaMA-Omni有较低的延迟，但其本质仍是半双工交互方式，不支持打断。</li></ul><h2 id="Moshi"><a href="#Moshi" class="headerlink" title="Moshi  "></a>Moshi <a href="https://arxiv.org/pdf/2410.00037"><img src="https://img.shields.io/badge/arXiv-2410.00037-b31b1b.svg?logo=arXiv" alt="arXiv"></a> <a href="https://github.com/kyutai-labs/moshi"><img src="https://img.shields.io/badge/Github-Code-keygen.svg?logo=github" alt="code"></a></h2><p>Moshi由法国初创团队Kyutai开发的对标GPT-4o的语音交互模型，7月份发布，10月份公布了技术报告并开源了模型。<br>Moshi是一个多流的语音到语音的Transformer模型，支持全双工交互。</p><h3 id="模块组成-3"><a href="#模块组成-3" class="headerlink" title="模块组成"></a>模块组成</h3><table><thead><tr><th>Speech Tokenizer</th><th>LLM</th><th>Speech Detokenizer</th></tr></thead><tbody><tr><td>Mimi Encoder (12.5Hz x 8 Codebooks)</td><td>Helium-7B (As Temporal Transformer) &amp; Depth Transformer (6 layers, d=1024, 16 heads)</td><td>Mimi Decoder</td></tr></tbody></table><h3 id="模型框架-2"><a href="#模型框架-2" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="/image/speechllm_moshi.png" alt="Moshi模型框架"></p><p>上图是Moshi的模型框架，几个特点：</p><ul><li>Multi-stream：用户语音输入、Moshi语音输出、内心独白。为自然语音交互做好了底层设计，可以同时听和说，支持用户打断。</li><li>Neural Codec：Mimi为了更低比特率、流式编解码、同时包含语义和声学信息，做了针对性设计。</li><li>RQ-Transformer：包含Temporal Transformer和Depth Transformer，TemporaryTransformer处理时间步S，DepthTransformer进一步扩展到多个流。这样，将O(S*K)计算复杂度（S为时间步，K为序列/多流个数）大约减少为O(S)个计算步。</li></ul><p>Mimi是Neural Codec，输入24KHz音频，输出12.5Hz的8个Codec，每个取值范围2048，第一个是VQ从WavLM中蒸馏学习语义信息，其他的7个为RVQ。<br><img src="/image/speechllm_mimi.png" alt="Mimi框架"></p><h3 id="模型训练-2"><a href="#模型训练-2" class="headerlink" title="模型训练"></a>模型训练</h3><ol><li>阶段1：Helium-7B 语言模型预训练。基于大量的文本数据。</li><li>阶段2：Moshi预训练。单流建模，文本和语音模态对齐。基于Whisper转写的7百万小时弱监督预训练数据。</li><li>阶段3：Moshi后训练。扩展到多流建模，让模型具备同时听和说的能力。采用了2千小时的电话数据集Fisher，8KHz采样率升采样到24KHz。</li><li>阶段4：Moshi微调。基于170小时自然对话，学习具有语音交叠的实时对话能力。基于2万小时包含70种说话风格的单说话人合成数据，使得Moshi具备固定音色。<br>值得一提的是，阶段3的训练，多流建模增加了Moshi的内心独白（Inner Monologue），也就是Moshi 生成语音相对应的文本，对应下图中Moshi stream的Text tokens。内心独白可以提升生成文本和语音的质量。<br><img src="/image/speechllm_moshi_multistream.png" alt="Moshi多流建模"></li></ol><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>Moshi对标GPT-4o，实现了多样化语音理解与生成的全双工语音交互。</li><li>Moshi的构建成本很高，需要大量的文本和语音数据，需要大量的算力。</li><li>Moshi的建模方式可以看做是一种‘原生多模态’的建模方式，相比于模态融合，其难度更高，还有很多值得探索。</li></ul><h2 id="GLM-4-Voice"><a href="#GLM-4-Voice" class="headerlink" title="GLM-4-Voice  "></a>GLM-4-Voice <a href="https://arxiv.org/abs/2412.02612"><img src="https://img.shields.io/badge/arXiv-2412.02612-b31b1b.svg?logo=arXiv" alt="arXiv"></a> <a href="https://github.com/THUDM/GLM-4-Voice"><img src="https://img.shields.io/badge/Github-Code-keygen.svg?logo=github" alt="code"></a></h2><p>GLM-4-Voice是智谱于2024年10月发布、11月公布技术报告的端到端语音模型。<br>GLM-4-Voice可以理解中英文语音，进行实时语音对话，并改变生成语音的情感、风格。</p><h3 id="模块组成-4"><a href="#模块组成-4" class="headerlink" title="模块组成"></a>模块组成</h3><table><thead><tr><th>Speech Tokenizer</th><th>LLM</th><th>Speech Detokenizer</th></tr></thead><tbody><tr><td>fine-tuned whisper-large-v3  with Quantizer (12.5Hz)</td><td>GLM-4-9B-Base</td><td>Flow Matching  based on CosyVoice + Hifi-GAN vocoder</td></tr></tbody></table><h3 id="模型框架-3"><a href="#模型框架-3" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="/image/speechllm_glm4voice.jpeg" alt="GLM-4-Vocie模型框架"></p><h3 id="模型训练-3"><a href="#模型训练-3" class="headerlink" title="模型训练"></a>模型训练</h3><ol><li>预训练：文本预训练、语音-文本交替数据预训练，分别对应“根据用户音频做出文本回复”和“根据文本回复和用户语音合成回复语音”两个任务。</li><li>对齐：输入用户语音，流式输出文本-语音交替内容，语音输出以文本输出为参照保证了回复内容的质量。</li></ol><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ul><li>GLM-4-Voice 通过语音-文本交替数据的预训练任务将语音模态和文本模态融入基座模型，这种方式对模态融合有很好的借鉴意义，具体细节可以他们的<a href="https://arxiv.org/abs/2411.17607">技术报告</a>。</li><li>GLM-4-Voice支持流式，为此对Whisper Encoder做了流式改造，标准卷积替换为因果卷积、双向注意力替换为因果注意力机制。</li><li>GLM-4-Voice在模型结构侧面没有做全双工（开源的模型），不能同时听和说，而是“半双工”模式。</li></ul><h2 id="KE-Omni"><a href="#KE-Omni" class="headerlink" title="KE-Omni  "></a>KE-Omni <a href="https://arxiv.org/abs/2412.01078"><img src="https://img.shields.io/badge/arXiv-2412.01078-b31b1b.svg?logo=arXiv" alt="arXiv"></a> <a href="https://huggingface.co/spaces/KE-Team/KE-Omni"><img src="https://img.shields.io/badge/%F0%9F%A4%97%20Hugging_Face-Demo-blue.svg" alt="model"></a></h2><p>KE-Omni是由贝壳语音团队于2024年12月发布的中英文语音大模型，在<a href="https://github.com/MatthewCYM/VoiceBench">VoiceBench</a>上取得优异成绩。<br>该工作构建了包含6万小时、4万多个说话人的高质量合成语音对话数据集KeSpeechChat，并基于该数据集将LLaMA能力扩展到语音模态。</p><h3 id="模块组成-5"><a href="#模块组成-5" class="headerlink" title="模块组成"></a>模块组成</h3><table><thead><tr><th>Speech Tokenizer</th><th>LLM</th><th>Speech Detokenizer</th></tr></thead><tbody><tr><td>whisper-large-v3  encoder</td><td>LLaMA-3.1</td><td>Transformer based duration predictor &amp; Transformer based speech unit generator &amp; unit base HiFi-GAN</td></tr></tbody></table><h3 id="模型框架-4"><a href="#模型框架-4" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="/image/speechllm_keomni.png" alt="KE-Omni模型框架"></p><p>文本对话构建（如下图）：引入了大语言模型，对文本指令数据进行口语化的改写。<br><img src="/image/speechllm_keomni_textual.jpg" alt="文本对话构建"><br>语音对话构建（如下图）：提出了一种构建虚拟说话人音库的方法，丰富说话人的多样性。基于CosyVoice合成指定说话人音色的语音对话。对合成的语音对话进行质量筛选过滤。<br><img src="/image/speechllm_keomni_speech.jpg" alt="语音对话构建"></p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ul><li>该工作提出了大规模高质量语音对话构造方法，并基于数据集在不同的数据尺度上验证了语音大模型的效果。</li></ul><h2 id="MiniCPM-o-2-6（2025-01）"><a href="#MiniCPM-o-2-6（2025-01）" class="headerlink" title="MiniCPM-o 2.6（2025.01）  "></a>MiniCPM-o 2.6（2025.01）<a href="https://openbmb.notion.site/MiniCPM-o-2-6-A-GPT-4o-Level-MLLM-for-Vision-Speech-and-Multimodal-Live-Streaming-on-Your-Phone-185ede1b7a558042b5d5e45e6b237da9"><img src="https://img.shields.io/badge/Notion-MiniCPMo26-white.svg?logo=notion" alt="Notion"></a> <a href="https://github.com/OpenBMB/MiniCPM-o"><img src="https://img.shields.io/badge/Github-Code-keygen.svg?logo=github" alt="code"></a> <a href="https://huggingface.co/openbmb/MiniCPM-o-2_6"><img src="https://img.shields.io/badge/%F0%9F%A4%97%20Hugging_Face-Model-blue.svg" alt="model"></a></h2><p>MiniCPM-o 2.6 是OpenBMB（清华大学自然语言处理实验室和面壁智能共同发起的开源社区）于2025年1月份开源的多模态大模型，对标GPT-4o，支持图像、语音的理解以及语音的生成。</p><h3 id="贡献点"><a href="#贡献点" class="headerlink" title="贡献点"></a>贡献点</h3><ul><li>实现了多模态实时交互。</li><li>实现了语音生成的可控，包括情绪、口音、语速等。</li></ul><h3 id="模块组成-6"><a href="#模块组成-6" class="headerlink" title="模块组成"></a>模块组成</h3><table><thead><tr><th>Speech Tokenizer(Encoder)</th><th>LLM</th><th>Speech Detokenizer(Decoder)</th></tr></thead><tbody><tr><td>Whisper-medium-300M encoder</td><td>Qwen2.5-7B-Instruct</td><td>ChatTTS-200M</td></tr></tbody></table><h3 id="模型框架-5"><a href="#模型框架-5" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="/image/speechllm_minicpm_o_26.png" alt="MiniCPM-o-2.6 模型框架"></p><p>MiniCPM-o-2.6 模型输入语音（麦克风输入、音频文件输入）、视觉（图像、视频），模型输出语音。<br>为了实现多模态的实时交互，采用了时分复用（Omni-modality Time Division Multiplexing, OTDM）技术，能够及时响应各模态的输入。</p><h3 id="模型训练-4"><a href="#模型训练-4" class="headerlink" title="模型训练 "></a>模型训练 <a href="https://github.com/OpenBMB/MiniCPM-o/blob/main/docs/llamafactory_train_and_infer.md"><img src="https://img.shields.io/badge/Documentation-LLaMAFactory-24292e?logo=github" alt="GitHub"></a></h3><p>MiniCPM-o-2.6采用了三阶段模型训练：</p><ul><li>Pretraining: 首先进行Vision Pretraining，使用图像-文本对对齐视觉和语言模态；然后进行Audio Pretraining，使用语音-文本对对齐语音和语言模态；最后是Omni Pretrainin，基于时分复用机制，融合各个模态。</li><li>Omni SFT：这个阶段基于高质量的多模态数据对模型微调，包括视觉问答、语音理解、语音生成、视频理解等数据类型， 从而实现这些模态上理解和生成能力以及指令遵循能力。</li><li>RLAIF：参考了<a href="https://github.com/RLHF-V/RLAIF-V">RLAIF-V</a>的工作，来提升模型的可信性，减少幻觉。</li></ul><h1 id="进阶话题"><a href="#进阶话题" class="headerlink" title="进阶话题"></a>进阶话题</h1><ul><li>音频&amp;音乐</li><li>全双工交互</li><li>多模态融合</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://arxiv.org/abs/2411.13577">WavChat: A Survey of Spoken Dialogue Models Shengpeng</a></li><li><a href="http://arxiv.org/abs/2410.03751">Recent Advances in Speech Language Models: A Survey</a></li><li><a href="https://arxiv.org/pdf/2410.18908">A SURVEY ON SPEECH LARGE LANGUAGE MODELS</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>llm</tag>
      
      <tag>speech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大模型整理（large language models survey）</title>
    <link href="/2023/06/09/llm-papers/"/>
    <url>/2023/06/09/llm-papers/</url>
    
    <content type="html"><![CDATA[<h1 id="基座大模型"><a href="#基座大模型" class="headerlink" title="基座大模型"></a>基座大模型</h1><h2 id="GPT系列"><a href="#GPT系列" class="headerlink" title="GPT系列"></a>GPT系列</h2><p>2022年底，ChatGPT开启了大模型时代的序章。</p><ul><li><a href="https://arxiv.org/pdf/2303.08774.pdf">GPT-4 Technical Report</a>:具备更强的推理能力，且能够融合图像信息。</li><li><a href="https://arxiv.org/pdf/2203.02155.pdf">InstructGPT</a></li><li><a href="https://openai.com/blog/chatgpt">ChatGPT</a>: ChatGPT是InstructGPT的姊妹模型，只是在数据收集和基座模型上有轻微差异。</li></ul><h2 id="LLaMA"><a href="#LLaMA" class="headerlink" title="LLaMA"></a>LLaMA</h2><p>LLaMA只使用开源数据预训练，在较小的模型参数下取得了相近的效果。<br>LLaMA 拥有7B, 13B, 33B and 65B 4种模型参数，模型开源但不可商用。</p><ul><li><a href="https://arxiv.org/pdf/2302.13971.pdf">LLaMA paper</a></li><li><a href="https://github.com/facebookresearch/llama">LLaMA github</a></li><li><a href="https://huggingface.co/decapoda-research/llama-13b-hf">LLaMA model-13B</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>llm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从0到1组装自己的台式机</title>
    <link href="/2023/01/07/assemble-your-computer/"/>
    <url>/2023/01/07/assemble-your-computer/</url>
    
    <content type="html"><![CDATA[<h1 id="明确自己的需求"><a href="#明确自己的需求" class="headerlink" title="明确自己的需求"></a>明确自己的需求</h1><p>不同的需求对配置的侧重是不同的。</p><ul><li>普通办公：侧重平衡。</li><li>娱乐：侧重显卡。</li><li>重度办公：侧重内存。</li><li>专业开发：侧重堆配置。</li></ul><h1 id="购买必要配件"><a href="#购买必要配件" class="headerlink" title="购买必要配件"></a>购买必要配件</h1><h2 id="普通办公"><a href="#普通办公" class="headerlink" title="普通办公"></a>普通办公</h2><p>以下这套方案是2021年为了日常办公而采取的方案。<br>主要使用场景是在公司日常办公以及连接开发机进行代码开发，所以并不需要很高的配置，只需要较大的内存即可。</p><ul><li>CPU(¥779.00)：AMD 锐龙3 3100 (<a href="https://item.jd.com/100007190439.html">https://item.jd.com/100007190439.html</a>)</li><li>主板(¥839.00)：华硕 TUF GAMING B550M-PLUS(<a href="https://item.jd.com/100013699280.html">https://item.jd.com/100013699280.html</a>)</li><li>内存(¥589.00 * 2)：金士顿 DDR4 3600 (<a href="https://item.jd.com/100011529714.html">https://item.jd.com/100011529714.html</a>)</li><li>GPU(¥799.00)：盈通 (yeston)RX550 4G (<a href="https://item.jd.com/100009748215.html">https://item.jd.com/100009748215.html</a>)</li><li>硬盘(¥999.00    * 2)：金士顿1TB 固态硬盘(<a href="https://item.jd.com/100018606186.html">https://item.jd.com/100018606186.html</a>)</li><li>机箱+电源(¥289.00    )：启航者F1 (<a href="https://item.jd.com/100014733474.html">https://item.jd.com/100014733474.html</a>)</li><li>散热(¥79.00)：九州风神 玄冰400S (<a href="https://item.jd.com/100009682545.html">https://item.jd.com/100009682545.html</a>)</li><li>显示器：公司配备</li><li>其他：键盘鼠标自己配置<br>以上各项共计：¥5961。<br>小结：CPU采用AMD主要考虑性价比。硬盘是m.2固态硬盘，速度更快、体积更小巧。</li></ul><p><strong>注意</strong>：Intel和AMD对应不同的主板，购买的时候一定要注意。</p><h2 id="普通办公兼顾娱乐"><a href="#普通办公兼顾娱乐" class="headerlink" title="普通办公兼顾娱乐"></a>普通办公兼顾娱乐</h2><p>以下这套方案是2021年为了在家办公采用的方案。<br>偶尔会看视频、做视频、调试AI模型。所以采用了较小的机箱，升级了GPU。</p><ul><li>CPU(¥999)：Intel i5-10400F 6核12线程(<a href="https://item.jd.com/100006897507.html">https://item.jd.com/100006897507.html</a>)</li><li>主板(¥1099)：玩家国度(ROG)ROG STRIX B460-I GAMING主板 (<a href="https://item.jd.com/100013209244.html">https://item.jd.com/100013209244.html</a>)</li><li>内存(¥959)：金士顿 (Kingston) FURY 32GB(16G×2)(<a href="https://item.jd.com/100007628368.html">https://item.jd.com/100007628368.html</a>)</li><li>GPU普通(¥849)：盈通(yeston)RX550-4G D5 极速版(<a href="https://item.jd.com/100010414091.html">https://item.jd.com/100010414091.html</a>)</li><li>GPU升级(¥2894)：华硕 ASUS TUF GeForce RTX 3060-O12G-V2-GAMING(<a href="https://item.jd.com/100011555183.html">https://item.jd.com/100011555183.html</a>)</li><li>硬盘(¥599 )：金士顿(Kingston) 1TB SSD固态硬盘 M.2接口(<a href="https://item.jd.com/100020082478.html">https://item.jd.com/100020082478.html</a>)</li><li>机箱(¥399)：酷冷至尊(CoolerMaster)NR200(魔方200)白色版 (<a href="https://item.jd.com/100008692713.html">https://item.jd.com/100008692713.html</a>)</li><li>电源(¥739)：全汉(FSP)额定600W 经典版MS600G (<a href="https://item.jd.com/100002705378.html">https://item.jd.com/100002705378.html</a>)</li><li>散热(¥329)：酷冷至尊(Cooler Master)冰神B240 CPU水冷散热器(<a href="https://item.jd.com/4567820.html">https://item.jd.com/4567820.html</a>)</li><li>显示器：公司配备</li><li>其他：键盘鼠标自己配置<br>以上各项共计：¥5972（普通GPU）/¥8017（升级GPU）。<br>小结：机箱采用了更小尺寸的，主板只能采用更小的MINI-ITX，所以组装起来空间略微小、也略麻烦些。<br>CPU采用了Intel，能够AMD对比下性能情况。<br>散热采用水冷也是为了和风冷做下对比，实际中度使用情况下，噪音相比风冷更大些，如果只是中度使用风冷即可。</li></ul><p><strong>注意</strong>：升级GPU要考虑电源的功率，600W正好可以支持RTX3060，无需升级电源了。</p><h2 id="普通办公送给长辈"><a href="#普通办公送给长辈" class="headerlink" title="普通办公送给长辈"></a>普通办公送给长辈</h2><p>以下这套方案是2023年初为了给家里长辈日常办公采用的方案。<br>考虑到长辈的认知度和对速度的需求，采用了Intel i5和32GB 3600内存。</p><ul><li>CPU(¥1189)：英特尔(Intel) i5-12400F 12代 酷睿 CPU处理器 6核12线程(<a href="https://item.jd.com/100031035610.html">https://item.jd.com/100031035610.html</a>)</li><li>主板(¥1199)：华硕(ASUS)TUF GAMING B660M-PLUS WIFI D4重炮手(<a href="https://item.jd.com/100031223640.html">https://item.jd.com/100031223640.html</a>)</li><li>内存(¥369 *2)：金士顿 (Kingston) FURY 16GB DDR4 3600 (<a href="https://item.jd.com/100007628368.html">https://item.jd.com/100007628368.html</a>)</li><li>GPU(¥849)：盈通(yeston)RX550-4G D5 极速版(<a href="https://item.jd.com/100010414091.html">https://item.jd.com/100010414091.html</a>)</li><li>硬盘(¥599 )：金士顿(Kingston) 1TB SSD固态硬盘 M.2接口(<a href="https://item.jd.com/100020082478.html">https://item.jd.com/100020082478.html</a>)</li><li>机箱(¥129)：先马(SAMA)平头哥M2 Mini小机箱 (<a href="https://item.jd.com/100025663574.html">https://item.jd.com/100025663574.html</a>)</li><li>电源(¥296)：酷冷至尊(CoolerMaster)额定500W G500(<a href="https://item.jd.com/100016458226.html">https://item.jd.com/100016458226.html</a>)</li><li>散热(¥109)：九州风神(DEEPCOOL)玄冰400V5(<a href="https://item.jd.com/100024033753.html">https://item.jd.com/100024033753.html</a>)</li><li>显示器：丰俭由人</li><li>其他：键盘鼠标自己配置<br>以上各项共计：¥5108。<br>小结：选择Intel主要是大家对Intel有着更好的认知度。<br>为了满足不卡顿、更快的体验，直接用固态硬盘，避免机械硬盘的速度慢的问题。<br>采用更大的内存，避免多后台任务卡顿问题。</li></ul><h1 id="动手组装"><a href="#动手组装" class="headerlink" title="动手组装"></a>动手组装</h1><p>这方面参考了哔哩哔哩上的安装视频，大家可以自行搜索下。<br><strong>注意</strong>：安装CPU的时候一定要小心再小心，CPU针脚很多且脆弱。</p><h1 id="安装Windows系统"><a href="#安装Windows系统" class="headerlink" title="安装Windows系统"></a>安装Windows系统</h1><ul><li>安装系统：基于WIN PE工具箱安装即可(<a href="https://www.wepe.com.cn/download.html">https://www.wepe.com.cn/download.html</a>)</li><li>激活系统：免费激活(<a href="https://github.com/massgravel/Microsoft-Activation-Scripts">https://github.com/massgravel/Microsoft-Activation-Scripts</a>)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语音识别概述</title>
    <link href="/2022/03/29/asr-simple-tutorial/"/>
    <url>/2022/03/29/asr-simple-tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="语音识别定义"><a href="#语音识别定义" class="headerlink" title="语音识别定义"></a>语音识别定义</h2><p>语音识别，亦称自动语音识别（Automatic Speech Recognition，ASR)或语音文本转换（Speech to Text, STT），<br>是一种将语音转为文本的技术。当前的语音识别一般均特指大词汇量连续语音识别。</p><h2 id="语音识别应用"><a href="#语音识别应用" class="headerlink" title="语音识别应用"></a>语音识别应用</h2><p>语音识别有着广泛的应用，按照使用场景的不同，可以分为以下几类：</p><ul><li>语音输入：语音输入法、语音搜索等。</li><li>语音助手：手机、音箱、穿戴设备上的语音助手，例如Siri、Cortana、Alexa等。</li><li>智能座舱：车载控制、娱乐等车载语音交互，例如NOMI。</li><li>智能家居：家居控制、娱乐等家居语音交互，例如小爱同学等。</li><li>电话客服：智能外呼、IVR、客服质检等。</li><li>商务办公：线上线下会议直播的字幕上屏展示。</li><li>语音审核：这类应用面向在线直播、电台等，检测是否存在违规违法内容。</li></ul><h2 id="语音识别类别"><a href="#语音识别类别" class="headerlink" title="语音识别类别"></a>语音识别类别</h2><p>根据应用场景对实时性的要求高低，可以分为：</p><ul><li>实时语音识别：要求系统低延迟，在两百毫秒以内；一般以语音流的方式实时地识别。典型的例子包括语音助手等语音交互、字幕实时上屏。</li><li>非实时语音识别：不要求实时返回结果；一般是一句话识别或文件语音识别。会议纪要转写等录音的语音识别属于这类。</li></ul><p>根据系统实现架构，可以分为</p><ul><li>经典语音识别：系统由声学模型、语言模型、发音词典、解码器几个部分组成。系统模块较多，搭建较为复杂；各个模块‘分工明确’ 模型结构相对简单，不依赖大量训练数据，在小数据集上有一定优势。</li><li>端到端语音识别：系统由一个模型实现从语音到文本的直接转换。深度学习引入语音识别之后，端到端的方式逐步成为研究热点。单个模型没有级联累积错误，而且系统搭建相对简单；但由于模型规模较大，需要更多的数据和训练成本。</li></ul><span id="more"></span><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><p>语音识别精度的评测是基于带标注的测试集，其数据规模从几千到上万句不等。<br>中文一般采用字错误率(character error rate, CER)，英文一般采用词错误率(word error rate, WER)。CER和WER本质其实是一样的，只是计算的粒度不同。二者的核心都是对比参考答案和识别结果两个序列。<br>下面介绍WER的计算方法，将计算粒度从词换成字就是CER。</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>如果两个序列长度相同，依次对比相应顺序的词是否相同，统计出错误个数，即可计算出错误率。但是实际情况两个序列长度不一定相同，有可能识别结果会多字或者少字，此时就无法直接按照顺序去对比。<br>WER的计算和生物信息学中的序列比对十分类似，可以参考序列比对的计算，引入动态规划算法。</p><p><img src="/image/wer.svg" alt="wer"></p><ul><li>S is the number of substitutions,</li><li>D is the number of deletions</li><li>I is the number of insertions</li><li>N is the number of words in the reference, N=S+D+C</li></ul><h3 id="相关工具："><a href="#相关工具：" class="headerlink" title="相关工具："></a>相关工具：</h3><ul><li><a href="https://github.com/usnistgov/SCTK">SCTK</a></li><li><a href="https://github.com/shuaijiang/Whisper-Finetune/blob/master/metrics/wer.py">WER</a>: Python scripts to compute WER.</li></ul><h2 id="学术研究"><a href="#学术研究" class="headerlink" title="学术研究"></a>学术研究</h2><p>学术会议：</p><ul><li>ICASSP</li><li>INTERSPEECH</li><li>ASRU：IEEE Automatic Speech Recognition and Understanding Workshop</li><li>ISCSLP</li></ul><p>比赛：</p><ul><li><a href="https://chimechallenge.github.io/">CHiME Challenge</a></li></ul><h2 id="开源数据集"><a href="#开源数据集" class="headerlink" title="开源数据集"></a>开源数据集</h2><p>中文：</p><ul><li><a href="http://www.openslr.org/33/">AISHELL-1</a>: An open-source 178 Hours Chinese Mandarin speech corpus </li><li><a href="https://wenet.org.cn/WenetSpeech/">WenetSpeech</a>: A 10000+ Hours Multi-domain Mandarin Corpus for Speech Recognition</li></ul><p>英文：</p><ul><li><a href="http://www.openslr.org/12/">LibriSpeech</a>: A Large-scale (1000 hours) corpus of read English speech</li><li><a href="https://github.com/SpeechColab/GigaSpeech">GigaSpeech</a>: An Evolving, Multi-domain ASR Corpus with 10,000 Hours of Transcribed Audio</li></ul><p>多语种：</p><ul><li><a href="https://huggingface.co/datasets/amphion/Emilia-Dataset">Emilia</a>: 以中英文为主的开源语音数据集，主要包括以下几种语言：<table><thead><tr><th>Language</th><th>Duration (hours)</th></tr></thead><tbody><tr><td>En</td><td>46,828</td></tr><tr><td>Zh</td><td>49,922</td></tr><tr><td>De</td><td>1,590</td></tr><tr><td>Fr</td><td>1,381</td></tr><tr><td>Ja</td><td>1,715</td></tr><tr><td>Ko</td><td>217</td></tr></tbody></table></li></ul><h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><ul><li><a href="https://github.com/shuaijiang/Whisper-Finetune/">Whisper</a>: OpenAI 开源的Whisper语音识别模型，支持多语种语音识别、语音翻译。更多内容参考<a href="https://zhuanlan.zhihu.com/p/662906303">知乎</a></li><li><a href="https://github.com/athena-team/athena">Athena</a>：端到端的语音处理工具，提供了语音识别、语音合成、语音活动检测、声纹识别等能力。</li><li><a href="https://github.com/espnet/espnet">ESPNet</a>: 端到端的语音处理工具，提供了语音识别、语音合成、语音翻译、机器翻译、语义理解、语音增强、语音分离等能力。</li><li><a href="https://github.com/wenet-e2e/wenet">WeNet</a>: 借鉴了ESPNet中语音识别的实现，并提供了工业界落地的实现。</li><li><a href="https://github.com/kaldi-asr/kaldi">Kaldi</a>: 经典语音识别的开源框架，非端到端的模型框架。</li><li><a href="https://github.com/k2-fsa/k2">k2+icefall+lhotse</a>: 新一代语音识别框架，涵盖了主流的模型结构，具备先进的模块化设计：模型底层实现（k2）、数据模块（lhotse）、ASR样例（icefall）、部署（sherpa）。</li></ul><h1 id="语音信号与特征"><a href="#语音信号与特征" class="headerlink" title="语音信号与特征"></a>语音信号与特征</h1><h2 id="语音的产生过程"><a href="#语音的产生过程" class="headerlink" title="语音的产生过程"></a>语音的产生过程</h2><p>声带利用振动，将肺部送来的气流转换成声波，从而产生声音。</p><h2 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h2><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>语音识别的声学特征一般为梅尔倒谱系数（Mel-scale Frequency Cepstral Coefficients，MFCC）或者 Filter Bank（FBank）。<br>MFCC的计算流程如下：</p><ol><li>预加重</li><li>分帧 </li><li>加窗 </li><li>快速傅里叶变换（FFT） </li><li>Mel滤波器组</li><li>对数运算 </li><li>离散余弦变换（DCT）<br>FBank的计算流程和MFCC很相似，只是没有做第七步的离散余弦变换。</li></ol><p>因为没有DCT，FBank特征各维度间具有较高的相关性，可以被DNN等深度神经网络很好地利用，因此FBank较MFCC具有更好地精度。<br>然而，对于GMM等模型忽略了不同特征维度的相关性，因此MFCC更具优势。    </p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>阅读文献：</p><ul><li>An Overview of End-to-End Automatic Speech Recognition[<a href="/file/An_Overview_of_End-to-End_Automatic_Speech_Recognition.pdf">pdf</a>]</li></ul><p>主流ASR模型可以分为基于HMM的混合模型和端到端模型两大类。</p><h2 id="混合模型"><a href="#混合模型" class="headerlink" title="混合模型"></a>混合模型</h2><p>混合模型可以分为：</p><ul><li>基于HMM-DNN的模型</li><li>基于HMM-LSTM的模型</li></ul><h3 id="HMM-DNN"><a href="#HMM-DNN" class="headerlink" title="HMM-DNN"></a>HMM-DNN</h3><p>GMM有很多优点，可以很好地概率分布建模、通过EM算法容易地拟合数据。但是，GMM不能有效地对非线性数据空间的数据进行建模。<br>DNN具有更强的表达能力，</p><h3 id="HMM-LSTM"><a href="#HMM-LSTM" class="headerlink" title="HMM-LSTM"></a>HMM-LSTM</h3><p>DNN没有时序建模能力，LSTM增加了对语音时序建模的能力。</p><h2 id="端到端模型"><a href="#端到端模型" class="headerlink" title="端到端模型"></a>端到端模型</h2><p>下面介绍下端到端模型，大体可以分为三类：</p><ul><li>基于CTC的模型</li><li>基于Transducer的模型</li><li>基于Attention的模型</li></ul><h3 id="CTC"><a href="#CTC" class="headerlink" title="CTC"></a>CTC</h3><p>Connectionist Temporal Classification(CTC)是一种针对基于深度神经网络的序列任务中输入输出序列不等长问题的准则。<br>CTC通过前向后向算法自动学习序列的边界信息，无需之前的方法中所需的强制对齐信息，降低了训练代价、减少了累积错误。<br>对于序列长度，CTC要求输入序列长度大于等于输出序列，在语音识别任务中，输入语音的长度往往都是远大于标注文本的长度的。<br>由于输入序列长于输出序列，在输出单元集合中增加blank(no label)，通过在输出序列中插入blank(-)，就可以实现输入和输出的长度对齐。所有可能的对齐的概率之和就是一种对齐标注的概率。<br>例如，通过插入blank(-)，输出序列<code>aab</code>可以对齐为<code>a−ab−</code>、<code>−aa−−abb</code>等若干序列。</p><h3 id="Transducer"><a href="#Transducer" class="headerlink" title="Transducer"></a>Transducer</h3><p>相比于CTC的目标函数，Transducer没有条件独立性假设，具有更强的建模能力。<br>相比于CTC的模型结构，增加了文本编码网络（Label Encoder，亦称Prediction Net）和融合网络（Joint Net），对于实时语音识别，更加合适自然。<br>与CTC类似，前向后向算法可以高效地完成对齐路径的计算。</p><p>基于Transducer的模型，从RNN Transducer（RNNT），逐渐演进到Transformer Transducer（TT）、Conformer Transducer（CT）。<br><img src="/paper_image/asr_tutorial_transducer.png" alt="RNNT"></p><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p>在《Attention is all you need》这篇工作问世后，语音识别也开启了端到端模型的新阶段。<br>这类模型结构也就是Attention base Encoder-Decoder models(AED)，包含了Encoder、Decoder两大模块：<br>Encoder对声学特征建模，输出声学表示；<br>Attention机制对Encoder输出做重要程度的加权；<br>Decoder利用Attention权重和其本身的历史时刻输出“自回归”地输出最终的结果；<br><img src="/paper_image/asr_tutorial_aed.png" alt="AED"><br>基于AED的模型在建模过程中，引入了Attention机制，更好地对长序列建模，相比于引入了门限机制的LSTM更加“有的放矢”。</p><p>AED这类框架中，最初Encoder和Decoder都是多层的LSTM结构，后续提出了非常经典的transformer结构，也就是大家都了解的BERT模型的核心结构。<br>基于Transformer的结构，后面衍生出很多变种：Conformer、Emformer、Squeezeformer等等。</p><p>Attention机制也在不断演变: Generalized Attention, Self-Attention, Multi-Head Attention, Additive Attention, Global Attention,Monotonic Chunkwise Attention（MoChA）</p><h1 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h1><p>常见的解码方式包括：</p><ul><li>WFST</li><li>beam search</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>语音识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deep Learning Book</title>
    <link href="/2022/02/10/deeplearningbook/"/>
    <url>/2022/02/10/deeplearningbook/</url>
    
    <content type="html"><![CDATA[<h2 id="无监督学习算法"><a href="#无监督学习算法" class="headerlink" title="无监督学习算法"></a>无监督学习算法</h2><h2 id="监督学习算法"><a href="#监督学习算法" class="headerlink" title="监督学习算法"></a>监督学习算法</h2><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p>随机梯度下降的核心是期望。所以可以用小规模的样本去估计梯度，这样就可以用minibatch的方式去计算梯度、更新模型。</p><h2 id="构建机器学习算法"><a href="#构建机器学习算法" class="headerlink" title="构建机器学习算法"></a>构建机器学习算法</h2><p>深度学习算法的配方：</p><ul><li>特定的数据集：</li><li>代价函数：代价函数至少含有一项使学习过程进行统计估计的成分。代价函数也可能还有附加项，如正则化。</li><li>优化过程：非线性模型要求选择一个迭代数据优化过程，如梯度下降。</li><li>模型</li></ul><h2 id="促使深度学习发展"><a href="#促使深度学习发展" class="headerlink" title="促使深度学习发展"></a>促使深度学习发展</h2><ul><li>维度灾难 <a href="https://www.visiondummy.com/2014/04/curse-dimensionality-affect-classification/">参考</a></li><li>局部不变性和平滑正则化</li><li>流形学习</li></ul><h1 id="深度前馈网络"><a href="#深度前馈网络" class="headerlink" title="深度前馈网络"></a>深度前馈网络</h1><p>前馈网络克服了线形网络的局限，是一种高效的非线性函数近似。<br>现代前馈网络的思想仍然使用反向传播算法和梯度下降方法。主要的性能提升来自于</p><ol><li>训练数据量的提升：减少了统计泛化对神经网络的挑战；</li><li>更大的网络结构：更强的算力和更好的深度学习框架基础使得神经网络能够变得更大；</li><li>少量算法的优化：包括交叉熵取代均方误差作为损失函数，使用RELU等分段线性函数作为激活函数。</li></ol><span id="more"></span>]]></content>
    
    
    
    <tags>
      
      <tag>deeplearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>paper-interspeech2021</title>
    <link href="/2021/10/12/paper-interspeech2021/"/>
    <url>/2021/10/12/paper-interspeech2021/</url>
    
    <content type="html"><![CDATA[<h1 id="SESSION-Tue-A-V-4-Self-Supervision-and-Semi-Supervision-for-Neural-ASR-Training"><a href="#SESSION-Tue-A-V-4-Self-Supervision-and-Semi-Supervision-for-Neural-ASR-Training" class="headerlink" title="SESSION Tue-A-V-4 Self-Supervision and Semi-Supervision for Neural ASR Training"></a>SESSION Tue-A-V-4 Self-Supervision and Semi-Supervision for Neural ASR Training</h1><table><thead><tr><th align="center">subclass</th><th align="center">paper</th><th align="center">link</th></tr></thead><tbody><tr><td align="center">Self-Supervision</td><td align="center">Improving Streaming Transformer Based ASR Under a Framework of Self-Supervised Learning</td><td align="center"><a href="https://arxiv.org/pdf/2109.07327.pdf">PDF</a></td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>语音识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鲁棒语音识别入门</title>
    <link href="/2021/08/15/distant-asr/"/>
    <url>/2021/08/15/distant-asr/</url>
    
    <content type="html"><![CDATA[<h1 id="CMU鲁棒语音识别简介"><a href="#CMU鲁棒语音识别简介" class="headerlink" title="CMU鲁棒语音识别简介"></a>CMU鲁棒语音识别简介</h1><p>鲁棒语音识别综述[<a href="/file/cmu_robust_asr.pdf">Robust Speech Recognition</a>]</p><ul><li>介绍了鲁棒语音识别的重要性与巨大挑战</li><li>介绍了多媒体技术</li><li>介绍了CMU研究领域以及相关的开源工具</li></ul><p><img src="/paper_image/cmu_robust_multimedia.png" alt="多媒体技术关系图"></p><h1 id="远场语音识别综述"><a href="#远场语音识别综述" class="headerlink" title="远场语音识别综述"></a>远场语音识别综述</h1><ul><li>远场语音识别综述[<a href="/file/is2016_tutorial_DSR_v6.pdf">Distant Speech Recognition</a>]</li></ul><p><img src="/paper_image/challenges_of_dsr.png" alt="远场语音识别的挑战"></p><p><img src="/paper_image/system_of_dsr.png" alt="远场语音识别框架"></p><span id="more"></span>]]></content>
    
    
    
    <tags>
      
      <tag>语音识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pip清华源</title>
    <link href="/2020/11/09/pip-tsinghua/"/>
    <url>/2020/11/09/pip-tsinghua/</url>
    
    <content type="html"><![CDATA[<h1 id="永久更新为清华源"><a href="#永久更新为清华源" class="headerlink" title="永久更新为清华源"></a>永久更新为清华源</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>编辑 vim ~/.pip/pip.conf ，修改为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">[<span class="hljs-keyword">global</span>]<br> <span class="hljs-built_in">index</span>-url = http<span class="hljs-variable">s:</span>//pypi.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/simple<br></code></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p><h1 id="临时更新为清华源"><a href="#临时更新为清华源" class="headerlink" title="临时更新为清华源"></a>临时更新为清华源</h1><p><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</code></p><h1 id="PIP更新方式"><a href="#PIP更新方式" class="headerlink" title="PIP更新方式"></a>PIP更新方式</h1><p>更新清华源往往需要使用最新的pip<br><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语音识别中的谱增强</title>
    <link href="/2020/03/29/paper-spec-augment/"/>
    <url>/2020/03/29/paper-spec-augment/</url>
    
    <content type="html"><![CDATA[<h1 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h1><ul><li>SpecAugment, GoogleBrain, paper: <a href="https://arxiv.org/pdf/1904.08779v1.pdf" title="SpecAugment">https://arxiv.org/pdf/1904.08779v1.pdf</a></li><li>SpecAugment++, PKU, paper: <a href="https://arxiv.org/pdf/2103.16858.pdf" title="SpecAugment++">https://arxiv.org/pdf/2103.16858.pdf</a></li></ul><h1 id="There-is-no-data-like-more-data"><a href="#There-is-no-data-like-more-data" class="headerlink" title="There is no data like more data"></a>There is no data like more data</h1>]]></content>
    
    
    
    <tags>
      
      <tag>语音识别</tag>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESPNET 安装指引</title>
    <link href="/2020/02/02/asr-espnet-install/"/>
    <url>/2020/02/02/asr-espnet-install/</url>
    
    <content type="html"><![CDATA[<h1 id="准备Python环境"><a href="#准备Python环境" class="headerlink" title="准备Python环境"></a>准备Python环境</h1><ol><li>建议安装anaconda3: <a href="https://www.anaconda.com/distribution/">anaconda3</a></li><li>创建ESPNET的环境: conda create -n  espnet python=3.6</li></ol><h1 id="Install-ESPNET相关依赖"><a href="#Install-ESPNET相关依赖" class="headerlink" title="Install ESPNET相关依赖"></a>Install ESPNET相关依赖</h1><ol><li>下载espnet源代码 <a href="https://github.com/espnet/espnet" title="espnet">espnet github</a></li><li>pip install torch==1.0.1 # Installation from anaconda is recommended for PyTorch </li><li>pip install chainer==6.0.0</li><li>pip install cupy==6.0.0 # Do not install cupy as default</li><li>pip install setuptools&gt;=38.5.1</li><li>pip install scipy&gt;=1.3.0</li><li>pip install librosa&gt;=0.7.0</li><li>pip install soundfile&gt;=0.10.2 </li><li>pip install inflect&gt;=1.0.0</li><li>pip install unidecode&gt;=1.0.22</li><li>pip install editdistance==0.5.2 </li><li>pip install h5py==2.9.0</li><li>pip install tensorboardX==1.8 </li><li>pip install pillow&gt;=6.1.0</li><li>pip install nara_wpe&gt;=0.0.5</li><li>pip install museval&gt;=0.2.1</li><li>pip install pystoi&gt;=0.2.2</li><li>pip install kaldiio&gt;=2.13.8</li><li>pip install matplotlib&gt;=3.1.0</li><li>pip install funcsigs&gt;=1.0.2 # A backport of inspect.signature for python2 </li><li>pip install configargparse&gt;=0.14.0</li><li>pip install PyYAML&gt;=5.1.2</li><li>pip install sentencepiece&gt;=0.1.82</li><li>pip install pysptk&gt;=0.1.17</li><li>pip install nltk&gt;=3.4.5</li><li>pip install nnmnkwii</li><li>pip install jaconv</li><li>pip install g2p_en</li><li>pip install torch_complex@git+<a href="https://github.com/kamo-naoyuki/pytorch_complex.git">https://github.com/kamo-naoyuki/pytorch_complex.git</a> </li><li>pip install pytorch_wpe@git+<a href="https://github.com/nttcslab-sp/dnn_wpe.git">https://github.com/nttcslab-sp/dnn_wpe.git</a></li><li>pip install warpctc-pytorch10-cuda90==0.1.3  (GitHub源码不易安装，pip安装较为简单)</li></ol><h2 id="Install-其他依赖"><a href="#Install-其他依赖" class="headerlink" title="Install 其他依赖"></a>Install 其他依赖</h2><ol><li>kaldi相关的依赖: sudo yum install atlas </li><li>sudo yum install bc</li><li>sudo yum install tree</li><li>sudo yum install libsndfile</li><li>sudo yum install flac (librispeech 语音转格式，需要安装flac)</li></ol><h2 id="install-cuda"><a href="#install-cuda" class="headerlink" title="install cuda"></a>install cuda</h2><ol><li>目前已支持cuda10，安装 sh /path/to/cuda10/cuda_10.0.130_410.48_linux.run</li><li>export LD_LIBRARY_PATH=/path/to/cuda/lib64:$LD_LIBRARY_PATH</li></ol><h1 id="Install-ESPNET"><a href="#Install-ESPNET" class="headerlink" title="Install ESPNET"></a>Install ESPNET</h1><ol><li>conda activate espnet (或者recipe里面的 path.sh)</li><li>pip install -e /path/to/espnet/ </li></ol><h1 id="Run-ESPNET"><a href="#Run-ESPNET" class="headerlink" title="Run ESPNET"></a>Run ESPNET</h1><ol><li>conda activate espnet</li><li>cd /path/to/espnet/egs/recipe</li><li>sh run.sh </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>语音识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paper Reading： Attention is all you need</title>
    <link href="/2019/07/28/paper_attention_is_all_you_need/"/>
    <url>/2019/07/28/paper_attention_is_all_you_need/</url>
    
    <content type="html"><![CDATA[<h1 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h1><ul><li>作者：Vaswani A , Shazeer N , Parmar N , et al. </li><li>单位：Google</li><li>会议：NIPS 2017</li><li>发表日期： 2017-06</li><li>论文链接：<a href="https://arxiv.org/pdf/1706.03762.pdf" title="attention is all you need">attention is all you need</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>主流的序列转换模型一般都是基于循环神经网络或者卷积神经网络来做的，包含编码器（encoder）、解码器（decoder），通过注意力机制连接编码器和解码器取得了最好的效果。<br>本文提出了一种简单有效的网络架构，即Transformer。</p><span id="more"></span><p>Transformer 仅仅基于注意力机制，而完全不依赖循环和卷积网络。<br>在机器翻译任务上的实验也证明，这样的模型需要的训练时间消耗会更少。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>注意力机制能够对输入序列、输出序列的依赖建模而无需考虑依赖的距离，注意力机制已成为不同任务的序列建模、转换模型不可或缺的一部分。在绝大多数的序列转换任务中，注意力机制往往会和循环神经网络联合使用。</p><h1 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h1><p>Transformer模型结构如下图所示。<br><img src="/paper_image/Attentionisallyouneed_transformer.png" alt="LSTM"></p><h2 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h2><p><img src="/paper_image/Attentionisallyouneed_multiheadattention.png" alt="Bidirectional RNN"></p><h2 id="缩放点乘注意力（Scaled-Dot-Product-Attention）"><a href="#缩放点乘注意力（Scaled-Dot-Product-Attention）" class="headerlink" title="缩放点乘注意力（Scaled Dot-Product Attention）"></a>缩放点乘注意力（Scaled Dot-Product Attention）</h2><h2 id="多头注意力（Multi-Head-Attention）"><a href="#多头注意力（Multi-Head-Attention）" class="headerlink" title="多头注意力（Multi-Head Attention）"></a>多头注意力（Multi-Head Attention）</h2><h1 id="为什么使用-Self-Attention"><a href="#为什么使用-Self-Attention" class="headerlink" title="为什么使用 Self-Attention"></a>为什么使用 Self-Attention</h1><p>激发Self-Attentoin的使用，主要有三方面的考虑：</p><ul><li>每层的计算复杂度</li><li>计算是否能并行</li><li>网络中长依赖的路径长度</li></ul><p><img src="/paper_image/Attentionisallyouneed_self_attention.png" alt="不同类型层的计算复杂度、序列操作、最大路径长度"></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本文工作中，作者提出了Transformer的框架，是首个完全基于注意力机制的序列转换模型，用多头自注意力机制取代了在编码器-解码器框架中常用的循环神经网络。</p><p>对于翻译任务而言，Transformer相比于基于循环神经网络或者卷积神经网络，其训练明显更快，而且取得了新的state-of-the-art。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>端到端语音识别基础入门</title>
    <link href="/2019/02/15/end-to-end-asr/"/>
    <url>/2019/02/15/end-to-end-asr/</url>
    
    <content type="html"><![CDATA[<h1 id="传统与端到端语音识别框架"><a href="#传统与端到端语音识别框架" class="headerlink" title="传统与端到端语音识别框架"></a>传统与端到端语音识别框架</h1><ul><li><p>传统的语音识别框架[<a href="/file/Signals_and_Communication_Technology_Aut.pdf">Automatic Speech Recognition</a>]<br><img src="/paper_image/typical_asr_architecture.png" alt="传统的语音识别框架"></p></li><li><p>端到端语音识别框架[<a href="/file/andrew-ng-machine-learning-yearning.pdf">Machine Learning Yearning</a>]<br><img src="/paper_image/end_to_end_asr_architecture.png" alt="端到端语音识别框架"></p></li></ul><span id="more"></span><h1 id="基础课程"><a href="#基础课程" class="headerlink" title="基础课程"></a>基础课程</h1><p>课程网址：<a href="http://www.speech.zone/courses/" title="http://www.speech.zone/courses/">http://www.speech.zone/courses/</a><br>这是爱丁堡大学的一名很有名气的语音方向的教授Simon King将他的授课内容分享出来的网站，里面的内容都是关于语音，丰富而且很清晰明了，即便有语音基础的同学学习一边也会受益匪浅。<br>如果没有语音基础，建议从语音处理基础开始课程，了解语音信号、音素等，然后再进一步到语音识别，包括特征工作，例如MFCC特征、filterBank特征，以及具体的算法。</p><ul><li>信号基础：<a href="http://www.speech.zone/courses/foundations-for-speech-processing/" title="http://www.speech.zone/courses/foundations-for-speech-processing/">http://www.speech.zone/courses/foundations-for-speech-processing/</a></li></ul><h1 id="传统语音识别技术（2009年）"><a href="#传统语音识别技术（2009年）" class="headerlink" title="传统语音识别技术（2009年）"></a>传统语音识别技术（2009年）</h1><p>这一时期的语音识别主要是基于统计模型建模，其中隐马尔可夫模型大获成功。</p><ul><li>An Overview of Modern Speech Recognition[<a href="/file/An_Overview_of_Modern_Speech_Recognition.pdf">An Overview of Modern Speech Recognition</a>]</li><li>虽然名为’modern’，但是现在已经确实为’conventional’</li><li>详细介绍了传统语音识别框架中的声学模型、语言模型、解码，以及语音识别的应用。</li></ul><h1 id="端到端语音识别技术"><a href="#端到端语音识别技术" class="headerlink" title="端到端语音识别技术"></a>端到端语音识别技术</h1><p>目前端到端语音识别主要有基于CTC的方法、基于Attention的方法，以及结合二者的多任务学习方法。</p><h2 id="End-to-end-ASR-Tutorial"><a href="#End-to-end-ASR-Tutorial" class="headerlink" title="End-to-end ASR Tutorial"></a>End-to-end ASR Tutorial</h2><ul><li>Interspeech 2018_ Tutorial E2E Speech Recognition[<a href="/file/Tutorial_E2E_Speech_Recognition.pdf">pdf</a>]</li><li>这是Google的关于端到端语音识别的tutorial，可以从宏观上观察端到端语音识别的发展，以及不同方法的优劣。</li></ul><h2 id="CTC"><a href="#CTC" class="headerlink" title="CTC"></a>CTC</h2><ul><li>Connectionist Temporal Classification Labelling Unsegmented Sequence Data with Recurrent Neural Networks[<a href="/file/CTC_Labelling_Unsegmented_Sequence_Data_with_Recurrent_Neural_Networks.pdf" title="CTC">pdf</a>]</li><li>deep speech [<a href="/file/deep_speech.pdf" title="deep_speech">pdf</a>]</li><li>deep speech2[<a href="/file/deep_speech2.pdf" title="deep_speech2">pdf</a>]</li><li>Supervised Sequence Labelling with Recurrent Neural Networks[<a href="/file/Supervised_Sequence_Labelling_with_RNN.pdf" title="CTC">pdf</a>] 介绍CTC部分主要是在第7章，需要重点看下。</li></ul><h2 id="RNN-T"><a href="#RNN-T" class="headerlink" title="RNN-T"></a>RNN-T</h2><p>RNN-T全称是Recurrent Neural Network Transducer，是在CTC的基础上改进的。<br>CTC的缺点是它没有考虑输出之间的依赖，RNN-T则在CTC模型的Encoder基础上，又加入了一个将之前时刻的输出作为输入的RNN(Prediction Network)，<br>将Prediction Network输出与Encoder的输出共同作为一个joint network的输入，得到输出logits通过softmax layer得到最终输出的概率。</p><ul><li>Sequence Transduction with Recurrent Neural Networks[<a href="/file/Sequence_Transduction_with_Recurrent_Neural_Networks.pdf" title="RNN-T">pdf</a>]<br><img src="/paper_image/rnn-t.png" alt="RNN-T Architecture"></li></ul><h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><ul><li>Attention-Based Models for Speech Recognition[<a href="/file/Attention_Based_Models_for_Speech_Recognition.pdf" title="Attention_ASR">pdf</a>]</li><li>Listen, Attend and Spell[<a href="/file/Listen_Attend_and_Spell.pdf" title="LAS">pdf</a>] 这一篇算是Attention开启之作。</li></ul><h2 id="Joint-CTC-Attention"><a href="#Joint-CTC-Attention" class="headerlink" title="Joint CTC/Attention"></a>Joint CTC/Attention</h2><ul><li>ESPnet 实现了Hybrid CTC/attention based end-to-end ASR [<a href="https://github.com/espnet/espnet" title="ESPnet">github</a>]</li><li>JOINT CTC-ATTENTION BASED END-TO-END SPEECH RECOGNITION USING MULTI-TASK LEARNING[<a href="/file/JOINT_CTC-ATTENTION_BASED_END-TO-END_SPEECH_RECOGNITION_USING_MULTI-TASK_LEARNING.pdf" title="Joint">pdf</a>]</li><li>Hybrid CTC-Attention Architecture for End-to-End Speech Recognition[<a href="/file/Hybrid_CTC_Attention_Architecture_for_End-to-End_Speech_Recognition.pdf" title="Hybrid">pdf</a>]</li></ul><h2 id="Conformer"><a href="#Conformer" class="headerlink" title="Conformer"></a>Conformer</h2><ul><li>Conformer: Convolution-augmented Transformer for Speech Recognition[<a href="/file/Conformer_Convolution_augmented_Transformer_for_Speech_Recognition.pdf" title="Conformer ASR">pdf</a>]</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>语音识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BERT Pre-training of Deep Bidirectional Transformers for Language Understanding</title>
    <link href="/2018/12/11/paper-bert/"/>
    <url>/2018/12/11/paper-bert/</url>
    
    <content type="html"><![CDATA[<h1 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h1><ul><li>发表机构：Google AI Language</li><li>发表时间：2018-10</li><li>论文链接：<a href="https://arxiv.org/abs/1810.04805" title="https://arxiv.org/abs/1810.04805">https://arxiv.org/abs/1810.04805</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>语言模型预训练对于提升很多自然语言处理任务有大帮助，这些任务包括句子级别任务例如自然语言推理、释义)、单词符号级别任务（例如命名实体识别、问答）。有两种策略将预训练的语言表示应用到这些任务上：基于特征的策略和微调优化的策略。这篇文章改进了微调优化的策略提出了BERT方法（Bidirectional Encoder Representations from Transformers）。</p><h1 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h1><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p><img src="/paper_image/bert_figure1.png" alt="结构对比"></p>]]></content>
    
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读列表</title>
    <link href="/2017/12/17/gist-reading/"/>
    <url>/2017/12/17/gist-reading/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因本文与Gist绑定，需要访问外网，否则可能无法全部显示，对此十分抱歉。</p><script src="https://gist.github.com/shuaijiang/34ae78fbe436122dea35fb45a68f1a21.js"></script>]]></content>
    
    
    
    <tags>
      
      <tag>reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deep Voice 3</title>
    <link href="/2017/10/26/paper-deep-voice-3/"/>
    <url>/2017/10/26/paper-deep-voice-3/</url>
    
    <content type="html"><![CDATA[<h1 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h1><ul><li>发表机构：Baidu </li><li>发表时间：2017-10</li><li>论文链接：<a href="https://arxiv.org/pdf/1710.07654.pdf" title="https://arxiv.org/pdf/1710.07654.pdf">https://arxiv.org/pdf/1710.07654.pdf</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文提出了一个全卷积架构的语音合成框架<br>特别地，本文的贡献包括：</p><ol><li>提出了全卷积的字符到频谱的架构，能够在序列上完成并行计算，训练速度比采用循环单元的类似架构快一个数量级</li><li>证明了该架构适用于LibriSpeech数据集，并能快速训练，该数据集包含了2484个发音人的将近820小时的语音数据。</li><li>证明了我们能够生成单调的注意力行为，避免了在语音合成中经常出现的错误情形。</li><li>对于单个说话人，我们比较了不同波形合成方法的质量，包括WORLD、Griffin-Lim和WaveNet</li><li>描述了Deep Voice 3 推理内核的具体实现，其能够在单一GPU机器上每天响应1000万次的查询请求。</li></ol><h1 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h1><p><img src="/paper_image/deepvoice3_fig1.png" alt="Model Architecture"><br>Deep Voice3 包括三个部分：</p><ul><li>Encoder：一个全卷积的编码器，将文本特征转换到中间的学习表示；</li><li>Decoder: 一个全卷积的因果解码器，采用自回归的方式将从多级卷积注意机制学习到的表示解码到低维音频表示（美尔带频谱）；</li><li>Converter: 一个全卷积的后处理网络，能够从decoder的状态预测最终的输出特征（依赖具体的波形合成方法）。</li></ul><p><img src="/paper_image/deepvoice3_fig2.png" alt="Convolution Block"></p><p><img src="/paper_image/deepvoice3_fig3.png" alt="Attention Block"></p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/paper_image/deepvoice3_tab2.png" alt="MOS"></p><p><img src="/paper_image/deepvoice3_tab3.png" alt="MOS"></p>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tacotron--一种完全端到端的语音合成模型</title>
    <link href="/2017/09/04/paper-tacotron/"/>
    <url>/2017/09/04/paper-tacotron/</url>
    
    <content type="html"><![CDATA[<h1 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h1><ul><li>发表机构：Google </li><li>发表时间：2017-04</li><li>论文链接：<a href="https://arxiv.org/pdf/1703.10135.pdf" title="https://arxiv.org/pdf/1703.10135.pdf">https://arxiv.org/pdf/1703.10135.pdf</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>现代的语音合成（Text-to-Speech，TTS）是很复杂的系统流程。对于参数语音合成，包括从语言抽取特征的文本处理、时长模型、声学模型预测声学特征、基于复杂信号处理的声码器。这些模块都是基于专家知识、需要精心设计。另外这些模块都是独立训练的，每个模块的错误会累积成更多的错误。TTS系统的复杂性导致当建立新系统时需要大量的工程量。</p><p>TTS是一种转换问题：将高度压缩的文本“解压”成音频。<br>本文提出了Tacotron，一种引入注意力（attention）机制的基于序列到序列（sequence-to-sequence，seq2seq）的端到端生成式TTS模型。我们的模型将文本字符作为输入、原始语谱图作为输出，并应用一些技术提高seq2seq模型的能力。<br>Tacotron可以完全地随机初始化、从头开始训练、它不需要音子级别的对齐，所以可以很轻松地利用大量带文本标注的声学数据。</p><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>WaveNet<br>DeepVoice<br>Char2Wav</p><h1 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h1><h2 id="model-architecture"><a href="#model-architecture" class="headerlink" title="model architecture"></a>model architecture</h2><p>Tacotron的主要结构是含有attention机制的seq2seq模型。下图展示了模型结构，包括一个编码器（encoder）、一个基于attention的解码器（decoder）、一个后处理网络。在高一级层次上，模型以字符作为输入，预测帧级别语谱，然后可以进一步转成波形。如下图Figure 1所示。<br><img src="/paper_image/tacotron_architecture.png" alt="Tacotron architecture"></p><h2 id="CBHG"><a href="#CBHG" class="headerlink" title="CBHG"></a>CBHG</h2><p>CBHG包括一个1-D的卷积滤波，接着是高通网络以及一个双向GRU。如下Figure 2所示。<br><img src="/paper_image/tacotron_cbhg.png" alt="CBHG architecture"></p><h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><p>Encoder的目标是提取鲁棒的文本特征序列。encoder的输入是字符序列，每个字符用one-hot向量或者嵌入式连续向量表示。对于每个嵌入式输入，我们应用了非线性变换，称为“pre-net”。在实际应用中，采用dropout瓶颈网络作为pre-net，有助于网络收敛和泛化能力。CBHG模块利用attention模块将per-net的输出转换成最终的encoder表示。我们发现基于CBHG的encoder不仅可以降低过拟合，相对于多层的RNN encoder可以减少发音错误。</p><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>我们使用简单的全连接输出层来预测decoder的目标。一个重要的技巧是在每个解码步骤预测多个不重叠的输出帧。一次预测r帧，使得整体的decoder数量降低为原来的r分之一，从而减小了模型大小、训练时间和推理时间。更重要的是，这项技巧可以加速收敛速度，并且可以更快地从attention中学到更稳定的对齐。</p><h2 id="后处理与波形合成"><a href="#后处理与波形合成" class="headerlink" title="后处理与波形合成"></a>后处理与波形合成</h2><p>后处理网络的任务是将seq2seq的输出转换成可以合成波形的输出。<br>采用Griffin-Lim算法根据预测的语谱合成波形。</p><h1 id="模型细节"><a href="#模型细节" class="headerlink" title="模型细节"></a>模型细节</h1><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="MOS测试"><a href="#MOS测试" class="headerlink" title="MOS测试"></a>MOS测试</h2><p>我们进行了MOS测试，要求被试者根据满分为5分的李克特量表对自然度打分。测试以众包的形式给母语人士测听。<br>测试结果如Table2所示。<br><img src="/paper_image/tacotron_mos_test.png" alt="MOS Test"></p><p>#总结<br>文章提出了Tacotron，一种端到端的生成式TTS模型，其将字符序列作为输入，语谱作为输出。使用一个简单的波形合成模块，在英文上可以达到3.82的MOS（mean option score,满分为5分）得分,自然度超出了产品级参数合成系统。</p>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode Predict the Winner</title>
    <link href="/2017/04/18/leetcode-Predict-the-Winner/"/>
    <url>/2017/04/18/leetcode-Predict-the-Winner/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p><p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.<br>Example:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>:<span class="hljs-meta"> [1, 5, 2]</span><br><span class="hljs-attribute">Output</span>: False<br><span class="hljs-attribute">Explanation</span>: Initially, player <span class="hljs-number">1</span> can choose between <span class="hljs-number">1</span> and <span class="hljs-number">2</span>. <br><span class="hljs-attribute">If</span> he chooses <span class="hljs-number">2</span> (or <span class="hljs-number">1</span>), then player <span class="hljs-number">2</span> can choose from <span class="hljs-number">1</span> (or <span class="hljs-number">2</span>) and <span class="hljs-number">5</span>. If player <span class="hljs-number">2</span> chooses <span class="hljs-number">5</span>, then player <span class="hljs-number">1</span> will be left with <span class="hljs-number">1</span> (or <span class="hljs-number">2</span>). <br><span class="hljs-attribute">So</span>, final score of player <span class="hljs-number">1</span> is <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span>, and player <span class="hljs-number">2</span> is <span class="hljs-number">5</span>. <br><span class="hljs-attribute">Hence</span>, player <span class="hljs-number">1</span> will never be the winner and you need to return False.<br></code></pre></td></tr></table></figure><p>The original problem is <a href="https://leetcode.com/problems/predict-the-winner/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    bool PredictTheWinner(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        s<span class="hljs-symbol">td:</span><span class="hljs-symbol">:ve</span>ctor&lt;s<span class="hljs-symbol">td:</span><span class="hljs-symbol">:ve</span>ctor&lt;<span class="hljs-built_in">int</span>&gt; &gt; dp(nums.size(), s<span class="hljs-symbol">td:</span><span class="hljs-symbol">:ve</span>ctor&lt;<span class="hljs-built_in">int</span>&gt;(nums.size()));  <br><br>        vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">sum</span>;<br>        sum.push_back(nums[<span class="hljs-number">0</span>]);<br>        for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++) &#123;<br>            sum.push_back(nums[i] + <span class="hljs-built_in">sum</span>[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        for (<span class="hljs-built_in">int</span> wide = <span class="hljs-number">0</span>; wide &lt; nums.size(); ++wide) &#123;  <br>            for(<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">left</span> + wide &lt; nums.size(); ++<span class="hljs-built_in">left</span>) &#123;<br>                <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">left</span> + wide;<br>                <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> == <span class="hljs-built_in">right</span>) &#123;<br>                    dp[<span class="hljs-built_in">left</span>][<span class="hljs-built_in">right</span>] = nums[<span class="hljs-built_in">left</span>];<br>                &#125; else <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> == <span class="hljs-built_in">right</span>-<span class="hljs-number">1</span>) &#123;<br>                    dp[<span class="hljs-built_in">left</span>][<span class="hljs-built_in">right</span>] = mymax(nums[<span class="hljs-built_in">left</span>], nums[<span class="hljs-built_in">right</span>]);<br>                &#125; else <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>-<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-built_in">int</span> leftMax = nums[<span class="hljs-built_in">left</span>] + <span class="hljs-built_in">sum</span>[<span class="hljs-built_in">right</span>] - <span class="hljs-built_in">sum</span>[<span class="hljs-built_in">left</span>] - dp[<span class="hljs-built_in">left</span>+<span class="hljs-number">1</span>][<span class="hljs-built_in">right</span>];<br>                    <span class="hljs-built_in">int</span> rightMax = nums[<span class="hljs-built_in">right</span>] +  <span class="hljs-built_in">sum</span>[<span class="hljs-built_in">right</span>-<span class="hljs-number">1</span>] - <span class="hljs-built_in">sum</span>[<span class="hljs-built_in">left</span>-<span class="hljs-number">1</span>] - dp[<span class="hljs-built_in">left</span>][<span class="hljs-built_in">right</span>-<span class="hljs-number">1</span>];<br>                    dp[<span class="hljs-built_in">left</span>][<span class="hljs-built_in">right</span>] = mymax(leftMax, rightMax); <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">int</span> res = dp[<span class="hljs-number">0</span>][nums.size()-<span class="hljs-number">1</span>];<br>        return <span class="hljs-number">2</span>*res &gt;= <span class="hljs-built_in">sum</span>[nums.size()-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-built_in">int</span> mymax(<span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;<br>        return i &gt; j ? i <span class="hljs-symbol">:</span> j;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, use daynamic programming, dp[left][right] means the max value one can get from vector nums which begin with left index end with right index.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>word2vec：词表示</title>
    <link href="/2017/04/14/word2vec/"/>
    <url>/2017/04/14/word2vec/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>源码： <a href="https://code.google.com/archive/p/word2vec/">https://code.google.com/archive/p/word2vec/</a></li><li>文献： <a href="https://arxiv.org/pdf/1301.3781.pdf">https://arxiv.org/pdf/1301.3781.pdf</a></li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>word2vec 是Google 2013年创建的一个项目， 其是“Tool for computing continuous distributed representations of words”。</p><p>word2vec 的安装非常简单，得到源码后，直接“make”即可。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>针对（大）语料，通过神经网络的训练，得到词表示。</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><ul><li>skipgram</li><li>cbow</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>下面就动手做下实验。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2017春节回家记</title>
    <link href="/2017/02/03/essay-spring-festival-2017/"/>
    <url>/2017/02/03/essay-spring-festival-2017/</url>
    
    <content type="html"><![CDATA[<h1 id="返乡人潮"><a href="#返乡人潮" class="headerlink" title="返乡人潮"></a>返乡人潮</h1><p>腊月二十九请假了一天提前回家，一大早7点的高铁，提前一个小时到车站，也已经是人潮涌动了。<br>没抢到二等座，就买了一等座，什么都无法阻挡回家的脚步。</p><h1 id="人情世故"><a href="#人情世故" class="headerlink" title="人情世故"></a>人情世故</h1><p>除了家人团聚，春节最重要的非走亲戚莫属。从初二到初五，不是在亲戚家，就是在走亲戚的路上。<br>几千年的风俗习惯，几千年的人情世故，流淌在我们心中，延绵不绝。</p><h1 id="永恒话题"><a href="#永恒话题" class="headerlink" title="永恒话题"></a>永恒话题</h1><h1 id="蓝天白云"><a href="#蓝天白云" class="headerlink" title="蓝天白云"></a>蓝天白云</h1><p>和往年不同的是，整个市都禁放鞭炮，买卖鞭炮或者燃放鞭炮都会被严处。<br>只有在乡下能燃放鞭炮，找回了一些童年时的年味。</p><h1 id="转瞬即逝"><a href="#转瞬即逝" class="headerlink" title="转瞬即逝"></a>转瞬即逝</h1><p>7天的春节假期，就这样结束了，仿佛昨天才刚刚放假。<br>假期少了工作的辛苦，多了家庭的琐事；<br>假期少了打拼的奔波，多了变胖的机会。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Total Hamming Distance</title>
    <link href="/2017/01/24/leetcode-Total-Hamming-Distance/"/>
    <url>/2017/01/24/leetcode-Total-Hamming-Distance/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p><p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p><p>Example:</p><blockquote><p>Input: 4, 14, 2</p></blockquote><blockquote><p>Output: 6</p></blockquote><blockquote><p>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case).<br>So the answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p></blockquote><p>Note:</p><ol><li>Elements of the given array are in the range of 0 to 10^9</li><li>Length of the array will not exceed 10^4.</li></ol><p>The original problem is <a href="https://leetcode.com/problems/total-hamming-distance/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">totalHammingDistance</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isContainNonZero</span>(nums)) &#123;<br>            <span class="hljs-keyword">int</span> count1bit=<span class="hljs-number">0</span>, count0bit=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &amp; <span class="hljs-number">1</span>)<br>                    count1bit++;<br>                <span class="hljs-keyword">else</span><br>                    count0bit++;<br>                <br>                nums[i] &gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br>            res += count1bit * count0bit;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isContainNonZero</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>如果直接两两计算汉明距离，最后求和，结果会超时。<br>解决方法是从低位到高位依次统计所有数的1和0的个数，每位的汉明距离就是1和0个数的乘积。<br>最后把每位的汉明距离相加即可得到最终结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode Sum of Left Leaves</title>
    <link href="/2017/01/23/leetcode-Sum-of-Left-Leaves/"/>
    <url>/2017/01/23/leetcode-Sum-of-Left-Leaves/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Find the sum of all left leaves in a given binary tree.</p><p>Example:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">    <span class="hljs-number">3</span><br>   <span class="hljs-operator">/</span> \<br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>      <span class="hljs-operator">/</span>  \<br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br><br>There <span class="hljs-keyword">are</span> two <span class="hljs-keyword">left</span> leaves <span class="hljs-keyword">in</span> the <span class="hljs-type">binary</span> tree, <span class="hljs-keyword">with</span> <span class="hljs-keyword">values</span> <span class="hljs-number">9</span> <span class="hljs-keyword">and</span> <span class="hljs-number">15</span> respectively. <span class="hljs-keyword">Return</span> <span class="hljs-number">24.</span><br></code></pre></td></tr></table></figure><p>The original problem is <a href="https://leetcode.com/problems/sum-of-left-leaves/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    int res = <span class="hljs-number">0</span>;<br>    int sumOfLeftLeaves(TreeNode* root) &#123;<br>        if (root == NULL) <br>            return <span class="hljs-number">0</span>;<br>        if (isLeaf(root))<br>            return <span class="hljs-number">0</span>;<br>        sum(root);<br>        return res;<br><br>    &#125;<br>    void sum(TreeNode* <span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">        if</span> (<span class="hljs-keyword">node</span> <span class="hljs-title">== NULL</span>) <br>            return;<br>        if (isLeaf(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>))<br>             res += <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left-</span>&gt;val;<br>        else&#123;<br>            sum(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span>);<br>        &#125;<br>        sum(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span>);<br>    &#125;<br>    <br>    bool isLeaf(TreeNode* <span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">        if</span> (<span class="hljs-keyword">node</span> <span class="hljs-title">== NULL</span>)<br>            return <span class="hljs-literal">false</span>;<br>        if(<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;left</span> == NULL &amp;&amp; <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;right</span> == NULL)<br>            return <span class="hljs-literal">true</span>;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem,  traverse the tree recursively, if the node is left leaf add the value to the result.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Intersection of Two Arrays</title>
    <link href="/2017/01/23/leetcode-Intersection-of-Two-Arrays/"/>
    <url>/2017/01/23/leetcode-Intersection-of-Two-Arrays/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two arrays, write a function to compute their intersection.</p><p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p><p>Note:</p><ul><li>Each element in the result must be unique.</li><li>The result can be in any order.</li></ul><p>The original problem is <a href="https://leetcode.com/problems/intersection-of-two-arrays/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; freq;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            freq[nums1[i]] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(freq.<span class="hljs-built_in">find</span>(nums2[i]) != freq.<span class="hljs-built_in">end</span>()) &#123;<br>                freq[nums2[i]] = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator iter = freq.<span class="hljs-built_in">begin</span>(); iter != freq.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>            <span class="hljs-keyword">if</span>(iter-&gt;second == <span class="hljs-number">2</span>) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(iter-&gt;first);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, traverse the two arrays, use hashmap to store the numbers and count the numbers which  are both in the two arrays. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Verify Preorder Serialization of a Binary Tree</title>
    <link href="/2017/01/23/leetcode-Verify-Preorder-Serialization-of-a-Binary-Tree/"/>
    <url>/2017/01/23/leetcode-Verify-Preorder-Serialization-of-a-Binary-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">     _9_<br>    /   <span class="hljs-string">\</span><br>   <span class="hljs-number">3</span>     <span class="hljs-number">2</span><br>  / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br> <span class="hljs-number">4</span>   <span class="hljs-number">1</span>  <span class="hljs-comment">#  6</span><br>/ <span class="hljs-string">\</span> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-comment"># # # #   # #</span><br></code></pre></td></tr></table></figure><p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node.</p><p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p><p>Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p><p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”.</p><p>Example 1:</p><blockquote><p>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>Return true</p></blockquote><p>Example 2:</p><blockquote><p>“1,#”<br>Return false</p></blockquote><p>Example 3:</p><blockquote><p>“9,#,#,1”<br>Return false</p></blockquote><p>The original problem is <a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(string preorder)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; nodes;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, dotCount = <span class="hljs-number">0</span>; i &lt; preorder.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(dotCount % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (preorder[i] != <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dotCount ++;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dotCount ++;<br>            &#125;<br>            nodes.<span class="hljs-built_in">push</span>(preorder[i]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> symbolCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!nodes.<span class="hljs-built_in">empty</span>() &amp;&amp; (nodes.<span class="hljs-built_in">size</span>() + symbolCount) &gt;= <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nodes.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                symbolCount ++;<br>                nodes.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (symbolCount &gt;= <span class="hljs-number">2</span>) &#123;<br>                    nodes.<span class="hljs-built_in">pop</span>();<br>                    nodes.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br>                    symbolCount -= <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ( nodes.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; nodes.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; symbolCount == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem,  use a stack to save the node and verify every child.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Two Sum II Input array is sorted</title>
    <link href="/2017/01/19/leetcode-Two-Sum-II-Input-array-is-sorted/"/>
    <url>/2017/01/19/leetcode-Two-Sum-II-Input-array-is-sorted/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p><p>You may assume that each input would have exactly one solution.</p><blockquote><p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p></blockquote><p>The original problem is <a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; twoSum(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; numbers, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; res;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span> = -<span class="hljs-number">1</span>;<br>        for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-built_in">index</span> = findIndex(numbers, i+<span class="hljs-number">1</span>, numbers.<span class="hljs-built_in">size</span>()-<span class="hljs-number">1</span>, <span class="hljs-keyword">target</span>-numbers[i]);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">index</span> <span class="hljs-comment">!= -1) &#123;</span><br>                res.push_back(i+<span class="hljs-number">1</span>);<br>                res.push_back(<span class="hljs-built_in">index</span>+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-built_in">int</span> findIndex(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i&gt;j) <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(i==j) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] <span class="hljs-comment">!= target)</span><br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>            <span class="hljs-built_in">index</span> = (i+j)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-built_in">index</span>] == <span class="hljs-keyword">target</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">index</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[<span class="hljs-built_in">index</span>] &lt; <span class="hljs-keyword">target</span>) &#123;<br>                i = <span class="hljs-built_in">index</span> + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j = <span class="hljs-built_in">index</span> - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, traverse the array and find the number which add by the current element is equal to target.<br>Use binary search when find the other number by the array is sorted. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Top K Frequent Elements</title>
    <link href="/2017/01/19/leetcode-Top-K-Frequent-Elements/"/>
    <url>/2017/01/19/leetcode-Top-K-Frequent-Elements/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a non-empty array of integers, return the k most frequent elements.</p><p>For example,<br>Given [1,1,1,2,2,3] and k = 2, return [1,2].<br>Note: </p><ul><li>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.</li><li>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</li></ul><p>The original problem is <a href="https://leetcode.com/problems/top-k-frequent-elements/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; freq;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            freq[nums[i]] ++;<br>        &#125;<br>        priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; vecFreq;<br>        <span class="hljs-keyword">for</span>(map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator iter=freq.<span class="hljs-built_in">begin</span>(); iter != freq.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>            vecFreq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(iter-&gt;second,iter-&gt;first));<br>        &#125;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vecFreq.<span class="hljs-built_in">top</span>().second);<br>            vecFreq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, use maxHeap, namely priority_queue in C++. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Longest Palindrome</title>
    <link href="/2017/01/19/leetcode-longest-palindrome/"/>
    <url>/2017/01/19/leetcode-longest-palindrome/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p><p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p><p>Note:<br>Assume the length of given string will not exceed 1,010.</p><p>Example:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Input:<br><span class="hljs-string">&quot;abccccdd&quot;</span><br><br>Output:<br><span class="hljs-number">7</span><br><br>Explanation:<br>One longest palindrome <span class="hljs-keyword">that</span> can be built <span class="hljs-keyword">is</span> <span class="hljs-string">&quot;dccaccd&quot;</span>, <span class="hljs-keyword">whose</span> <span class="hljs-built_in">length</span> <span class="hljs-keyword">is</span> <span class="hljs-number">7.</span><br></code></pre></td></tr></table></figure><p>The original problem is <a href="https://leetcode.com/problems/longest-palindrome/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">letters</span><span class="hljs-params">(<span class="hljs-number">52</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                letters[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] ++; <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                letters[s[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">26</span>] ++; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> odd = <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">52</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (letters[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                res += letters[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res += letters[i] - <span class="hljs-number">1</span>;<br>                odd ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (odd &gt; <span class="hljs-number">0</span>) &#123;<br>            res += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem,  use a vector with length 52 for all letters to save the frequence.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Battleships in a Board</title>
    <link href="/2017/01/19/leetcode-battleships-in-a-board/"/>
    <url>/2017/01/19/leetcode-battleships-in-a-board/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an 2D board, count how many different battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules:</p><p>You receive a valid board, made of only battleships or empty slots.<br>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.<br>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.<br>Example:</p><blockquote><p>X..X<br>…X<br>…X</p></blockquote><p>In the above board there are 2 battleships.</p><p>Invalid Example:</p><blockquote><p>…X<br>XXXX<br>…X</p></blockquote><p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p><p>The original problem is <a href="https://leetcode.com/problems/battleships-in-a-board/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countBattleships</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rowSize = board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(rowSize &lt;= <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> colSize = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; rowSize; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j &lt; colSize; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                    res ++;<br>                    <span class="hljs-built_in">count</span>(board, i, j);<br>                &#125;<br>                    <br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">count</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span> || i&gt;=board.<span class="hljs-built_in">size</span>() || j&gt;=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>        <span class="hljs-built_in">count</span>(board, i<span class="hljs-number">-1</span>, j);<br>        <span class="hljs-built_in">count</span>(board, i+<span class="hljs-number">1</span>, j);<br>        <span class="hljs-built_in">count</span>(board, i, j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">count</span>(board, i, j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, traverse the array, when meet ‘X’, add one to result and lebel it and it’s neighbors ‘X’ to ‘.’ recursively. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Magical String</title>
    <link href="/2017/01/19/leetcode-Magical-String/"/>
    <url>/2017/01/19/leetcode-Magical-String/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>A magical string S consists of only ‘1’ and ‘2’ and obeys the following rules:</p><p>The string S is magical because concatenating the number of contiguous occurrences of characters ‘1’ and ‘2’ generates the string S itself.</p><p>The first few elements of string S is the following: S = “1221121221221121122……”</p><p>If we group the consecutive ‘1’s and ‘2’s in S, it will be:</p><p>1 22 11 2 1 22 1 22 11 2 11 22 ……</p><p>and the occurrences of ‘1’s or ‘2’s in each group are:</p><p>1 2    2 1 1 2 1 2 2 1 2 2 ……</p><p>You can see that the occurrence sequence above is the S itself.</p><p>Given an integer N as input, return the number of ‘1’s in the first N number in the magical string S.</p><p>Note: N will not exceed 100,000.</p><p>Example 1:</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">Explanation:</span> The first <span class="hljs-number">6</span> elements <span class="hljs-keyword">of</span> magical <span class="hljs-type">string</span> S <span class="hljs-built_in">is</span> <span class="hljs-string">&quot;12211&quot;</span> <span class="hljs-built_in">and</span> it contains three <span class="hljs-number">1</span><span class="hljs-comment">&#x27;s, so return 3.</span><br></code></pre></td></tr></table></figure><p>The original problem is <a href="https://leetcode.com/problems/magical-string/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> magicalString(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">str</span>;<br>        <span class="hljs-built_in">str</span>.push_back(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">str</span>.push_back(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">str</span>.push_back(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> char12 = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>, j=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">3</span>; i&lt;n;i++) &#123;<br>            <span class="hljs-keyword">count</span> = <span class="hljs-built_in">str</span>[j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-keyword">count</span>; k++)&#123;<br>                <span class="hljs-keyword">if</span> (char12 == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-built_in">str</span>.push_back(<span class="hljs-number">1</span>);<br>                    res++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">str</span>.push_back(<span class="hljs-number">2</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">str</span>.size() == n)<br>                    <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            char12 = <span class="hljs-number">1</span> - char12;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, save the history number and according to the history number to generate new number. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Island Perimeter</title>
    <link href="/2017/01/11/leetcode-Island-Perimeter/"/>
    <url>/2017/01/11/leetcode-Island-Perimeter/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p><p>Example:</p><p>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]</p><p>Answer: 16</p><p>The original problem is <a href="https://leetcode.com/problems/island-perimeter/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> islandPerimeter(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">grid</span>) &#123;<br>        <span class="hljs-keyword">int</span> rowSize = <span class="hljs-keyword">grid</span>.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">if</span>(rowSize &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> perimeter = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> colSize = <span class="hljs-keyword">grid</span>[<span class="hljs-number">0</span>].<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rowSize; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; colSize; j++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">grid</span>[i][j] == <span class="hljs-number">1</span>) &#123;<br>        perimeter += <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span> (i<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">grid</span>[i<span class="hljs-number">-1</span>][j] == <span class="hljs-number">1</span>)<br>        perimeter --;<br>        <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span> &lt; rowSize &amp;&amp; <span class="hljs-keyword">grid</span>[i+<span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>)<br>        perimeter --;<br>        <span class="hljs-keyword">if</span> (j<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">grid</span>[i][j<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>)<br>        perimeter --;<br>        <span class="hljs-keyword">if</span> (j+<span class="hljs-number">1</span> &lt; colSize &amp;&amp; <span class="hljs-keyword">grid</span>[i][j+<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<br>        perimeter --;<br>        &#125;<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> perimeter;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, go throght all the island in the grid and reduce one for one neigbhood. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Hamming Distance</title>
    <link href="/2017/01/10/leetcode-hamming-distance/"/>
    <url>/2017/01/10/leetcode-hamming-distance/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers x and y, calculate the Hamming distance.</p><p>Note:<br>0 ≤ x, y &lt; 2^31.</p><p>The original problem is <a href="https://leetcode.com/problems/hamming-distance/" title="Problem">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> hammingDistance(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) &#123;<br>        <span class="hljs-keyword">int</span> big = x &gt; y ? x : y;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">small</span> = x &lt; y ? x : y;<br>        <span class="hljs-keyword">int</span> distance = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> bigMod, smallMod;<br>        <span class="hljs-keyword">while</span>(big &gt; <span class="hljs-number">0</span>) &#123;<br>            bigMod = big % <span class="hljs-number">2</span>;<br>            smallMod = <span class="hljs-keyword">small</span> % <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(bigMod != smallMod) &#123;<br>                distance ++;<br>            &#125;<br>            big = big / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">small</span> = <span class="hljs-keyword">small</span> / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> distance;<br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, convert the integer to binary and compare the every bit. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>启动tomcat报错  “Cannot allocate memory (errno=12)”解决方法</title>
    <link href="/2017/01/06/java-tomcat-cannot-allocate-memory/"/>
    <url>/2017/01/06/java-tomcat-cannot-allocate-memory/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>启动tomcat statup.sh，直接报错了： VM warning: …… error=’Cannot allocate memory’ (errno=12)。</p><p>就是说内存不够了，查看了下内存还剩余大约1GB，但是对于要启动的程序是够的。</p><p>网上查找了一些资料，断定是Java VM的内存分配问题。</p><p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；<br>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。</p><p>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；<br>空余堆内存大于70% 时，JVM会减少堆直到-Xms的最小限制。<br>因此服务器一般设置-Xms、-Xmx相等以避免在每次垃圾回收后调整堆的大小。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>修改tomcat的bin中catalina.sh的配置。修改JAVA_OPTS，调整-Xms 和 -Xmx 到合适的值。</p><p>我将之前的 -Xms4096m -Xmx4096m 修改成 -Xms2048m -Xmx2048m</p><p>重启tomcat成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WaveNet--一种应用于原始语音的端到端生成式模型</title>
    <link href="/2016/12/05/paper-wavenet/"/>
    <url>/2016/12/05/paper-wavenet/</url>
    
    <content type="html"><![CDATA[<h1 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h1><ul><li>作者：Aaron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex Graves, Nal Kalchbrenner, Andrew Senior, Koray Kavukcuoglu</li><li>单位：Google, Google Deep Mind</li><li>发表日期： 2016</li><li>论文链接：<a href="https://arxiv.org/pdf/1609.03499.pdf" title="https://arxiv.org/pdf/1609.03499.pdf">https://arxiv.org/pdf/1609.03499.pdf</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>WaveNet 是一种用于生成原始语音的深层神经网络，基于WaveNet的语音合成比目前性能最好的参数式语音合成和拼接式语音合成有更好的主观评分。<br>单个WaveNet可以捕获多个说话人的特点，根据说话人的标记可以在不同说话人之间转换。<br>WaveNet还可以生成美妙动听的音乐，此外还可以作为区分式模型应用到音子识别。</p><p>该论文工作的主要贡献包括：</p><ul><li>验证了WaveNet可以生成语音信号，并且语音的主观评分之高在TTS领域内是前所有未有的。</li><li>为了更好地处理音频生成过程中的长跨度的时序依赖，基于扩展级联卷积开发了新的网络结构。</li><li>验证了在不同说话人标记条件下，单个模型可以生成不同的声音。</li><li>文中的网络结构在小的语音识别数据库中具有很好的效果，并且在生成其他音频例如音乐时具有不错的效果。</li></ul><h1 id="WaveNet"><a href="#WaveNet" class="headerlink" title="WaveNet"></a>WaveNet</h1><p>介绍了一种生成式模型，直接对原始语音波形建模。波形$X={x_1,…,x_T}$是条件概率的乘积：$p(x) = \frac{p(x_t|x_1,…,x_{t-1}}$</p><p>条件概率分布建模通过卷积层的堆叠实现，但是网络中没有pooling层，同时模型的输出与输入在时序上有相同的纬度。</p><h2 id="Dilated-Causal-Convolutions"><a href="#Dilated-Causal-Convolutions" class="headerlink" title="Dilated Causal Convolutions"></a>Dilated Causal Convolutions</h2><p>WaveNet主要由Causal Convolution组成，下图是由多个Causal Convolutional Layers堆叠形成的网络。<br><img src="/paper_image/waveNet_cnn.png" alt="Visualization of a stack of causal convolutional layers"></p><p>这里采用了一种扩展的卷积网络，随着隐层阶数增加而增加接收范围，但不会明显增加计算量。<br><img src="/paper_image/waveNet_dilated_cnn.png" alt="Visualization of a stack of dilated causal convolutional layers"></p><p>随着深度的增加，扩展范围指数性增加。</p><h2 id="Softmax-Distributions"><a href="#Softmax-Distributions" class="headerlink" title="Softmax Distributions"></a>Softmax Distributions</h2><p>相关研究工作证明Softmax distribution 对于条件分布建模有更好的效果，尽管数据是连续的。</p><h2 id="Gated-Activation-Units"><a href="#Gated-Activation-Units" class="headerlink" title="Gated Activation Units"></a>Gated Activation Units</h2><p>文章采用了门限激活单元，与门限PixelCNN中的一致。<br><img src="/paper_image/waveNet_gated_activation.png" alt="Gated activation units"><br>其中，*表示卷积操作。</p><h2 id="Residual-and-Skip-Connections"><a href="#Residual-and-Skip-Connections" class="headerlink" title="Residual and Skip Connections"></a>Residual and Skip Connections</h2><p><img src="/paper_image/waveNet_architecture.png" alt="Overview of the residual block and the entire architecture"></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS操作系统使用入门介绍</title>
    <link href="/2016/11/22/macos-usage/"/>
    <url>/2016/11/22/macos-usage/</url>
    
    <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>全选：commend ＋ a</li><li>复制：commend ＋ c</li><li>粘贴：commend ＋ v</li><li>剪切：无（粘贴时 alt＋commend＋v可以模拟）</li><li>保存：commend ＋ s</li><li>退出：commend ＋ q</li><li>全屏：control ＋ commend ＋ f（退出全屏也是）</li><li>打开文件：commend ＋ o</li><li>输入法切换：commend ＋ 空格</li><li>spotlight：control ＋ 空格</li><li>Alfred：alt ＋ 空格</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Natural Language Processing with Python</title>
    <link href="/2016/06/15/natural-language-processing-with-python/"/>
    <url>/2016/06/15/natural-language-processing-with-python/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>人类的语言有五千多种，研究人类起源的专家认为，通过口语交流是人类区别于其他动物的最显著标志。</p><p>自然语言处理（ Natural Language Processing，NLP）是指采用计算机技术处理自然语言，包括词性标注（Part-Of-Speech,POS）、文本分类（Text Classification）、句法分析（Syntactic Analysis）等任务。NLP是很多任务或者系统的基础，例如语音合成系统等，已成为人工智能的基础。</p><p>两大工具：</p><ul><li>Python。Python已经广泛应用到很多领域，成为很多程序员的利器，也是很多项目的支撑。这里采用Python2.7：<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>。</li><li>NLTK（Natural Language Toolkit）。包含了相关的软件、数据以及文档。下载地址:<a href="http://www.nltk.org/">http://www.nltk.org/</a>。</li></ul><h2 id="语言处理与Python"><a href="#语言处理与Python" class="headerlink" title="语言处理与Python"></a>语言处理与Python</h2><h2 id="文本语料和词汇资源"><a href="#文本语料和词汇资源" class="headerlink" title="文本语料和词汇资源"></a>文本语料和词汇资源</h2><h2 id="处理原始文本"><a href="#处理原始文本" class="headerlink" title="处理原始文本"></a>处理原始文本</h2><h2 id="编写结构化程序"><a href="#编写结构化程序" class="headerlink" title="编写结构化程序"></a>编写结构化程序</h2><h2 id="词的分类与标注"><a href="#词的分类与标注" class="headerlink" title="词的分类与标注"></a>词的分类与标注</h2><h2 id="分类文本"><a href="#分类文本" class="headerlink" title="分类文本"></a>分类文本</h2><h2 id="文本信息抽取"><a href="#文本信息抽取" class="headerlink" title="文本信息抽取"></a>文本信息抽取</h2><h2 id="句法结构分析"><a href="#句法结构分析" class="headerlink" title="句法结构分析"></a>句法结构分析</h2><h2 id="基于特征的句法"><a href="#基于特征的句法" class="headerlink" title="基于特征的句法"></a>基于特征的句法</h2><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><h2 id="语言数据的管理"><a href="#语言数据的管理" class="headerlink" title="语言数据的管理"></a>语言数据的管理</h2><h3 id="TIMIT"><a href="#TIMIT" class="headerlink" title="TIMIT"></a>TIMIT</h3><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>标注的层次大致可分为如下几种：</p><ul><li>词正则化</li><li>句子切分</li><li>段落切分</li><li>词性标注</li><li>语义结构</li><li>浅层语义</li><li>对话与交谈</li></ul><p>标注的方式：</p><ul><li>内嵌标注（inline annotation）：直接修改原始文档，插入相关的标注信息。</li><li>外置标注（standoff annotation）：不修改原始文档，通过在额外文档中的标注信息实现。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>Bird S, Klein E, Loper E. Natural language processing with Python[M]. “ O’Reilly Media, Inc.”, 2009.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用PIP管理Python模块（Use pip install package）</title>
    <link href="/2016/06/12/use-pip-install-package/"/>
    <url>/2016/06/12/use-pip-install-package/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Pip是管理Python模块的工具，目前Python3中已经包含，但是Python2中没有。<br>使用Pip可以很好管理Python模块，例如安装某一模块。</p><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><p>安装PIP最简单的方式是利用PIP源码安装：<a href="https://pypi.python.org/pypi/pip">获取pip</a><br>解压缩代码压缩包，进入路径，运行setup.py即可。具体如下所示。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> setup.<span class="hljs-keyword">py</span> install<br></code></pre></td></tr></table></figure><h2 id="配置pip国内源"><a href="#配置pip国内源" class="headerlink" title="配置pip国内源"></a>配置pip国内源</h2><p>编辑或者新建配置文件<br>vim ~/.pip/pip.conf</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">[<span class="hljs-keyword">global</span>]<br> <span class="hljs-built_in">index</span>-url = http<span class="hljs-variable">s:</span>//pypi.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/simple<br></code></pre></td></tr></table></figure><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>PIP安装好之后，就可以很简单地利用其安装其他模块了。具体如下所示。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">python -m pip <span class="hljs-keyword">install</span> PackageName<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统--存储器层次结构</title>
    <link href="/2016/05/21/csapp-6-memory/"/>
    <url>/2016/05/21/csapp-6-memory/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>存储器系统是一个具有不同容量、成本以及访问时间的存储设备的层次结构。<br>局部性（locality）是计算机程序的一个基本属性。</p><h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>局部性的两周形式：</p><ul><li>时间局部性（temporal locality）：具有良好时间局部性的程序，被引用过一次的存储器位置很可能在不远的将来继续被多次引用。</li><li>空间局部性（spatial locality）：具有良好空间局部性的程序，如果一个存储器位置被引用了一次，那么不久的将来，附近的存储器位置很可能被引用。</li></ul><p>程序员要理解局部性原理并应用到代码中，有良好局部性的程序比局部性差的程序运行得更快。</p><h3 id="引用程序数据的局部性"><a href="#引用程序数据的局部性" class="headerlink" title="引用程序数据的局部性"></a>引用程序数据的局部性</h3><p>一个连续向量中，每隔k个元素进行访问，被称为步长为k的引用模式。</p><h3 id="取指令的局部性"><a href="#取指令的局部性" class="headerlink" title="取指令的局部性"></a>取指令的局部性</h3><p>由于程序指令是存放在存储器中的，CPU需要取出这些指令，所以一个程序也具有取指令的局部性。</p><h3 id="局部性小结"><a href="#局部性小结" class="headerlink" title="局部性小结"></a>局部性小结</h3><ul><li>重复引用同一个变量的程序具有良好的时间局部性。</li><li>对于取指令，循环具有较好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li></ul><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p>存储器层次结构的中心思想是，k层的更快更小的存储设备作为k+1层的更大更慢的存储设备的缓存。也就是说，存储器层次结构的本质是每一层存储设备都是较低一层的缓存。</p><p>数据以块为传送单元在第k层和第k+1层之间来回拷贝。</p><h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>(美)布莱恩特(Bryant, R. E.), (美)奥哈拉伦(O’Hallaron),等. 深入理解计算机系统[M]. 机械工业出版社, 2012.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解计算机系统--链接</title>
    <link href="/2016/05/20/csapp-7-linking/"/>
    <url>/2016/05/20/csapp-7-linking/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>链接是将各种代码和数据收集起来并组合成一个单一文件的过程，这个文件可被加载到存储器并执行。<br>现代系统中，链接是由链接器（linker）自动执行的。</p><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>首先定义强符号与弱符号。</p><ul><li>强符号：函数和已初始化的全局变量。</li><li>弱符号：未初始化的全局变量。</li></ul><h3 id="规则1"><a href="#规则1" class="headerlink" title="规则1"></a>规则1</h3><p>不允许有多个强符号。</p><h3 id="规则2"><a href="#规则2" class="headerlink" title="规则2"></a>规则2</h3><p>如果有一个强符号和多个弱符号，那么选择强符号。<br>如果在一个模块里x未被初始化，那么链接器将安静地选择定义在另一个模块中的强符号。</p><h3 id="规则3"><a href="#规则3" class="headerlink" title="规则3"></a>规则3</h3><p>如果有多个弱符号，那么从这些弱符号中任意选择一个。</p><h3 id="一个有趣的错误"><a href="#一个有趣的错误" class="headerlink" title="一个有趣的错误"></a>一个有趣的错误</h3><p>在foo5模块中，x被定义为int类型；在bar5模块，x被定义为double类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//foo5.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">15213</span>;<br><span class="hljs-keyword">int</span> y = <span class="hljs-number">15212</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = 0x%x, y = 0x%x\n&quot;</span>, x, y);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//bar5.c</span><br><span class="hljs-keyword">double</span> x;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    x = <span class="hljs-number">-0.0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用gcc（版本为4.8.0）编译，会有警告信息。与参考文献中所说的没有警告信息有出入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -o foobar5 foo5.c  bar5.c <br>$/usr/bin/ld: Warning: alignment 4 of symbol `x<span class="hljs-string">&#x27; in /tmp/ccrGpxXb.o is smaller than 8 in /tmp/ccYL3Zqs.o</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$./foobar5<br><span class="hljs-variable">$x</span> = 0x0, y = 0x80000000<br></code></pre></td></tr></table></figure><p>结果显示，y的值被修改，这是因为double类型是8个字节，int类型是4个字节，在bar5模块中对x赋值，双精度浮点数覆盖了存储器中x和y的位置。</p><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>链接器完成符号解析之后，就可以把代码中的每个符号引用和确定的一个符号定义联系起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小，就可以开始重定位了。<br>重定位由两步组成：</p><ol><li>重定位节和符号定义。链接器将所有相同类型的节合并，得到新的聚合节。</li><li>重定位节中的符号定义。链接器修改代码节和数据节中对每个符号的引用，使他们指向正确的地址。</li></ol><h2 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h2><p>静态库的缺点</p><ol><li>需要定期维护和更新，如果程序员想使用最新版本，必须了解该库的更新情况，显式地将程序与更新的库重新链接。</li><li>库中被调用函数的代码会被复制到每个运行进程的代码段中，几乎每个程序都会包含标准I/O函数，这对存储资源是一种浪费。</li></ol><p>共享库是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时可以加载到任意的存储器地址，并和一个在存储器的程序链接起来。这个过程称为动态链接，由动态链接器的程序来执行。</p><p>共享库也称为共享目标（shared object）。在Unix、Linux系统中通常用后缀.so来表示。Window系统也大量利用了共享库，称为动态链接库，用后缀.dll来表示。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>(美)布莱恩特(Bryant, R. E.), (美)奥哈拉伦(O’Hallaron),等. 深入理解计算机系统[M]. 机械工业出版社, 2012.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于深层神经网络的语音合成</title>
    <link href="/2016/04/21/DeepNeuralNetworkBasedSpeechSynthesis/"/>
    <url>/2016/04/21/DeepNeuralNetworkBasedSpeechSynthesis/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>随着深度学习在各个领域取得了优异的性能，例如计算机视觉、自然语言处理领域。深度学习也被应用到语音合成中，并取得了不错的效果。本文就简单介绍基于深层神经网络的语音合成。</p><h2 id="基于DBN的语音合成"><a href="#基于DBN的语音合成" class="headerlink" title="基于DBN的语音合成"></a>基于DBN的语音合成</h2><p>深层置信网络（Deep Neural Network，DBN）是概率生成模型，其中包含了多个隐层。</p><p><img src="/paper_image/DBN_based_speech_synthesis.png" alt="基于DBN的语音合成系统框图"></p><h2 id="基于DNN的语音合成"><a href="#基于DNN的语音合成" class="headerlink" title="基于DNN的语音合成"></a>基于DNN的语音合成</h2><p>深层神经网络（Deep Neural Network，DNN）是一种前馈神经网络，除了输入层和输出层，包含多个隐层。</p><p><img src="/paper_image/DNN_based_speech_synthesis.png" alt="基于DNN的语音合成系统框图"></p><h2 id="基于RNN的语音合成"><a href="#基于RNN的语音合成" class="headerlink" title="基于RNN的语音合成"></a>基于RNN的语音合成</h2><p>循环神经网络（Recurrent Neural Network，RNN）包含循环连接，可以获取输入序列任意时刻的信息。</p><p><img src="/paper_image/DBLSTM_RNN_TTS.png" alt="基于RNN的语音合成系统框图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在客观指标方面，基于深层神经网络的语音合成显著优于传统的语音合成（例如基于HMM的语音合成）。</li><li>在主观听感方面，基于深层神经网络的语音合成整体高于基于HMM的语音合成，但是某些地方会出现较差的情况。</li><li>基于深层神经网络的语音合成需要更多的计算量。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>S.-Y. Kang, X.-J. Qian, and H. Meng, “Multi-distribution deep belief network for speech synthesis,” in Proc. IEEE Int. Conf. Acoustics, Speech and Signal Pro- cessing (ICASSP), 2013, pp. 8012–8016.</li><li>H. Zen, A. Senior, and M. Schuster, “Statistical parametric speech synthesis using deep neural networks,” in Proc. IEEE Int. Conf. Acoustics, Speech and Sig- nal Processing (ICASSP), 2013, pp. 7962–7966.</li><li>Y. C. Fan, Y. Qian, F. L. Xie, F. K. Soong. TTS synthesis with bidirectional LSTM based recurrent neural networks.[C]. Interspeech. 2014, pp. 1964–1968.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Word Search 2</title>
    <link href="/2015/10/21/leetcode_word_search2/"/>
    <url>/2015/10/21/leetcode_word_search2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p><p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p>For example,<br>Given words = [“oath”,”pea”,”eat”,”rain”] and board =</p><pre><code class="hljs">[  [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],  [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],  [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]]</code></pre><p>Return [“eat”,”oath”].</p><p>The original problem is <a href="https://leetcode.com/problems/word-search-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/WordSearch2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Word Search II *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class TrieNode&#123;public:        bool iskey;    TrieNode * childern[26];    TrieNode()&#123;        iskey = false;        for(int i=0;i&lt;26;++i)&#123;            childern[i] = NULL;        &#125;    &#125;&#125;;class Solution &#123;public:    vector&lt;string&gt; res;    int row;    int col;    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123;        root = new TrieNode();                int wordNum = words.size();        if(wordNum &lt;= 0)            return res;                row = board.size();                col = board[0].size();                //create tried tree         for(int i=0;i&lt;wordNum;++i)&#123;            string word = words[i];            int wordLen = word.size();            TrieNode * node = root;            char ch;            for(int j=0;j&lt;wordLen;++j)&#123;                ch = word[j];                if(node-&gt;childern[ch - &#39;a&#39;] == NULL)&#123;                    node-&gt;childern[ch - &#39;a&#39;] = new TrieNode() ;                &#125;                if(j == wordLen-1)&#123;                    node-&gt;childern[ch - &#39;a&#39;]-&gt;iskey = true;                &#125;                node =  node-&gt;childern[ch-&#39;a&#39;];                            &#125;        &#125;        // find the words in the board                for(int i=0;i&lt;row;i++)&#123;            for(int j=0;j&lt;col;j++)&#123;                vector&lt;vector&lt;bool&gt;&gt; path(row, vector&lt;bool&gt;(col, false));                char ch = board[i][j];                if(root-&gt;childern[ch-&#39;a&#39;] != NULL)                    find(board, path, i, j, root, &quot;&quot;);            &#125;        &#125;        return res;    &#125;    void find(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt; &amp;path, int i, int j, TrieNode *node, string str)&#123;        if(i&lt;0 || i&gt;=row || j&lt; 0 || j&gt;=col)            return;        if(path[i][j])            return ;        char ch = board[i][j];        node = node-&gt;childern[ch-&#39;a&#39;];        if(node == NULL)            return;        str.push_back(ch);        if(node-&gt;iskey)&#123;            res.push_back(str);            node-&gt;iskey = false;        &#125;                path[i][j] = true;        if(i-1&gt;=0 &amp;&amp; i-1&lt;row)            find(board, path, i-1, j, node, str);        if(i+1&gt;=0 &amp;&amp; i+1&lt;row)            find(board, path, i+1, j, node, str);        if(j-1&gt;=0 &amp;&amp; j-1&lt;col)        find(board, path, i, j-1, node, str);        if(j+1&gt;=0 &amp;&amp; j+1&lt;col)            find(board, path, i, j+1, node, str);                    path[i][j] = false;    //should be set to false    &#125;private:    TrieNode * root;&#125;;int main()&#123;    Solution s;    vector&lt;vector&lt;char&gt;&gt; board(1,vector&lt;char&gt;(2,&#39;a&#39;));    vector&lt;string&gt; words(1,&quot;a&quot;);    vector&lt;string&gt; res = s.findWords(board, words);    cout&lt;&lt;&quot;res.size&quot;&lt;&lt;res.size();    /*    for(int i=0;i&lt;res.size();++i)&#123;        cout&lt;&lt;res[i]&lt;&lt;endl;    &#125;*/    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>采用前缀树保存字典中所有单词。在搜索词的过程中，使用了深度优先遍历（DFS）。需要注意的是，利用一个和board相同大小的2维矩阵保存是否访问过某个字母，访问时设置对应位置为true，访问后设置其为false, 否则会得到错误结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Restore IP Addresses</title>
    <link href="/2015/10/20/leetcode_restore_ip_addresses/"/>
    <url>/2015/10/20/leetcode_restore_ip_addresses/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p><p>For example:<br>Given “25525511135”,</p><p>return [“255.255.11.135”, “255.255.111.35”]. (Order does not matter)</p><p>The original problem is <a href="https://leetcode.com/problems/restore-ip-addresses/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RestoreIPAddresses.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Restore IP Addresses*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;sstream&gt;using namespace std;class Solution &#123;public:    vector&lt;string&gt; res;    vector&lt;string&gt; restoreIpAddresses(string s) &#123;        string str;        dfs(s, str, 0);        return res;    &#125;    bool dfs(string s, string str, int level)&#123;        stringstream ss;        int num;                if(level == 3)&#123;            ss&lt;&lt;s;            ss&gt;&gt;num;            ss.clear();                        if(s[0] == &#39;0&#39; &amp;&amp; s.size()&gt;1) //if one part has more than 1 integer, the begining can&#39;t be 0                 return false;            if(num &lt;= 255)&#123;                str.push_back(&#39;.&#39;);                str+=s;                res.push_back(str);                return true;            &#125;            return false;        &#125;        string substr;        string remain;        for(int i=0;i&lt;3 &amp;&amp; i&lt;s.size();++i)&#123;            substr = s.substr(0,i+1);            if(substr[0] == &#39;0&#39; &amp;&amp; substr.size() &gt; 1)                continue;            ss&lt;&lt;substr;            ss&gt;&gt;num;            ss.clear();            if(num &lt;= 255)&#123;                if(str.size()&gt;0) // if first part should not add &#39;.&#39;                    str.push_back(&#39;.&#39;);                str += substr;                remain = s.substr(i+1, s.size()-i-1);                                if(remain.size() &gt;= 3-level)                    dfs(remain, str, level+1);                                if(str == substr)                    str = &quot;&quot;;                else                    str = str.substr(0, str.size() - substr.size() - 1);            &#125;            else&#123;                return false;            &#125;        &#125;    &#125;&#125;;int main()&#123;    Solution s;    //string str(&quot;25525511135&quot;);    string str(&quot;010010&quot;);    vector&lt;string&gt; res = s.restoreIpAddresses(str);    for(int i=0;i&lt;res.size();++i)&#123;        cout&lt;&lt;res[i]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>因为对一个给定的字符串，存在多种可能得IP地址，考虑采用深度优先遍历方法，找出所有合法的IP地址。需要注意的是，每个字段如果超过2位，则第一位不可以是0。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Count Primes</title>
    <link href="/2015/10/20/leetcode_count_primes/"/>
    <url>/2015/10/20/leetcode_count_primes/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Count the number of prime numbers less than a non-negative number, n.</p><p>The original problem is <a href="https://leetcode.com/problems/count-primes/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/CountPrimes.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Count Primes *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;sstream&gt;#include&lt;math.h&gt;using namespace std;class Solution &#123;public:    int countPrimes(int n) &#123;        vector&lt;bool&gt; isPrime(n, true);        // Loop&#39;s ending condition is i * i &lt; n instead of i &lt; sqrt(n)        // to avoid repeatedly calling an expensive function sqrt().        for (int i = 2; i * i &lt; n; i++) &#123;          if (!isPrime[i]) continue;          for (int j = i * i; j &lt; n; j += i) &#123;             isPrime[j] = false;          &#125;        &#125;        int count = 0;        for (int i = 2; i &lt; n; i++) &#123;          if (isPrime[i]) count++;        &#125;        return count;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>参考了<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" title="维基百科">Sieve_of_Eratosthenes</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Implement Trie Prefix Tree</title>
    <link href="/2015/10/19/leetcode_implement_trie_prefix_tree/"/>
    <url>/2015/10/19/leetcode_implement_trie_prefix_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Implement a trie with insert, search, and startsWith methods.</p><p>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p><p>The original problem is <a href="https://leetcode.com/problems/implement-trie-prefix-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ImplementTrie(Prefix%20Tree).cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Implement Trie (Prefix Tree)*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;sstream&gt;#include&lt;math.h&gt;using namespace std;class TrieNode &#123;public:    // Initialize your data structure here.    bool iskey;    TrieNode* childern[26];    TrieNode() &#123;        for(int i=0;i&lt;26;i++)            childern[i] = NULL;        iskey = false;    &#125;&#125;;class Trie &#123;public:    Trie() &#123;        root = new TrieNode();    &#125;    // Inserts a word into the trie.    void insert(string word) &#123;        int len = word.size();        TrieNode * node = root;        char ch;        for(int i=0;i&lt;len;++i) &#123;            ch = word[i];            if(node-&gt;childern[ch - &#39;a&#39;] == NULL)                node-&gt;childern[ch - &#39;a&#39;] = new TrieNode();            if(i==len-1)                node-&gt;childern[ch-&#39;a&#39;]-&gt;iskey = true;            node = node-&gt;childern[ch-&#39;a&#39;];        &#125;    &#125;    // Returns if the word is in the trie.    bool search(string word) &#123;        int len = word.size();        TrieNode * node = root;        char ch;        for(int i=0;i&lt;len;++i)&#123;            ch = word[i];            if(node-&gt;childern[ch-&#39;a&#39;] == NULL)                return false;            if(i==len-1)&#123;                if(node-&gt;childern[ch-&#39;a&#39;]-&gt;iskey == true)                    return true;                else                    return false;            &#125;            node = node-&gt;childern[ch-&#39;a&#39;];        &#125;    &#125;    // Returns if there is any word in the trie    // that starts with the given prefix.    bool startsWith(string prefix) &#123;        int len = prefix.size();        TrieNode * node = root;        char ch;        for(int i=0;i&lt;len;++i)&#123;            ch = prefix[i];            if(node-&gt;childern[ch-&#39;a&#39;] == NULL)                return false;            node = node-&gt;childern[ch-&#39;a&#39;];        &#125;        return true;    &#125;private:    TrieNode* root;&#125;;// Your Trie object will be instantiated and called as such:// Trie trie;// trie.insert(&quot;somestring&quot;);// trie.search(&quot;key&quot;);</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>前缀树的实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Bitwise AND of Numbers Range</title>
    <link href="/2015/10/19/leetcode_bitwise_and_of_numbers_range/"/>
    <url>/2015/10/19/leetcode_bitwise_and_of_numbers_range/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p><p>For example, given the range [5, 7], you should return 4.</p><p>The original problem is <a href="https://leetcode.com/problems/bitwise-and-of-numbers-range/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BitwiseANDofNumbersRange.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Bitwise AND of Numbers Range*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;math.h&gt;using namespace std;class Solution &#123;public:    int rangeBitwiseAnd(int m, int n) &#123;        int res = m;        if(m==0)            return 0;        int move = 0; // the number of the move steps        while(m!=n)&#123;            m = m&gt;&gt;1;            n = n&gt;&gt;1;            move +=1;        &#125;        return m &lt;&lt; move;  // if m is 0, then the result is also 0    &#125;&#125;;int main()&#123;    Solution s;    //int m = 600000000, n = 2147483645;    int m = 2147483646, n = 2147483647;    int res = s.rangeBitwiseAnd(m, n);    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>直接采用从m到n遍历，使用&amp;位运算符进行位运算，原理是这样的，但是会超时。因为m&lt;n,将该范围内的所有数进行与运算后，如果某一个位的为1，则m和n一定在该位的所有更高的位上要不全为零、要不全为1，否则中间的数会存在该位为0的情况。</p><p>通过位移运算，更加快速找到高位全相等的情况。如果此时高位全为0，则结果为0；如果高位全为1，则结果为将从该位到低位全设置为0的结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Contains Duplicate 3</title>
    <link href="/2015/10/19/leetcode_contains_duplicate3/"/>
    <url>/2015/10/19/leetcode_contains_duplicate3/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.</p><p>The original problem is <a href="https://leetcode.com/problems/contains-duplicate-iii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ContainsDuplicate3_set.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Contains Duplicate III*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;class Solution &#123;public:    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;        int size = nums.size();        if(size&lt;=1 || k&lt;=0)            return false;        set&lt;long&gt; mySet; // windows which has k elements at most        int low = 0;        for(int i=0;i&lt;size;++i)&#123;            if(mySet.size() &gt; k)&#123;                mySet.erase(nums[low++]);            &#125;            auto target = mySet.lower_bound((long)nums[i] - (long)t); // the first element which target &gt;= nums[i]-t            if(target != mySet.end() &amp;&amp; *target &lt;= (long)nums[i]+(long)t) //  nums[i] + t &lt;= target &lt;= nums[i] + t                return true;            mySet.insert(nums[i]);        &#125;        return false;    &#125;&#125;;int main()&#123;    Solution s;    vector&lt;int&gt; nums(3,0);    nums[0]=1;nums[1]=3;nums[2]=1;    int k = 1; int t =1;    bool res = s.containsNearbyAlmostDuplicate(nums, k, t);    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>需要维护一个长度为k的窗，使用set<long>来实现。遍历数组vector<int>nums，在窗中寻找大于nums[i]-t的最小数，如果发现该数，并且该数小于nums[i]-t，则返回true。</p><p>即如果在窗中存在一个数 在区间[nums[i]-t, nums[i]+t]中，则返回true。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Add And Search Word</title>
    <link href="/2015/10/17/leetcode_add_and_search_word/"/>
    <url>/2015/10/17/leetcode_add_and_search_word/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Design a data structure that supports the following two operations:</p><pre><code class="hljs">void addWord(word)bool search(word)</code></pre><p>search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p><p>For example:</p><pre><code class="hljs">addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true</code></pre><p>The original problem is <a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/AddAndSearchWord.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Add and Search Word *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;class TrieNode&#123;public:    bool iskey;   // 标记该节点是否代表关键字    TrieNode *children[26]; // 各个子节点    TrieNode() &#123;        iskey = false;        for(int i=0; i&lt;26; ++i)            children[i] = NULL;    &#125;&#125;; class WordDictionary &#123;public:    WordDictionary()&#123;        root =  new TrieNode();        &#125;    // Adds a word into the data structure.    void addWord(string word) &#123;        int len = word.size();        if(len &lt;= 0)            return ;        TrieNode *node = root;         for(int i=0;i&lt;len;++i)&#123;            char ch = word[i];            if(node-&gt;children[ch-&#39;a&#39;] == NULL) &#123;                node-&gt;children[ch-&#39;a&#39;] = new TrieNode();            &#125;            node = node-&gt;children[ch-&#39;a&#39;];                    &#125;        node-&gt;iskey = true;    &#125;    // Returns if the word is in the data structure. A word could    // contain the dot character &#39;.&#39; to represent any one letter.    bool search(string word) &#123;        int len = word.size();        if(len &lt;= 0)            return false;                return dfs(root, word, 0);    &#125;    bool dfs(TrieNode* node, string word, int i)&#123;        int len = word.size();        if(i &gt;= len)            return false;        char ch = word[i];        if(ch != &#39;.&#39;)&#123;            if(node-&gt;children[ch-&#39;a&#39;] == NULL)&#123;                return false;            &#125;            else&#123;                if(i == len-1)&#123;                    if(node-&gt;children[ch-&#39;a&#39;]-&gt;iskey == true)                        return true;                    else                        return false;                &#125;                return dfs(node-&gt;children[ch-&#39;a&#39;], word, i+1);            &#125;        &#125;        else&#123;            for(int j=0;j&lt;26;j++)&#123;                if(node-&gt;children[j] != NULL)&#123;                    if(i == len -1)&#123;                        if(node-&gt;children[j]-&gt;iskey)                            return true;                        else                            continue;                    &#125;                    if(dfs(node-&gt;children[j], word, i+1))                        return true;                &#125;            &#125;            return false;        &#125;    &#125;private:    TrieNode * root;&#125;;// Your WordDictionary object will be instantiated and called as such:// WordDictionary wordDictionary;// wordDictionary.addWord(&quot;word&quot;);// wordDictionary.search(&quot;pattern&quot;);int main()&#123;    WordDictionary wd;    wd.addWord(&quot;abc&quot;);    wd.addWord(&quot;hello&quot;);        if(wd.search(&quot;ab.&quot;))        cout&lt;&lt;&quot;Get ab.&quot;&lt;&lt;endl;    if(wd.search(&quot;abd&quot;))        cout&lt;&lt;&quot;Get ab.&quot;&lt;&lt;endl;        return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>采用前缀树来保存数据，根节点不保存任何数据，每个节点有26个孩子节点，代表’a-z’.同时，每个节点需要一个标记，来表示当前节点是否可以为一个单词结束节点。<br>Addword()函数较为容易实现，SearchWord()函数采用深度优先搜索，以递归的方式查询。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Course Schedule2</title>
    <link href="/2015/10/09/leetcode_course_schedule2/"/>
    <url>/2015/10/09/leetcode_course_schedule2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p><p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p><p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p><p>For example:</p><pre><code class="hljs">2, [[1,0]]</code></pre><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]</p><pre><code class="hljs">4, [[1,0],[2,0],[3,1],[3,2]]</code></pre><p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p><p>The original problem is <a href="https://leetcode.com/problems/course-schedule-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/CourseSchedule2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Course Schedule II *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    queue&lt;int&gt; q;  //save the course whos prerequisites are all finished    vector&lt;int&gt; res;    vector&lt;int&gt; empty;    vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123;        if(numCourses &lt;= 0 )&#123; //|| !canFinish(numCourses, prerequisites            return res;        &#125;        int len = prerequisites.size();        if(len == 0)&#123;            for(int i=0;i&lt;numCourses;i++)                res.push_back(i);            return res;        &#125;        vector&lt;int&gt; preNum(numCourses, 0);        for(int i=0;i&lt;len;i++)&#123;            preNum[prerequisites[i].first] ++;        &#125;        for(int i=0;i&lt;numCourses;i++)&#123;            if(preNum[i] == 0)                q.push(i);        &#125;        while(!q.empty())&#123;            int oneCourse = q.front();            res.push_back(oneCourse);            q.pop();            for(int i=0;i&lt;len;i++)&#123;                int course = prerequisites[i].first;                if(preNum[course] == 0)                    continue;                if(prerequisites[i].second == oneCourse)&#123;                    preNum[course] --;                    if(preNum[course] == 0)&#123;                        q.push(course);                    &#125;                &#125;            &#125;        &#125;        if(res.size() != numCourses)            return empty;        return res;    &#125;&#125;;int main()&#123;    Solution s;    pair&lt;int, int&gt; n1(0,1);    //pair&lt;int, int&gt; n2(2,0);    //pair&lt;int, int&gt; n3(3,1);    //pair&lt;int, int&gt; n4(3,2);        vector&lt;pair&lt;int,int&gt; &gt; vec;    vec.push_back(n1);    //vec.push_back(n2);    //vec.push_back(n3);    //vec.push_back(n4);    vector&lt;int&gt; res = s.findOrder(2, vec);    for(int i=0;i&lt;res.size();i++)        cout&lt;&lt;res[i]&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>借鉴了广度优先搜索遍历的思想。首先，得到不需要依赖其他课程的课程C0（肯定存在，否则无法完成整个课程安排）；其次，遍历C0，将所有依赖这些课程C0的课程C1的依赖课程数目减一，如果减为零，则该课程也退化为不需要依赖其他课程的课程， 将该课程加入到C0。在遍历C0的过程，即是得到结果的过程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Move Zeros</title>
    <link href="/2015/09/24/leetcode_move_zeroes/"/>
    <url>/2015/09/24/leetcode_move_zeroes/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p><p>Note:<br>    You must do this in-place without making a copy of the array.<br>    Minimize the total number of operations.</p><p>The original problem is <a href="https://leetcode.com/problems/move-zeroes/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MoveZeroes.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Move Zeroes*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        int end=size-1;        for(int i=0;i&lt;end;i++)&#123;            if(nums[i] != 0)&#123;                continue;            &#125;            else&#123;                for(int j=i;j&lt;end;j++)&#123;                    nums[j]=nums[j+1];                &#125;                nums[end]=0;                end --;                i--; //the numbers after zero move one step to the front, so the index i need one step move            &#125;        &#125;    &#125;&#125;;int main() &#123;    Solution s;    vector&lt;int&gt; nums;    nums.push_back(0);    nums.push_back(0);    nums.push_back(1);    //nums.push_back(3);        s.moveZeroes(nums);    for(int i=0;i&lt;nums.size();i++)&#123;        cout&lt;&lt;nums[i]&lt;&lt;endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>遍历数组，寻找0，通过冒泡方法，将0放置到数组的尾部.需要标记尾部已经确定的0的起始位置(end)；如果找到一个0，还需要把遍历的标记向前数组的起始方向移动一步（i–），因为非0的数向数组起始方向前移了一步。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中类的大小（Sizeof of Class in C++）</title>
    <link href="/2015/09/20/cpp_sizeof_class/"/>
    <url>/2015/09/20/cpp_sizeof_class/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>作为面向对象的语言，C++有很多面向对象的特性。对于一个类，如果能够准确判断其占用大小，说明对面向对象有了深入的理解。sizeof是一个操作符，返回一个变量或者对象的大小。</p><p>在求职面试的过程中，很多情况下，会涉及到这个问题。所以，这里列举了不同情况下C++中类的大小，默认是在64位机器上的结果。</p><span id="more"></span><h1 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h1><p>空类，就是除了构造函数和析构函数之外，没有其他的成员函数或者成员变量。当然，如果我们没有显式地写出构造函数和析构函数，编译器会替我们完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>class A&#123;<br>public:<br><span class="hljs-function"><span class="hljs-title">A</span></span>()&#123;&#125;<br>~<span class="hljs-function"><span class="hljs-title">A</span></span>()&#123;&#125;<br>&#125;; <br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()&#123;<br>A a;<br>cout&lt;&lt;<span class="hljs-string">sizeof(a)&lt;&lt;endl;</span><br><span class="hljs-string">return 0;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>运行代码，结果输出为1。对于空类，还是会分配一个字节的位置来标识该类的对象。</p><h1 id="含有不同数据类型的类"><a href="#含有不同数据类型的类" class="headerlink" title="含有不同数据类型的类"></a>含有不同数据类型的类</h1><p>含有不同数据类型的时候，要注意数据的对齐规则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>()&#123;&#125;<br>~<span class="hljs-built_in">A</span>()&#123;&#125;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">char</span> ch;<br><span class="hljs-keyword">double</span> n;<br>&#125;; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>A a;<br>cout&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码，结果输出为16（32位条件下也是16）。这个涉及到数据对齐，对齐规则是：占空间小的数据类型向占空间大的数据类型看齐，对齐的数目是2的幂次。比如，成员变量ch，由于只占了一个字节，所以要补成4个字节，所以，总共占用的空间是4+（1+3）+8=16。</p><h1 id="含有虚函数的类"><a href="#含有虚函数的类" class="headerlink" title="含有虚函数的类"></a>含有虚函数的类</h1><p>虚函数是个C++多态的重要组成，因为虚函数的存在，编译器会默认生成一个虚函数表和一个指向该表的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>()&#123;&#125;<br>~<span class="hljs-built_in">A</span>()&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//nothing</span><br>&#125;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">char</span> ch;<br><span class="hljs-keyword">double</span> n;<br>&#125;; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>A a;<br>cout&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码，结果输出为24（32位条件下是20）。因为虚函数的存在，编译器会默认生成一个指向虚函数表的指针，在64位机器上，指针的大小为8个字节。所以，整个对象的大小是 8+4+（1+3）+8=24。可以看到这里编译器很智能地把int 和char类型的还是对齐成4，这样节省了空间。</p><h1 id="含有static类型变量的类"><a href="#含有static类型变量的类" class="headerlink" title="含有static类型变量的类"></a>含有static类型变量的类</h1><p>在类中添加static类型的变量会发生什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>()&#123;&#125;<br>~<span class="hljs-built_in">A</span>()&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//nothing</span><br>&#125;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">char</span> ch;<br><span class="hljs-keyword">double</span> n;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_int;<br>&#125;; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>A a;<br>cout&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码，结果输出为24，和上一个类的大小相同。这是因为static类型是在静态存储区，并不属于该类的一个成员。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Interleaving String</title>
    <link href="/2015/09/18/leetcode_interleaving_string/"/>
    <url>/2015/09/18/leetcode_interleaving_string/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p><p>For example,<br>Given:<br>s1 = “aabcc”,<br>s2 = “dbbca”,</p><p>When s3 = “aadbbcbcac”, return true.<br>When s3 = “aadbbbaccc”, return false.</p><p>The original problem is <a href="https://leetcode.com/problems/interleaving-string/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/InterleavingString.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Interleaving String*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool isInterleave(string s1, string s2, string s3) &#123;        int m = s1.size();        int n = s2.size();        int k = s3.size();        if(k == 0)            return true;        if( m+n != k)            return false;        vector&lt;vector&lt;int&gt; &gt;  matrix(m+1, vector&lt;int&gt;(n+1, 0));                    matrix[0][0] = 1;                for(int i=1;i&lt;=m;i++)&#123;            if(s3[i-1] == s1[i-1])                matrix[i][0] = 1;            else                break;        &#125;        for(int j=1;j&lt;=n;j++)&#123;            if(s3[j-1] == s2[j-1])                matrix[0][j] = 1;            else                break;        &#125;        for(int i=1;i&lt;=m;i++)&#123;            char c1 = s1[i-1];            for(int j=1;j&lt;=n;j++)&#123;                char c2 = s2[j-1];                char c3 = s3[i+j-1];                if(c1 == c3)&#123;                    matrix[i][j] = matrix[i-1][j] || matrix[i][j];                &#125;                if(c2 == c3)                    matrix[i][j] = matrix[i][j-1] || matrix[i][j];                &#125;        &#125;                    return matrix[m][n];    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, dynamic programming is used. 创建了matrix表示利用s1和s2字符串交替创建s3的路径，即 matrix[i][j]表示s1的前i个字符和s2的前j个字符创建的字符串。对于s3的当前字符c3，如果和s1的当前字符c1相等，则如果matrix[i-1][j]是真（即可以组合成s3的前i+j个字符），则matrix[i][j]也为真。<br>注意</p><pre><code class="hljs">matrix[i][j] = matrix[i-1][j] || matrix[i][j]</code></pre><p>取或的原因是，如果c1和c3相等，但是c2和c3不相等，则matrix[i][j]会被先置为真，再置为假，如果取或，则为真。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Shortest Palindrome</title>
    <link href="/2015/09/18/leetcode_shortest_palindrome/"/>
    <url>/2015/09/18/leetcode_shortest_palindrome/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p><p>For example:</p><p>Given “aacecaaa”, return “aaacecaaa”.</p><p>Given “abcd”, return “dcbabcd”.</p><p>The original problem is <a href="https://leetcode.com/problems/shortest-palindrome/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ShortestPalindrome.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Shortest Palindrome*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    //Manacher algorithm    int longestPalindrom(string s) &#123;        int len = s.size();        string s1;        s1.resize(2 * s.length() + 2);        int idx = 0;        s1[idx++] = &#39;$&#39;;        s1[idx++] = &#39;#&#39;;        for (int i=0;i&lt;s.size(); i++) &#123;            s1[idx++] = s[i];            s1[idx++] = &#39;#&#39;;        &#125;        vector&lt;int&gt; p(s1.length(), 0);        int res = 0;        for (int id = 0, i = 1; i &lt; s1.length(); ++i) &#123;            if (i &lt; id + p[id])     // mx = id + p[id]                p[i] = min(p[2 * id - i], id + p[id] - i);            else                 p[i] = 1;            //compute the p            while (s1[i + p[i]] == s1[i - p[i]])                 ++p[i];                        if (id + p[id] &lt; i + p[i])                 id = i;            //the palindrome start from the beginning            if (p[i] == i)                res = max(res, i);        &#125;        return res - 1;    &#125;    string shortestPalindrome(string s) &#123;        int len = s.size();        if(len &lt;= 1)            return s;        int index = longestPalindrom(s) - 1;        cout&lt;&lt;&quot;index=&quot;&lt;&lt;index&lt;&lt;endl;        string res;        for(int i=len-1;i&gt;index;i--)            res.push_back(s[i]);        res = res + s;                return res;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>解题思路：首先，寻找以字符串第一个字符为起点的最长回文串；再将字符串中后面不属于回文的部分倒置，并防止新字符串的开始，然后再把该回文串放在其之后。</p><p>在寻找回文串的过程中，如果只是通过遍历，会超时。所以，采用Manacher算法，时间复杂度为O(n)。参考博客<img src="http://www.cnblogs.com/easonliu/p/4522724.html" alt="here"></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode House Robber2</title>
    <link href="/2015/09/17/leetcode_house_robber2/"/>
    <url>/2015/09/17/leetcode_house_robber2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Note: This is an extension of House Robber.</p><p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p><p>The original problem is <a href="https://leetcode.com/problems/house-robber-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/HouseRobber2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**House Robber*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        if(size &lt;= 0)            return 0;        if(size == 1)            return nums[0];                if(size == 2)            return max(nums[0], nums[1]);                vector&lt;int&gt; money = vector&lt;int&gt;(size, 0);        vector&lt;int&gt; index = vector&lt;int&gt;(size, 0);        //Dynamic programming        money[0] = nums[0];        index[0] = 1;        money[1] = max(nums[0],nums[1]);        if(nums[0] &gt; nums[1])            index[1] = 1;        else            index[1] = 0;        for(int count=2;count&lt;size;++count)&#123;            money[count] = max(money[count-1],money[count-2]+nums[count]);                        if( money[count-1] &gt;= money[count-2]+nums[count] )&#123;                if(count == size-1)                    return money[count];                index[count] = index[count-1];            &#125;             else                index[count] = index[count-2];        &#125;        if(index[size-1] == 0)            return money[size-1];        //The result without the last one         int max1 = money[size-2];                money[1] = nums[1];        money[2] = max(nums[1],nums[2]);        //Compute the result without the first one        for(int count=3;count&lt;size;++count)&#123;            money[count] = max(money[count-1],money[count-2]+nums[count]);                    &#125;        //return the max of the two results        return max(money[size-1], max1);    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, dynamic programming is used. Assume the robber get one house i, he just need to compute the maximum of the  nums[i-1] and (nums[i-2]+nums[i]) as the money[i], this will not alert police. In the end, the robber can get the maximum of money[end-1]; Additionally, the first and the end of the house can’t be robbed at the same time.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Construct Binary Tree from Inorder and Postorder Traversal</title>
    <link href="/2015/09/15/leetcode_construct_binary_tree_from_inorder_and_postorder_traversal/"/>
    <url>/2015/09/15/leetcode_construct_binary_tree_from_inorder_and_postorder_traversal/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>The original problem is <a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ConstructBinaryTreeFromInorderAndPostorderTraversal.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Construct Binary Tree from Inorder and Postorder Traversal*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;//Definition for a binary tree node. struct TreeNode &#123;     int val;     TreeNode *left;     TreeNode *right;     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; &#125;;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;        int len1 = postorder.size();        int len2 = inorder.size();        if(len1 != len2)            return NULL;        if(len1 &lt;= 0)            return NULL;        TreeNode * root = build(inorder, 0, len1-1, postorder, 0, len1-1);        return root;    &#125;    TreeNode* build(vector&lt;int&gt;&amp; inorder, int ni, int nj, vector&lt;int&gt;&amp; postorder, int pi, int pj)&#123;        if(pi &gt; pj)            return NULL;        if(ni &gt; nj)            return NULL;                int val = postorder[pj];        TreeNode *node = new TreeNode(val);        if(pi == pj)&#123;            return node;        &#125;        int pos = ni;        for(int i=ni;i&lt;=nj;i++)&#123;            if(inorder[i] == val) &#123;                pos = i;                break;            &#125;        &#125;        int leftLen  = pos-ni;        int rightLen = nj-pos;                node-&gt;left  = build(inorder, ni, pos-1, postorder, pi, pi+leftLen-1);        node-&gt;right = build(inorder, pos+1, nj, postorder, pj-rightLen, pj-1);        return node;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>根据后序序列，可以找到根节点，或者子树的根节点；在根据中序序列，可以分别找到左子树和右子树。递归地计算左子树和右子树，直至序列中只有一个节点，即叶子节点，就返回。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link href="/2015/09/15/leetcode_construct_binary_tree_from_preorder_and_inorder_traversal/"/>
    <url>/2015/09/15/leetcode_construct_binary_tree_from_preorder_and_inorder_traversal/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>The original problem is <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ConstructBinaryTreeFromPreorderAndInorderTraversal.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Construct Binary Tree from Preorder and Inorder Traversal*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;//Definition for a binary tree node. struct TreeNode &#123;     int val;     TreeNode *left;     TreeNode *right;     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; &#125;;class Solution &#123;public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;        int len1 = preorder.size();        int len2 = inorder.size();        if(len1 != len2)            return NULL;        if(len1 &lt;= 0)            return NULL;        TreeNode * root = build(preorder, 0, len1-1, inorder, 0, len1-1);        return root;    &#125;    TreeNode* build(vector&lt;int&gt;&amp; preorder, int pi, int pj, vector&lt;int&gt;&amp; inorder, int ni, int nj)&#123;        if(pi &gt; pj)            return NULL;        if(ni &gt; nj)            return NULL;                int val = preorder[pi];        TreeNode *node = new TreeNode(val);        if(pi == pj)&#123;            return node;        &#125;        int pos = ni;        for(int i=ni;i&lt;=nj;i++)&#123;            if(inorder[i] == val) &#123;                pos = i;                break;            &#125;        &#125;        int leftLen  = pos-ni;        int rightLen = nj-pos;                node-&gt;left  = build(preorder, pi+1, pi+leftLen, inorder, ni, pos-1);        node-&gt;right = build(preorder, pj-rightLen+1, pj, inorder, pos+1, nj);        return node;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>根据前序序列，可以找到根节点，或者子树的根节点；在根据中序序列，可以分别找到左子树和右子树。递归地计算左子树和右子树，直至序列中只有一个节点，即叶子节点，就返回。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Perfect Squares</title>
    <link href="/2015/09/13/leetcode_perfect_squares/"/>
    <url>/2015/09/13/leetcode_perfect_squares/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p><p>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p><p>The original problem is <a href="https://leetcode.com/problems/perfect-squares/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PerfectSquares.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Perfect Squares*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int numSquares(int n) &#123;        if(n &lt;= 0)            return -1;        if(n == 1)            return 1;        vector&lt;int&gt; square;        vector&lt;int&gt; nums;        nums.push_back(0);        nums.push_back(1);        int num = 1;        while(num*num &lt;= n)&#123;            square.push_back(num*num);            num ++;        &#125;                int index = 0;        for(int i=2;i&lt;=n;i++)&#123;            index = sqrt(i);            int factor = square[index-1];            if(factor == i) &#123;                nums.push_back(1);                continue;            &#125;            int minCount = nums[i-factor] + 1;            for(int j=index-2;j&gt;=0;j--)&#123;                factor = square[j];                int count = nums[i - factor] + 1;                minCount = min(minCount, count);            &#125;            cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;minCount&lt;&lt;endl;            nums.push_back(minCount);                    &#125;        return nums[n];    &#125;&#125;;int main()&#123;    Solution s;    int n = 100;    int result = s.numSquares(n);    cout&lt;&lt;&quot;result=&quot;&lt;&lt;result&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>采用动态规划解决.从1到n,依次计算每个数需要的最小平方数。对于一个数num，找到所有比它小的平方数S_i，比num小S_i的数所对应的数目再加一就是 num的数目, 再从这么数目中求最小的数目。这样就可以得到n的最小数目。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Longest Valid Parentheses</title>
    <link href="/2015/09/09/leetcode_longest_valid_parentheses/"/>
    <url>/2015/09/09/leetcode_longest_valid_parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p><p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p><p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p><p>The original problem is <a href="https://leetcode.com/problems/longest-valid-parentheses/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LongestValidParentheses.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Longest Valid Parentheses *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int longestValidParentheses(string s) &#123;        int len = s.size();        if( len &lt;= 0)            return 0;        stack&lt;int&gt; myStack; // save the index of &#39;(&#39;        int maxLen = 0, last = -1;        for(int i=0; i&lt;len; i++)&#123;            if(s[i] == &#39;(&#39;)                myStack.push(i);            else&#123;                if(!myStack.empty())&#123;                    myStack.pop();                    if(myStack.empty())                        maxLen = max(maxLen, i-last);                    else                        maxLen = max(maxLen, i-myStack.top());                &#125;                else&#123;                    last = i;                &#125;            &#125;        &#125;        return maxLen;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, a stack is used to save the index of ‘(‘. If the current char is ‘)’, pop the stack if it is not empty; otherwise, let last = the current index. After pop the stack, if the stack is empty, then get the length of new group valid parentheses by i-last; else, the length is i-stack.top(). </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode First Bad Version</title>
    <link href="/2015/09/08/leetcode_first_bad_version/"/>
    <url>/2015/09/08/leetcode_first_bad_version/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><p>The original problem is <a href="https://leetcode.com/problems/first-bad-version/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/FirstBadVersion.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**First Bad Version *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;// Forward declaration of isBadVersion API.bool isBadVersion(int version)&#123;    //if(version &gt;= 1702766719)    if(version &gt;= 2)        return true;    return false;&#125;class Solution &#123;public:    int firstBadVersion(int n) &#123;        double low = 1, high = n;        double middle = 0;        int m;        while(low &lt; high)&#123;            middle = (low + high) / 2;            m =  (int)floor(middle);            if(isBadVersion(m))                high = m;            else                low = m + 1;        &#125;        if(low == high)            return low;    &#125;    &#125;;int main() &#123;    int n = 2; //2126753390;    Solution s;    int res = s.firstBadVersion(n);    cout&lt;&lt;res&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, binary search is used. You should make sure that the value is not extend the scale of the 32bit int. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Course Schedule</title>
    <link href="/2015/08/31/leetcode_course_schedule/"/>
    <url>/2015/08/31/leetcode_course_schedule/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p><p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p><p>For example:</p><pre><code class="hljs">2, [[1,0]]</code></pre><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p><pre><code class="hljs">2, [[1,0],[0,1]]</code></pre><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p><p>The original problem is <a href="https://leetcode.com/problems/course-schedule/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/CourseSchedule.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Course Schedule *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    map&lt;int, vector&lt;int&gt; &gt; myMap;    map&lt;int, vector&lt;int&gt; &gt;::iterator iter;    bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt; &gt;&amp; prerequisites) &#123;        int len = prerequisites.size();        vector&lt;int&gt; visit(numCourses, 0);                   for(int i=0;i&lt;len;i++)&#123;            int num1 = prerequisites[i].first;            int num2 = prerequisites[i].second;            if(myMap.find(num1) == myMap.end())&#123;                vector&lt;int&gt; vec(1,num2);                myMap[num1] = vec;            &#125;            else&#123;                (myMap[num1]).push_back(num2);            &#125;        &#125;        for(iter = myMap.begin();iter != myMap.end(); iter++)&#123;            vector&lt;int&gt; nums = iter-&gt;second;            int begin = iter-&gt;first;            visit[begin] = -1;            for(int j=0;j&lt;nums.size();j++)&#123;                if(dfs(nums[j], visit))                    return false;            &#125;            visit[begin] = 1;        &#125;        return true;    &#125;    bool dfs(int num, vector&lt;int&gt; &amp;visit) &#123;        cout&lt;&lt;&quot;num=&quot;&lt;&lt;num&lt;&lt;endl;        if(visit[num] == -1)            return true;        if(visit[num] == 1)            return false;                    visit[num] = -1;        vector&lt;int&gt; vec;        if(myMap.find(num) != myMap.end())             vec = myMap[num];                for(int i=0;i&lt;vec.size();i++)&#123;            if(dfs(vec[i], visit))                return true;        &#125;        visit[num] = 1;        return false;    &#125;&#125;;int main()&#123;    Solution s;    pair&lt;int, int&gt; n1(0,1);    pair&lt;int, int&gt; n2(3,1);    pair&lt;int, int&gt; n3(1,3);    pair&lt;int, int&gt; n4(3,2);        vector&lt;pair&lt;int,int&gt; &gt; vec;    vec.push_back(n1);    vec.push_back(n2);    vec.push_back(n3);    vec.push_back(n4);    bool res = s.canFinish(4, vec);    cout&lt;&lt;&quot;res=&quot;&lt;&lt;res&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, depth-first search was used. The visited path is recorded, to reduce the used time, label the unvisited one to 0, label the visited one to -1, label the visited and without cycle ont to 1. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Different Ways To Add Parentheses</title>
    <link href="/2015/08/31/leetcode_different_ways_to_add_parentheses/"/>
    <url>/2015/08/31/leetcode_different_ways_to_add_parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.</p><p>Example 1<br>Input: “2-1-1”.</p><pre><code class="hljs">((2-1)-1) = 0(2-(1-1)) = 2</code></pre><p>Output: [0, 2]</p><p>The original problem is <a href="https://leetcode.com/problems/different-ways-to-add-parentheses/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/DifferentWaysToAddParentheses.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Different Ways to Add Parentheses *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;int&gt; diffWaysToCompute(string input) &#123;        int num = 0;        int i = 0, len = input.size();         for(i=0;i &lt; len &amp;&amp; input[i] &gt;=&#39;0&#39; &amp;&amp; input[i] &lt;= &#39;9&#39;;i++)&#123;            num = num * 10 + (input[i] - &#39;0&#39;);        &#125;        vector&lt;int&gt; result;                if(i &gt;= len)&#123;            result.push_back(num);                return result;        &#125;                           for(int j=0;j&lt;len;j++)&#123;            if(input[j] == &#39;+&#39; || input[j] == &#39;-&#39; || input[j] == &#39;*&#39;)&#123;                char op = input[j];                string left  = input.substr(0,j);                string right = input.substr(j+1, len - j -1);                vector&lt;int&gt; vecLeft  = diffWaysToCompute(left);                vector&lt;int&gt; vecRight = diffWaysToCompute(right);                                for(int k=0;k&lt;vecLeft.size();k++)&#123;                    for(int m=0;m&lt;vecRight.size();m++)&#123;                        int val = 0;                        if(op == &#39;+&#39;)                            val = vecLeft[k] + vecRight[m];                        else if(op == &#39;-&#39;)                            val = vecLeft[k] - vecRight[m];                        else if(op == &#39;*&#39;)                            val = vecLeft[k] * vecRight[m];                        result.push_back(val);                    &#125;                &#125;            &#125;                    &#125;        return result;    &#125;&#125;;int main()&#123;    Solution s;    string input(&quot;2*3-4*5&quot;);    vector&lt;int&gt; res = s.diffWaysToCompute(input);    for(int i=0;i&lt;res.size();i++)&#123;        cout&lt;&lt;res[i]&lt;&lt;endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, recursion was used. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Ugly Number2</title>
    <link href="/2015/08/30/leetcode_ugly_number2/"/>
    <url>/2015/08/30/leetcode_ugly_number2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Write a program to find the n-th ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</p><p>Note that 1 is typically treated as an ugly number.</p><p>The original problem is <a href="https://leetcode.com/problems/ugly-number-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/UglyNumber2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Ugly Number2*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int nthUglyNumber(int n) &#123;        if(n &lt;= 0)            return -1;        if(n == 1)            return 1;        int n1 = 0, n2 = 0, n3 = 0;        vector&lt;int&gt; L1, L2, L3;        L1.push_back(2);        L2.push_back(3);        L3.push_back(5);        int num = 1;        for(int count=2;count&lt;=n;count++)&#123;            int minNum=min(L1[n1],min(L2[n2],L3[n3]));                        L1.push_back(minNum * 2);            L2.push_back(minNum * 3);            L3.push_back(minNum * 5);                        if(L1[n1] == minNum)                n1 ++;            if(L2[n2] == minNum)                n2 ++;            if(L3[n3] == minNum)                n3 ++;            num = minNum;            //cout&lt;&lt;num&lt;&lt;endl;        &#125;        return num;    &#125;&#125;;int main()&#123;    Solution s;    int num = s.nthUglyNumber(12);    cout&lt;&lt;&quot;num=&quot;&lt;&lt;num&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;    </code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Three lists were used to save the ugly numbers. From 1-th to n-th ugly number, select the minimum of the three lists.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Edit Distance</title>
    <link href="/2015/08/26/leetcode_edit_distance/"/>
    <url>/2015/08/26/leetcode_edit_distance/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p><p>You have the following 3 operations permitted on a word:</p><p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p><p>The original problem is <a href="https://leetcode.com/problems/edit-distance/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/EditDistance.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Edit Distance*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int minDistance(string word1, string word2) &#123;        int size1 = word1.size();        int size2 = word2.size();        if(size1 &lt;= 0 &amp;&amp; size2 &gt; 0)            return size2;        else if(size2 &lt;= 0 &amp;&amp; size1&gt;0)            return size1;        else if(size1 &lt;= 0 &amp;&amp; size2 &lt;= 0)            return 0;        vector&lt;vector&lt;int&gt; &gt; distance(size1+1, vector&lt;int&gt;(size2+1,0));                for(int i=0;i&lt;=size1;i++)                distance[i][0] = i;        for(int j=0;j&lt;=size2;j++)                distance[0][j] = j;                for(int i=1;i&lt;=size1;i++)&#123;            for(int j=1;j&lt;=size2;j++)&#123;                if(word1[i-1] != word2[j-1])                    distance[i][j] = min(min(distance[i-1][j-1], distance[i-1][j]), distance[i][j-1]) + 1;                else                    distance[i][j] = distance[i-1][j-1];            &#125;        &#125;        return distance[size1][size2];    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, dynamic programming was used. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Simplify Path</title>
    <link href="/2015/08/26/leetcode_simplify_path/"/>
    <url>/2015/08/26/leetcode_simplify_path/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an absolute path for a file (Unix-style), simplify it.</p><p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”</p><p>The original problem is <a href="https://leetcode.com/problems/simplify-path/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SimplifyPath.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Simplify Path*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    string simplifyPath(string path) &#123;        string result;        int size = path.size();        stack&lt;string&gt; myStack;        string onePart;        int i=0,j=0;        for(;i&lt;size;i++)&#123;            int len = i-j-1;            if(path[i] == &#39;/&#39;)&#123;                if(len &gt; 0)&#123;                    onePart = path.substr(j+1,len);                    if(onePart == &quot;.&quot;)                        ;                    else if(onePart == &quot;..&quot;)&#123;                        if(!myStack.empty())                            myStack.pop();                    &#125;                    else                        myStack.push(onePart);                &#125;                                j = i;            &#125;            else if(i == size - 1 &amp;&amp; len &gt;= 0)&#123;                onePart = path.substr(j+1,len+1);                if(onePart == &quot;.&quot;)                    ;                else if(onePart == &quot;..&quot;)&#123;                    if(!myStack.empty())                        myStack.pop();                &#125;                else                    myStack.push(onePart);            &#125;        &#125;        while(!myStack.empty())&#123;            if(result.size() == 0)                result = myStack.top();            else                result = myStack.top() + &quot;/&quot; + result;            myStack.pop();        &#125;        result = &quot;/&quot; + result;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, a stack is used to save every part of the path. If reach “.”, ignore it, if reach “..”, pop the stack.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Missing Number</title>
    <link href="/2015/08/26/leetcode_missing_number/"/>
    <url>/2015/08/26/leetcode_missing_number/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p><p>For example,<br>Given nums = [0, 1, 3] return 2.</p><p>Note:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p><p>The original problem is <a href="https://leetcode.com/problems/missing-number/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MissingNumber.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Missing Number *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        int sum = size * (1 + size) / 2;        int total = 0;        for(int i=0;i&lt;size;i++)&#123;            total += nums[i];        &#125;        return sum-total;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, first comput the sum of the array 0…n with the missing number. Then add all the number to total, we can get the missing number by sum-total.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Binary Tree Paths</title>
    <link href="/2015/08/26/leetcode_binary_tree_paths/"/>
    <url>/2015/08/26/leetcode_binary_tree_paths/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, return all root-to-leaf paths.</p><p>For example, given the following binary tree:</p><pre><code class="hljs">   1 /   \2     3 \  5</code></pre><p>All root-to-leaf paths are:</p><pre><code class="hljs">[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</code></pre><p>The original problem is <a href="https://leetcode.com/problems/binary-tree-paths/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BinaryTreePaths.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Binary Tree Paths *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;string&gt; result;    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;        string str;        TreePath(root, str);        return result;    &#125;    void TreePath(TreeNode* root, string str)&#123;        if(root == NULL)            return;        stringstream ss;        string val;        ss&lt;&lt;root-&gt;val;        ss&gt;&gt;val;        ss.clear();        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)&#123;            if(str.size() == 0)                str += val;            else&#123;                str.push_back(&#39;-&#39;);                str.push_back(&#39;&gt;&#39;);                str += val;            &#125;            result.push_back(str);                &#125;        else&#123;            if(root-&gt;left != NULL)&#123;                string str1 = str;                if(str1.size() == 0)                    str1 += val;                else&#123;                    str1.push_back(&#39;-&#39;);                    str1.push_back(&#39;&gt;&#39;);                    str1 += val;                &#125;                TreePath(root-&gt;left, str1);            &#125;            if(root-&gt;right != NULL)&#123;                string str2 = str;                if(str2.size() == 0)                    str2 += val;                else&#123;                    str2.push_back(&#39;-&#39;);                    str2.push_back(&#39;&gt;&#39;);                    str2 += val;                &#125;                TreePath(root-&gt;right, str2);            &#125;        &#125;         &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, depth-first search was used. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Ugly Number</title>
    <link href="/2015/08/24/leetcode_ugly_number/"/>
    <url>/2015/08/24/leetcode_ugly_number/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Write a program to check whether a given number is an ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p><p>Note that 1 is typically treated as an ugly number.</p><p>The original problem is <a href="https://leetcode.com/problems/ugly-number/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/UglyNumber.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Ugly Number*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool isUgly(int num) &#123;        if(num == 0)            return false;        if(num == 1)            return true;        if(num % 2 == 0)&#123;            if(num/2 == 0)                return true;            return isUgly(num/2);        &#125;                    else if(num % 3 == 0)&#123;            if(num/3 == 0)                return true;            return isUgly(num/3);        &#125;        else if(num % 5 == 0)&#123;            if(num/5 == 0)                return true;            return isUgly(num/5);        &#125;        else             return false;    &#125;&#125;;int main()&#123;    Solution s;    int num = 14;    bool result = s.isUgly(num);    cout&lt;&lt;&quot;Result=&quot;&lt;&lt;result&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Recursion is used to the problem.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Substring with Concatenation of All Words</title>
    <link href="/2015/08/18/leetcode_substring_with_concatenation_of_all_words/"/>
    <url>/2015/08/18/leetcode_substring_with_concatenation_of_all_words/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p><p>For example, given:<br>s: “barfoothefoobarman”<br>words: [“foo”, “bar”]</p><p>You should return the indices: [0,9].<br>(order does not matter).</p><p>The original problem is <a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SubstringWithConcatenationOfAllWords.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Substring with Concatenation of All Words *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;        vector&lt;int&gt; result;        int wordsNum = words.size();        if(wordsNum &lt;= 0)            return result;        int wordLen = words[0].size();        int strLen  = s.size();        if(strLen &lt;= 0 || strLen &lt; wordLen)            return result;                map&lt;string, int&gt; wordMap;        for(int i=0;i&lt;wordsNum;i++)            ++ wordMap[words[i]];                int subLen = wordsNum * wordLen;         for(int i=0;i&lt;=strLen - subLen;i++)&#123;            map&lt;string, int&gt; myMap(wordMap);            for(int j=i;j&lt;i+subLen;j+=wordLen)&#123;                string substr = s.substr(j,wordLen);                if(myMap.find(substr) != myMap.end())&#123;                    myMap[substr] --;                    if(myMap[substr] == 0)                        myMap.erase(substr);                &#125;                                    else                    break;            &#125;            if(myMap.size() == 0)                result.push_back(i);        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, we need traversal the string. And, map is used to save the dictionary. If a substring is consisted of all the words in the dictionary, we get one answer.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeeCcode： LRU Cache</title>
    <link href="/2015/08/13/leetcode_lru_cache/"/>
    <url>/2015/08/13/leetcode_lru_cache/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.</p><p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>The original problem is <a href="https://leetcode.com/problems/lru-cache/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LRUCache.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**LRU Cache*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;class LRUCache&#123;public:    LRUCache(int capacity) &#123;        this-&gt;capacity = capacity;    &#125;        int get(int key) &#123;        if(cacheMap.find(key) == cacheMap.end())            return -1;                cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);        cacheMap[key] = cacheList.begin();        return cacheMap[key]-&gt;value;    &#125;        void set(int key, int value) &#123;        if(cacheMap.find(key) == cacheMap.end())&#123;            if(capacity == cacheList.size())&#123;                cacheMap.erase(cacheList.back().key);                cacheList.pop_back();             &#125;            CacheNode node(key,value);            cacheList.push_front(node);            cacheMap[key] = cacheList.begin();        &#125;        else&#123;            cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);            cacheMap[key] = cacheList.begin();            cacheMap[key]-&gt;value = value;        &#125;            &#125;private:    struct CacheNode&#123;        int key;        int value;        CacheNode(int k, int v):key(k), value(v)&#123;&#125;    &#125;;    int capacity;    list&lt;CacheNode&gt; cacheList;    map&lt;int, list&lt;CacheNode&gt;::iterator&gt; cacheMap;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, a bidirector list and a hashmap are needed. For every operation, put the visited node to the head of the list.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Clone Graph</title>
    <link href="/2015/08/13/leetcode_clone_graph/"/>
    <url>/2015/08/13/leetcode_clone_graph/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p><p>The original problem is <a href="https://leetcode.com/problems/clone-graph/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/CloneGraph.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">    /*    *Clone Graph    *Author: shuaijiang    *Email: zhaoshuaijiang8@gmail.com    */        #include&lt;iostream&gt;    #include&lt;vector&gt;    #include &lt;unordered_set&gt;    #include&lt;string.h&gt;    #include&lt;stdlib.h&gt;        /**     * Definition for undirected graph.     * struct UndirectedGraphNode &#123;     *     int label;     *     vector&lt;UndirectedGraphNode *&gt; neighbors;     *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;     * &#125;;     */    class Solution &#123;    public:        UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) &#123;            if(node == NULL)                return NULL;            map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; copied;            clone(node, copied);               return copied[node];        &#125;        UndirectedGraphNode *clone(UndirectedGraphNode *node, map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; copied) &#123;            if(node == NULL)                return NULL;            if(copied.find(node) != copied.end())                 return copied[node];            UndirectedGraphNode * root = new UndirectedGraphNode(node-&gt;label);               vector&lt;UndirectedGraphNode *&gt; neighbors = node-&gt;neighbors;               copied[node] = root;               for(int i=0;i&lt;neighbors.size(); i++)&#123;                   UndirectedGraphNode * temp = neighbors[i];                   UndirectedGraphNode * neighbor = cloneGraph(temp, copied);                   root-&gt;neighbors.push_back(neighbor);               &#125;               return root;        &#125;    &#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, depth-first search was used. In order to avoid the node to be copied more than once, a map was also need. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Word Ladder</title>
    <link href="/2015/08/13/leetcode_word_ladder/"/>
    <url>/2015/08/13/leetcode_word_ladder/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two words (beginWord and endWord), and a dictionary, find the length of shortest transformation sequence from beginWord to endWord, such that:</p><ol><li>Only one letter can be changed at a time</li><li>Each intermediate word must exist in the dictionary</li></ol><p>For example,</p><p>Given:<br>start = “hit”<br>end = “cog”<br>dict = [“hot”,”dot”,”dog”,”lot”,”log”]<br>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p><p>The original problem is <a href="https://leetcode.com/problems/word-ladder/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/WordLadder.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Word Ladder*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordDict) &#123;        map&lt;string, int&gt; wordVisited;        queue&lt;string&gt; curr;        bool found = false;        int len = 0;        curr.push(beginWord);        while(!curr.empty() &amp;&amp; !found)&#123;            len ++;            queue&lt;string&gt; next;            while(!curr.empty() &amp;&amp; !found)&#123;                string str = curr.front();                curr.pop();                for(int i=0;i&lt;str.size();i++)&#123;                    for(char ch=&#39;a&#39;;ch&lt;=&#39;z&#39;;ch++)&#123;                        if(ch == str[i])                            continue;                        swap(ch, str[i]);                        if(str == endWord)&#123;                            found = true;                            break;                        &#125;                        if(wordDict.count(str)&gt;0 &amp;&amp; wordVisited.find(str) == wordVisited.end())&#123;                            wordVisited[str] = 1;                            next.push(str);                        &#125;                                                swap(str[i], ch);                    &#125;                &#125;            &#125;            curr = next;        &#125;        if(found)            return len+1;        else            return 0;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, width-first search was used. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Unqiue Binary Search Trees 2</title>
    <link href="/2015/08/13/leetcode_unqiue_binary_search_trees2/"/>
    <url>/2015/08/13/leetcode_unqiue_binary_search_trees2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p><p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.</p><pre><code class="hljs">   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</code></pre><p>The original problem is <a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/UniqueBinarySearchTrees2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Unique Binary Search Trees II *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;TreeNode*&gt; generateTrees(int n) &#123;        if(n == 0)            return buildTree(1,0);        return buildTree(1,n);    &#125;    vector&lt;TreeNode*&gt; buildTree(int start, int end)&#123;        vector&lt;TreeNode*&gt; tree;        if(start &gt; end)&#123;            tree.push_back(NULL);            return tree;        &#125;        for(int i=start; i&lt;=end;i++)&#123;                        vector&lt;TreeNode*&gt; leftTree = buildTree(start, i-1);            vector&lt;TreeNode*&gt; rightTree = buildTree(i+1, end);            for(int left=0;left&lt;leftTree.size();left++)&#123;                for(int right=0;right&lt;rightTree.size();right++)&#123;                    TreeNode* node = new TreeNode(i);                    node-&gt;left = leftTree[left];                    node-&gt;right = rightTree[right];                    tree.push_back(node);                &#125;            &#125;        &#125;        return tree;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, recursion is used for find the left and right child of the tree. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Palindrome Partitioning</title>
    <link href="/2015/08/13/leetcode_palindrome_partitioning/"/>
    <url>/2015/08/13/leetcode_palindrome_partitioning/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of s.</p><p>For example, given s = “aab”,<br>Return</p><pre><code class="hljs">  [    [&quot;aa&quot;,&quot;b&quot;],    [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]  ]</code></pre><p>The original problem is <a href="https://leetcode.com/problems/palindrome-partitioning/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PalindromePartitioning.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Palindrome Partitioning *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        vector&lt;vector&lt;string&gt;&gt; result;        int len = s.length();        if(len &lt;= 0)            return result;        vector&lt;string&gt; path;        dfs(s, path, result, 0, 1);        return result;    &#125;    void dfs(string &amp;s, vector&lt;string&gt; &amp;path, vector&lt;vector&lt;string&gt;&gt; &amp;result, int prev, int start)&#123;        if(start == s.size())&#123;            if(isPalindrome(s, prev, start-1))&#123;                path.push_back(s.substr(prev, start-prev));                result.push_back(path);                path.pop_back();            &#125;            return;        &#125;        dfs(s, path, result, prev, start+1);        if(isPalindrome(s, prev, start-1))&#123;            path.push_back(s.substr(prev, start-prev));            dfs(s, path, result, start, start+1);            path.pop_back();                    &#125;        return;    &#125;    bool isPalindrome(string &amp; s, int start, int end)&#123;        while(s[start] == s[end])&#123;            start ++;            end --;        &#125;        if(start &lt; end)            return false;        else            return true;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, depth-first search was used. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Integer To Roman</title>
    <link href="/2015/08/13/leetcode_integer_to_roman/"/>
    <url>/2015/08/13/leetcode_integer_to_roman/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an integer, convert it to a roman numeral.</p><p>Input is guaranteed to be within the range from 1 to 3999.</p><p>The original problem is <a href="https://leetcode.com/problems/integer-to-roman/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/IntegerToRoman.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Integer to Roman*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    string intToRoman(int num) &#123;        int radix[] = &#123;1000,900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;        string symbol[] = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;        string roman;        for(int i=0;num&gt;0;i++)&#123;            int count = num / radix[i];            num =  num % radix[i];            while(count&gt;0)&#123;                roman += symbol[i];                count--;            &#125;        &#125;        return roman;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, the num was divided by the radix from 1000 to 1, and the num was assigned by the remainder. The roman was joint with the symbol.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Word Search</title>
    <link href="/2015/08/12/leetcode_word_search/"/>
    <url>/2015/08/12/leetcode_word_search/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>For example,<br>Given board =</p><pre><code class="hljs">[  [&quot;ABCE&quot;],  [&quot;SFCS&quot;],  [&quot;ADEE&quot;]]</code></pre><p>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p><p>The original problem is <a href="https://leetcode.com/problems/word-search/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/WordSearch.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Word Search*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;        int rowNum = board.size();        if(rowNum &lt;= 0)            return false;        int colNum = board[0].size();        vector&lt;vector&lt;char&gt;&gt; myBoard = board;        for(int i=0;i&lt;rowNum;i++)&#123;            for(int j=0;j&lt;colNum;j++)&#123;                if(board[i][j] == word[0])&#123;                    myBoard = board;                    if(same(myBoard,i,j,word,0))                        return true;                &#125;            &#125;        &#125;        return false;    &#125;    bool same(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j, string word, int index)&#123;        if(index == word.size()-1)&#123;            if(board[i][j] == word[index])                return true;            else                return false;        &#125;         else&#123;            if(board[i][j] == word[index])                board[i][j] = &#39;_&#39;;            else                return false;            bool flag = false;            if(i&gt;0)&#123;                vector&lt;vector&lt;char&gt;&gt; myBoard = board;                flag = flag || same(myBoard, i-1, j, word, index+1);            &#125;                            if(i&lt;board.size()-1)&#123;                vector&lt;vector&lt;char&gt;&gt; myBoard = board;                flag = flag || same(myBoard, i+1, j, word, index+1);            &#125;                            if(j&gt;0)&#123;                vector&lt;vector&lt;char&gt;&gt; myBoard = board;                flag = flag || same(myBoard, i, j-1, word, index+1);            &#125;                            if(j&lt;board[0].size()-1)&#123;                vector&lt;vector&lt;char&gt;&gt; myBoard = board;                flag = flag || same(myBoard, i, j+1, word, index+1);            &#125;                            return flag;        &#125;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>I use depth-first search to find the word in the borad. The same letter cell may not be used more than once, so the used letter was labeled.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Recover Binary Search Tree</title>
    <link href="/2015/08/12/leetcode_recover_binary_search_tree/"/>
    <url>/2015/08/12/leetcode_recover_binary_search_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Two elements of a binary search tree (BST) are swapped by mistake.</p><p>Recover the tree without changing its structure.</p><p>The original problem is <a href="https://leetcode.com/problems/recover-binary-search-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RecoverBinarySearchTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Recover Binary Search Tree *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    pair&lt;TreeNode*, TreeNode*&gt; badNode;    void recoverTree(TreeNode* root) &#123;        if(root==NULL)            return;                TreeNode *prev = NULL ;        TreeNode *curr = root;        while(curr != NULL)&#123;            if(curr-&gt;left == NULL)&#123;                WrongDetect(prev, curr);                prev = curr;                curr = curr-&gt;right;            &#125;            else&#123;                TreeNode * node = curr-&gt;left;                while(node-&gt;right != NULL &amp;&amp; node-&gt;right != curr)                    node = node-&gt;right;                if(node-&gt;right == NULL)&#123;                    node-&gt;right = curr;                    curr = curr-&gt;left;                &#125;                else&#123;                    WrongDetect(prev, curr);                    node-&gt;right = NULL;                     prev = curr;                    curr = curr-&gt;right;                &#125;            &#125;        &#125;        int temp = badNode.first-&gt;val;        badNode.first-&gt;val = badNode.second-&gt;val;        badNode.second-&gt;val = temp;    &#125;    void WrongDetect(TreeNode * prev, TreeNode * curr)&#123;        if(prev != NULL &amp;&amp; prev-&gt;val &gt; curr-&gt;val)&#123;            if(badNode.first == NULL)                badNode.first = prev;            badNode.second = curr;        &#125;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Traversal the tree by inorder and find the wrong node. Finally, swap the two nodes.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Surrounded Regions</title>
    <link href="/2015/08/12/leetcode_surrounded_regions/"/>
    <url>/2015/08/12/leetcode_surrounded_regions/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a 2D board containing ‘X’ and ‘O’, capture all regions surrounded by ‘X’.</p><p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p><p>For example,</p><pre><code class="hljs">X X X XX O O XX X O XX O X X</code></pre><p>After running your function, the board should be:</p><pre><code class="hljs">X X X XX X X XX X X XX O X X</code></pre><p>The original problem is <a href="https://leetcode.com/problems/surrounded-regions/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SurroundedRegions.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Surrounded Regions *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:        void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        int rowNum = board.size();        if(rowNum &lt;= 2)            return;        int colNum = board[0].size();        if(colNum &lt;= 2)            return;                for(int j=0; j &lt; colNum; j++)&#123;            if(board[0][j] == &#39;O&#39;)                isRegion(board, 0, j, rowNum, colNum);            if(board[rowNum-1][j] == &#39;O&#39;)                 isRegion(board, rowNum-1, j, rowNum, colNum);        &#125;        for(int i=0; i &lt; rowNum; i++)&#123;            if(board[i][0] == &#39;O&#39;)                 isRegion(board, i, 0, rowNum, colNum);            if(board[i][colNum-1] == &#39;O&#39;)                isRegion(board, i, colNum-1, rowNum, colNum);        &#125;                for(int i = 0; i &lt; rowNum; i++)&#123;            for(int j = 0; j &lt; colNum; j++)&#123;                if(board[i][j] == &#39;O&#39;)                    board[i][j] = &#39;X&#39;;                else if(board[i][j] == &#39;_&#39;)                     board[i][j] = &#39;O&#39;;            &#125;        &#125;        return;    &#125;    void isRegion(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, int row, int col)&#123;        if(board[i][j] == &#39;O&#39;)            board[i][j] = &#39;_&#39;;        else            return;        if(i &gt; 1 &amp;&amp; board[i-1][j] == &#39;O&#39;)        &#123;            //board[i-1][j] = &#39;_&#39;;            isRegion(board, i-1, j, row, col);        &#125;        if(i &lt; row-1 &amp;&amp; board[i+1][j] == &#39;O&#39;)        &#123;            //board[i+1][j] = &#39;_&#39;;            isRegion(board, i+1, j, row, col);        &#125;        if(j &gt; 1 &amp;&amp; board[i][j-1] == &#39;O&#39;)        &#123;           // board[i][j-1] = &#39;_&#39;;            isRegion(board, i, j-1, row, col);        &#125;        if(j &lt; col-1 &amp;&amp; board[i][j+1] == &#39;O&#39;)        &#123;            //board[i][j+1] = &#39;_&#39;;            isRegion(board, i, j+1, row, col);        &#125;        return;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>The problem is similar to the problem<a href="https://leetcode.com/problems/number-of-islands/">Number of Islands</a>. We just traversal the number at the first row, first column, last row and last column. Then depth-first search from the number to find the ‘O’. The ‘O’s which are not visited need converted to ‘X’.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Repeated DNA Sequences</title>
    <link href="/2015/08/10/leetcode_repeated_dna_sequences/"/>
    <url>/2015/08/10/leetcode_repeated_dna_sequences/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p><p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p><p>For example,</p><pre><code class="hljs">Given s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,Return:[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;].</code></pre><p>The original problem is <a href="https://leetcode.com/problems/repeated-dna-sequences/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RepeatedDNASequences.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Repeated DNA Sequences*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;#define Code 0x3ffff using namespace std;class Solution &#123;public:    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;        int size = s.size();        vector&lt;string&gt; res;        if(size &lt;= 10)            return res;        map&lt;int, int&gt; myMap;        map&lt;char, int&gt; char2int;        char2int[&#39;A&#39;] = 0;        char2int[&#39;C&#39;] = 1;        char2int[&#39;G&#39;] = 2;        char2int[&#39;T&#39;] = 3;        int strInt = 0;        for(int i=0;i&lt;10;i++)&#123;            strInt = (strInt &lt;&lt; 2) + char2int[s[i]];        &#125;        myMap[strInt] = 1;                for(int i=10; i&lt;size; i++)&#123;            strInt = ((strInt &amp; Code) &lt;&lt; 2) + char2int[s[i]];            if(myMap.find(strInt) == myMap.end())                myMap[strInt] = 1;            else&#123;                if(myMap[strInt] == 1)&#123;                    string substr = s.substr(i-9,10);                    res.push_back(substr);                &#125;                myMap[strInt] ++;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, use a map to save the 10-letter-long sequences and the frequence of it. Put the sequences with more than 1 frequence to the result.</p><p>However, this solution lead to ‘Memory Limit Exceeded’, to solve the problem, convert the 10-letter-long substring to an integer with ‘A’ represent ‘00’, ‘C’ represent ‘01’, ‘G’ represent ‘10’, ‘T’ represent ‘11’.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Maximum Gap</title>
    <link href="/2015/08/06/leetcode_maximum_gap/"/>
    <url>/2015/08/06/leetcode_maximum_gap/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p><p>Try to solve it in linear time/space.</p><p>Return 0 if the array contains less than 2 elements.</p><p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p><p>The original problem is <a href="https://leetcode.com/problems/maximum-gap/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MaximumGap.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Maximum Gap*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int maximumGap(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        if(size &lt; 2)            return 0;        sort(nums.begin(),nums.end());        int maxGap = 0;        for(int i=1;i&lt;size;i++)&#123;            if(nums[i]-nums[i-1] &gt; maxGap)                maxGap = nums[i]-nums[i-1];        &#125;        return maxGap;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, first sort the array, and then find the maximum gap. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Maximal Square</title>
    <link href="/2015/08/05/leetcode_maximal_square/"/>
    <url>/2015/08/05/leetcode_maximal_square/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.</p><p>For example, given the following matrix:</p><pre><code class="hljs">1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0</code></pre><p>Return 4.</p><p>The original problem is <a href="https://leetcode.com/problems/maximal-square/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MaximalSquare.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Maximal Square*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;        int rowNum = matrix.size();        if(rowNum &lt;= 0)            return 0;        int colNum = matrix[0].size();        vector&lt;int&gt; oneRow(colNum, 0);        vector&lt;vector&lt;int&gt;&gt; dp;        for(int i=0;i&lt;rowNum;i++)            dp.push_back(oneRow);        int sideLength = 0;        // get the maximum side length        for(int i=0;i&lt;rowNum;i++)&#123;            for(int j=0;j&lt;colNum;j++)&#123;                dp[i][j] = matrix[i][j] - &#39;0&#39;;                if(i-1=&gt;0 &amp;&amp; j-1=&gt;0 &amp;&amp; dp[i][j]&gt;0)&#123;                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;                &#125;                if(dp[i][j] &gt; sideLength)                    sideLength = dp[i][j];            &#125;        &#125;        return sideLength * sideLength;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I use dynamic program and save the maximal side length of the square. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Best Time to Buy and Sell Stock 3</title>
    <link href="/2015/08/04/leetcode_best_time_to_buy_and_sell_stock3/"/>
    <url>/2015/08/04/leetcode_best_time_to_buy_and_sell_stock3/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p><p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p>The original problem is <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BestTimeToBuyAndSellStock3.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Best Time to Buy and Sell Stock III*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int size = prices.size();        if(size&lt;=0)            return 0;        vector&lt;int&gt; currProfit(size,0);        int maxPro = 0;        int result=0;        int minPrice = prices[0];        for(int i=1;i&lt;size;i++)&#123;            minPrice = min(prices[i-1], minPrice);            if((prices[i]-minPrice) &gt; maxPro)                maxPro = prices[i] - minPrice;            currProfit[i] = maxPro;        &#125;        maxPro = 0;        int maxPrice = prices[size-1];        for(int i=size-2;i&gt;=0;i--)&#123;            maxPrice = max(prices[i+1], maxPrice);            if((maxPrice - prices[i]) &gt; maxPro)                maxPro = maxPrice - prices[i];            if(maxPro + currProfit[i] &gt; result)                result = maxPro + currProfit[i];        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, first traversal the prices from head to tail and keep the maxProfit of the current price to an array. Then, traversal the prices from tail to head, and get the maxProfit from current price to the maxprice.</p><p>Finally, get the max profit by add the two part of the profit. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Search In Rotated Sorted Array 2</title>
    <link href="/2015/08/04/leetcode_search_in_rotated_sorted_array2/"/>
    <url>/2015/08/04/leetcode_search_in_rotated_sorted_array2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Follow up for “Search in Rotated Sorted Array”:<br>What if duplicates are allowed?</p><p>Would this affect the run-time complexity? How and why?</p><p>Write a function to determine if a given target is in the array.</p><p>The original problem is <a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SearchInRotatedSortedArray2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Search in Rotated Sorted Array II*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;        int size = nums.size();        if(size &lt;= 0)            return false;                sort(nums.begin(),nums.end());                int start, end, middle;        start = 0;         end = size-1;                while(start &lt;= end)&#123;            middle = (start+end) / 2;            if(nums[middle] == target)&#123;                return true;            &#125;                else if(nums[middle] &gt; target)                end = middle - 1;            else                start = middle + 1;        &#125;        return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, binary search is used.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Search In Rotated Sorted Array</title>
    <link href="/2015/08/04/leetcode_search_in_rotated_sorted_array/"/>
    <url>/2015/08/04/leetcode_search_in_rotated_sorted_array/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>The original problem is <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SearchInRotatedSortedArray.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Search in Rotated Sorted Array*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int size = nums.size();        map&lt;int,int&gt; myMap;        if(size &lt;= 0)            return -1;                for(int i=0;i&lt;size;i++)&#123;            myMap[nums[i]] = i;        &#125;                sort(nums.begin(),nums.end());                int start, end, middle;        start = 0;         end = size-1;                while(start &lt;= end)&#123;            middle = (start+end) / 2;            if(nums[middle] == target)&#123;                return myMap[nums[middle]];            &#125;                            else if(nums[middle] &gt; target)                end = middle - 1;            else                start = middle + 1;        &#125;        return -1;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, binary search is used. I use a map to save the indexes of the numbers.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Count Complete Tree Nodes</title>
    <link href="/2015/08/04/leetcode_count_complete_tree_nodes/"/>
    <url>/2015/08/04/leetcode_count_complete_tree_nodes/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a complete binary tree, count the number of nodes.</p><p>The original problem is <a href="https://leetcode.com/problems/count-complete-tree-nodes/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/CountCompleteTreeNodes.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Count Complete Tree Nodes *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    int countNodes(TreeNode* root) &#123;        if(root == NULL)             return 0;        int leftH  = leftHight(root) + 1;        int rightH = rightHight(root) + 1;        if(leftH == rightH)            return     2&lt;&lt;(leftH-1) - 1;        else            return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;    &#125;    int leftHight(TreeNode * root)&#123;        int hight = 0;        while(root-&gt;left != NULL)&#123;            root = root-&gt;left;            hight ++;        &#125;        return hight;    &#125;    int rightHight(TreeNode * root)&#123;        int hight = 0;        while(root-&gt;right != NULL)&#123;            root = root-&gt;right;            hight ++;        &#125;        return hight;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, recursion is used. If the left child and the right child have the different hight, we compute the nodes of the left and right, respectively. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Combination Sum 3</title>
    <link href="/2015/08/03/leetcode_combination_sum3/"/>
    <url>/2015/08/03/leetcode_combination_sum3/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p><p>Ensure that numbers within the set are sorted in ascending order.</p><p>Example 1:</p><pre><code class="hljs">Input: k = 3, n = 7</code></pre><p>Output:</p><pre><code class="hljs">[[1,2,4]]</code></pre><p>Example 2:</p><pre><code class="hljs">Input: k = 3, n = 9</code></pre><p>Output:</p><pre><code class="hljs">[[1,2,6], [1,3,5], [2,3,4]]</code></pre><p>The original problem is <a href="https://leetcode.com/problems/combination-sum-iii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/CombinationSum3.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Combination Sum*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:        vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;int&gt; nums;    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;                   for(int i=1;i&lt;=9;i++)            nums.push_back(i);        int size = nums.size();        if(size &lt;= 0)            return result;        vector&lt;int&gt; oneSet;        oneCombination(oneSet, 0, k, n);        return result;    &#125;    void oneCombination(vector&lt;int&gt; &amp;oneSet, int start, int k, int target) &#123;                if(oneSet.size() &gt; k)            return;        if(target &lt; 0)            return;        else if(target == 0)&#123;            for(int i=0;i&lt;result.size();i++)&#123;                if(sameSet(result[i], oneSet))                    return;            &#125;            if(oneSet.size() == k)                result.push_back(oneSet);            return;        &#125;        for(int i=start;i &lt; nums.size(); i++)&#123;            int newTarget = target-nums[i];            oneSet.push_back(nums[i]);            oneCombination(oneSet, i+1, k, newTarget);            oneSet.pop_back();        &#125;        return;    &#125;    bool sameSet(vector&lt;int&gt; set1, vector&lt;int&gt; set2) &#123;        int size1 = set1.size();        int size2 = set2.size();        if(size1 != size2)            return false;        for(int i=0;i&lt;size1;i++) &#123;            if(set1[i] != set2[i])                return false;        &#125;        return true;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, recursion is used. Similar to Combination Sum and Combination Sum II, but we need to judge the size of each set in the result.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Combination Sum 2</title>
    <link href="/2015/08/03/leetcode_combination_sum2/"/>
    <url>/2015/08/03/leetcode_combination_sum2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p><p>Each number in C may only be used once in the combination.</p><p>Note:</p><ul><li>All numbers (including target) will be positive integers.</li><li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set 10,1,2,7,6,1,5 and target 8,<br>A solution set is:<br>[1, 7]<br>[1, 2, 5]<br>[2, 6]<br>[1, 1, 6] </p><p>The original problem is <a href="https://leetcode.com/problems/combination-sum-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/CombinationSum2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Combination Sum*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:        vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;                   int size = candidates.size();        if(size &lt;= 0)            return result;        vector&lt;int&gt; oneSet;        sort(candidates.begin(),candidates.end());        oneCombination(candidates, oneSet, 0, target);        return result;    &#125;    void oneCombination(vector&lt;int&gt;&amp;candidates, vector&lt;int&gt; &amp;oneSet, int start, int target) &#123;                if(target &lt; 0)            return;        else if(target == 0)&#123;            for(int i=0;i&lt;result.size();i++)&#123;                if(sameSet(result[i], oneSet))                    return;            &#125;            result.push_back(oneSet);            return;        &#125;        for(int i=start;i &lt; candidates.size(); i++)&#123;            int newTarget = target-candidates[i];            oneSet.push_back(candidates[i]);            oneCombination(candidates, oneSet, i+1, newTarget);            oneSet.pop_back();        &#125;        return;    &#125;    bool sameSet(vector&lt;int&gt; set1, vector&lt;int&gt; set2) &#123;        int size1 = set1.size();        int size2 = set2.size();        if(size1 != size2)            return false;        for(int i=0;i&lt;size1;i++) &#123;            if(set1[i] != set2[i])                return false;        &#125;        return true;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, recursion is used. We also need to judge whether the reslt has duplicate combinations.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Combination Sum</title>
    <link href="/2015/08/03/leetcode_combination_sum/"/>
    <url>/2015/08/03/leetcode_combination_sum/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p><p>The same repeated number may be chosen from C unlimited number of times.</p><p>Note:</p><ul><li>All numbers (including target) will be positive integers.</li><li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set 2,3,6,7 and target 7,<br>A solution set is:<br>[7]<br>[2, 2, 3] </p><p>The original problem is <a href="https://leetcode.com/problems/combination-sum/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/CombinationSum.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Combination Sum*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:        vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;                   int size = candidates.size();        if(size &lt;= 0)            return result;        vector&lt;int&gt; oneSet;        sort(candidates.begin(),candidates.end());        oneCombination(candidates, oneSet, 0, target);        return result;    &#125;    void oneCombination(vector&lt;int&gt;&amp;candidates, vector&lt;int&gt; &amp;oneSet, int start, int target) &#123;                if(target &lt; 0)            return;        else if(target == 0)&#123;            result.push_back(oneSet);            return;        &#125;        for(int i=start;i &lt; candidates.size(); i++)&#123;            int newTarget = target-candidates[i];            oneSet.push_back(candidates[i]);            oneCombination(candidates, oneSet, i, newTarget);            oneSet.pop_back();        &#125;        return;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, recursion is used.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Jump Game 2</title>
    <link href="/2015/08/03/leetcode_jump_game2/"/>
    <url>/2015/08/03/leetcode_jump_game2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Your goal is to reach the last index in the minimum number of jumps.</p><p>For example:<br>Given array A = [2,3,1,1,4]</p><p>The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p><p>The original problem is <a href="https://leetcode.com/problems/jump-game-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/JumpGame2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Jump Game II*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int jump(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        int step = 0;        if(size &lt;= 1)            return step;                int currIndex = 0;        int nextIndex = nums[0];        while(currIndex &lt;= nextIndex &amp;&amp; currIndex &lt; size)&#123;            int temp = nextIndex;            for(int j=currIndex;j&lt;=temp &amp;&amp; j&lt;size;j++)&#123;                if(nums[j] + j &gt; nextIndex)&#123;                            nextIndex = nums[j] + j;                &#125;                &#125;            step ++;            currIndex = temp + 1;        &#125;        return step;    &#125;&#125;;int main() &#123;    Solution s;    vector&lt;int&gt; nums;    nums.push_back(1);    nums.push_back(2);        int result = s.jump(nums);    cout&lt;&lt;&quot;result=&quot;&lt;&lt;result&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem,  Greedy algoritym is used. It is similar to <a href="https://leetcode.com/problems/jump-game/">Jump Game</a>.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Anagrams</title>
    <link href="/2015/08/02/leetcode_anagrams/"/>
    <url>/2015/08/02/leetcode_anagrams/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of strings, return all groups of strings that are anagrams.</p><p>Note: All inputs will be in lower-case.</p><p>The original problem is <a href="https://leetcode.com/problems/anagrams/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Anagrams.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Anagrams*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt; #include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;string&gt; anagrams(vector&lt;string&gt;&amp; strs) &#123;        int size = strs.size();        map&lt;string, int&gt; myMap;        vector&lt;string&gt; result;        if(size &lt;= 0)            return result;                    for(int i=0;i&lt;size;i++)&#123;            string str = strs[i];            sort(str.begin(),str.end());            if(myMap.find(str) == myMap.end())&#123;                myMap[str] = i;            &#125;            else&#123;                if(myMap[str] &gt;= 0)&#123;                    result.push_back(strs[myMap[str]]);                    myMap[str] = -1;                &#125;                result.push_back(strs[i]);            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, save each new sorted string to the map, the key is the string, the value is its index. If two strings are anagrams, their sorted strings are the same. We can find the same sorted string, and push them in the vector.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Jump Game</title>
    <link href="/2015/08/02/leetcode_jump_game/"/>
    <url>/2015/08/02/leetcode_jump_game/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p>For example:<br>A = [2,3,1,1,4], return true.</p><p>A = [3,2,1,0,4], return false.</p><p>The original problem is <a href="https://leetcode.com/problems/jump-game/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/JumpGame.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Jump Game *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool canJump(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        if(size &lt;= 1)            return true;        vector&lt;bool&gt; path(size,false);        path[0] = true;        int currIndex = 0;        int nextIndex = nums[0];        while(currIndex &lt;= nextIndex &amp;&amp; currIndex &lt; size)&#123;            int temp = nextIndex;            for(int j=currIndex;j&lt;=nextIndex &amp;&amp; j&lt;size;j++)&#123;                path[j] = true;                if(nums[j] + j &gt; nextIndex)&#123;                                nextIndex = nums[j] + j;                &#125;                    &#125;            currIndex = temp + 1;        &#125;        return path[size-1];    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, greedy algorithm is used. We need currIndex and nextIndex to label the positions of one step. The path between the currIndex and nextIndex can be reached, and we can get the next nextIndex if nums[currIndex] + currIndex are larger than the nextIndex.  Steps by steps, finally we kown whether we reach the last one.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Letter Combinations Of A Phone Number</title>
    <link href="/2015/08/02/leetcode_letter_combinations_of_a_phone_number/"/>
    <url>/2015/08/02/leetcode_letter_combinations_of_a_phone_number/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a digit string, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p><p><img src="/image/telephonekeypad.png" alt="The keypad of telephone"></p><p>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><p>The original problem is <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LetterCombinationsOfAPhoneNumber.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Letter Combinations of a Phone Number *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;string&gt; letterCombinations(string digits) &#123;        vector&lt;string&gt; res;        string letter[] = &#123;&quot;&quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;;        int size = digits.size();        if(size &lt;= 0)            return res;        string firstStr = letter[digits[0]-&#39;0&#39;];        for(int i=0;i&lt;firstStr.size();i++)&#123;            string oneStr;            oneStr.push_back(firstStr[i]);            res.push_back(oneStr);        &#125;        for(int i=1;i&lt;size;i++)&#123;            if(digits[i] == &#39;0&#39;  || digits[i] == &#39;1&#39;)                continue;            else &#123;                vector&lt;string&gt; vec;                for(int j=0; j&lt;res.size();j++)&#123;                    string str = letter[digits[i]-&#39;0&#39;];                    for(int k=0;k&lt;str.size();k++)&#123;                        string oneRes = res[j];                            oneRes.push_back(str[k]);                        vec.push_back(oneRes);                    &#125;                &#125;                res = vec;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we just traversal the digits, and add every possible letter to the combinations. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Maximum Product Subarray</title>
    <link href="/2015/08/02/leetcode_maximum_product_subarray/"/>
    <url>/2015/08/02/leetcode_maximum_product_subarray/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p><p>The original problem is <a href="https://leetcode.com/problems/maximum-product-subarray/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MaximumProductSubarray.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Maximum Product Subarray *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        if(size &lt;= 0)            return 0;        if(size == 1)            return nums[0];        int maxNum = nums[0];        int minNum = nums[0];        int maxRes = nums[0];        for(int i=1;i&lt;size;i++)&#123;            int num1 = nums[i] * maxNum;            int num2 = nums[i] * minNum;            maxNum = max(max(num1,num2),nums[i]);            minNum = min(min(num1,num2),nums[i]);            maxRes = max(maxRes, maxNum);        &#125;        return maxRes;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, during traversal the array, save the maxNum and minNum. we need compute the product num1 of maxNum and the current num. If num1 is smaller than the current num, then set the current num to maxNum. It is similar to the minNum. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Valid Anagram</title>
    <link href="/2015/08/01/leetcode_valid_anagram/"/>
    <url>/2015/08/01/leetcode_valid_anagram/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two strings s and t, write a function to determine if t is an anagram of s.</p><p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p><p>Note:<br>You may assume the string contains only lowercase alphabets.</p><p>The original problem is <a href="https://leetcode.com/problems/valid-anagram/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ValidAnagram.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Valid Anagram *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt; #include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool isAnagram(string s, string t) &#123;        int size1 = s.size();        int size2 = t.size();        map&lt;char, int&gt; myMap;        if(size1 != size2)            return false;        if(size1 == 1 &amp;&amp; size2 == 1) &#123;            if(s[0] == t[0])                return true;            else                return false;        &#125;        for(int i=0;i&lt;size1;i++)&#123;            if(myMap.find(s[i]) == myMap.end())                myMap[s[i]] = 1;            else                myMap[s[i]] += 1;        &#125;        for(int i=0;i&lt;size1;i++)&#123;            if(myMap.find(t[i]) == myMap.end())                              return false;            else if(myMap[t[i]] == 0)                return false;            else                myMap[t[i]] --;        &#125;        return true;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, use a map to save the count of each alphabet in string s. Then, traversal string t, and find each alphabet in the map and minus the count of it. If the alphabet does not exist in the map or the count of the alphabet is zeros, then return false. Finally, return true.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Multiply Strings</title>
    <link href="/2015/08/01/leetcode_multiply_strings/"/>
    <url>/2015/08/01/leetcode_multiply_strings/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p><p>Note: The numbers can be arbitrarily large and are non-negative.</p><p>The original problem is <a href="https://leetcode.com/problems/multiply-strings/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MultiplyStrings.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Multiply Strings *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;stdlib.h&gt;using namespace std; class Solution &#123;public:    string multiply(string num1, string num2) &#123;          int size1 = num1.size();          int size2 = num2.size();          vector&lt;int&gt; result(size1+size2,0);          int k = size1+size2-2;          for(int i=0;i&lt;size1;i++)&#123;              int n1 = num1[i]-&#39;0&#39;;              for(int j=0;j&lt;size2;j++)&#123;                  int n2 = num2[j]-&#39;0&#39;;                  result[k-i-j] += n1 * n2;              &#125;          &#125;          int carries = 0;        for(int i=0;i&lt;size1+size2;i++)&#123;            result[i] += carries;            if(result[i] &gt; 9)&#123;                carries = result[i]/10;                result[i] = result[i] % 10;            &#125;            else                carries = 0;        &#125;        int i = size1+size2-1;        while(result[i] == 0)            i--;        string str;        for(int j=i;j&gt;=0;j--)&#123;            str.push_back(result[j]+&#39;0&#39;);        &#125;        if(str == &quot;&quot;)            str.push_back(&#39;0&#39;);        return str;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To simplify the problem, reference to <a href="http://www.cnblogs.com/TenosDoIt/p/3735309.html">blog</a>. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode First Missing Positive</title>
    <link href="/2015/07/28/leetcode_first_missing_positive/"/>
    <url>/2015/07/28/leetcode_first_missing_positive/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an unsorted integer array, find the first missing positive integer.</p><p>For example,<br>Given [1,2,0] return 3,<br>and [3,4,-1,1] return 2.</p><p>Your algorithm should run in O(n) time and uses constant space.</p><p>The original problem is <a href="https://leetcode.com/problems/first-missing-positive/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/FirstMissingPositive.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**First Missing Positive *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        bool positive = false;        sort(nums.begin(),nums.end());        for(int i=0;i&lt;size;i++)&#123;            if(positive)&#123;                if(nums[i]-nums[i-1] &gt; 1)                    return nums[i-1] + 1;            &#125;            else&#123;                if(nums[i]&gt;0)                    positive = true;                if(nums[i]&gt;1)                    return 1;            &#125;        &#125;        if(positive)            return nums[size-1]+1;        return 1;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, first sort the vector. Then, tranversal the vector and find the positive part, and take the first missing positive.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Max Points On A Line</title>
    <link href="/2015/07/28/leetcode_max_points_on_a_line/"/>
    <url>/2015/07/28/leetcode_max_points_on_a_line/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p><p>The original problem is <a href="https://leetcode.com/problems/max-points-on-a-line/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MaxPointsOnALine.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Max Points on a Line*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a point. * struct Point &#123; *     int x; *     int y; *     Point() : x(0), y(0) &#123;&#125; *     Point(int a, int b) : x(a), y(b) &#123;&#125; * &#125;; */class Solution &#123;public:    int maxPoints(vector&lt;Point&gt;&amp; points) &#123;        int maxNum = 0;                int size = points.size();        if(size &lt;= 2)            return size;                for(int i=0;i&lt;size;i++)&#123;            map&lt;double, int&gt; myMap;            int self = 1, vertical = 0;            for(int j=i+1;j&lt;size;j++)&#123;                int x1=points[i].x, y1=points[i].y;                int x2=points[j].x, y2=points[j].y;                if(x1 == x2 &amp;&amp; y1 == y2)                    self ++;                else if(x1 == x2)                    vertical ++;                else&#123;                    double a = (double)(y1-y2)/(x1-x2);                    if(myMap.find(a) == myMap.end())                        myMap[a] = 1;                    else                        myMap[a] += 1;                &#125;            &#125;            map&lt;double,int&gt;::iterator iter = myMap.begin();             int oneMax = vertical;            for(;iter!=myMap.end();iter++)&#123;                if(oneMax &lt; iter-&gt;second)                    oneMax = iter-&gt;second;            &#125;            oneMax += self;            if(oneMax &gt; maxNum)                maxNum = oneMax;        &#125;        return maxNum;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, fix one point and find the points which are on one line with it by compute the slope. If two points are on one vertical line, the slope doesn’t exist, so this situation should consider alone. Finally, we find the maximum number of points on one line. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Majority Element 2</title>
    <link href="/2015/07/27/leetcode_majority_element2/"/>
    <url>/2015/07/27/leetcode_majority_element2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.</p><p>The original problem is <a href="https://leetcode.com/problems/majority-element-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MajorityElement2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Majority Element II *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        vector&lt;int&gt; result;        if(size &lt;= 1)            return nums;        if(size == 2)&#123;            if(nums[0] != nums[1])                return nums;            else&#123;                result.push_back(nums[0]);                return result;            &#125;        &#125;        sort(nums.begin(),nums.end());        int count = 1;        for(int i=1;i&lt;size;i++)&#123;            if(nums[i] == nums[i-1])&#123;                count++;            &#125;            else&#123;                if(count&gt;size/3)                    result.push_back(nums[i-1]);                count = 1;            &#125;        &#125;        if(count &gt; size/3)            result.push_back(nums[size-1]);        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve this problem, sort the array first. Then, traversal the array, if the  element appears more than [n/3] times, add it to the result.   </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Candy</title>
    <link href="/2015/07/27/leetcode_candy/"/>
    <url>/2015/07/27/leetcode_candy/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>There are N children standing in a line. Each child is assigned a rating value.</p><p>You are giving candies to these children subjected to the following requirements:</p><ul><li><p>Each child must have at least one candy.</p></li><li><p>Children with a higher rating get more candies than their neighbors.</p></li></ul><p>What is the minimum candies you must give?</p><p>The original problem is <a href="https://leetcode.com/problems/candy/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Candy.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:    </p><pre><code class="hljs">/**Candy  *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int candy(vector&lt;int&gt;&amp; ratings) &#123;        vector&lt;int&gt; candies;        int size = ratings.size();        for(int i=0;i&lt;size;i++)            candies.push_back(1);        for(int i=1;i&lt;size;i++)&#123;            if(ratings[i] &gt; ratings[i-1])                candies[i] = candies[i-1] + 1;        &#125;        for(int i=size-2;i&gt;=0;i--)&#123;            if(ratings[i] &gt; ratings[i+1] &amp;&amp; candies[i] &lt;= candies[i+1])                candies[i] = candies[i+1] + 1;        &#125;        int result = 0;        for(int i=0;i&lt;size;i++)            result += candies[i];        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve this problem, vector candies is used to save the number of candies of children. </p><p>First, init every number in the vector to 1. </p><p>Second, traversal the ratings from head to tail, if the ratings[i] is larger than ratings[i-1], then candies[i] = candies[i-1] + 1.  </p><p>Third, traversal the ratings from tail to head, if ratings[i] is larger than ratings[i+1] and the candies[i] is not larger than candies[i+1], then candies[i] = candies[i+1]+1.</p><p>Finally, return the sum of the candies.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Lowest Common Ancestor Of A Binary Tree</title>
    <link href="/2015/07/27/leetcode_lowest_common_ancestor_of_a_binary_tree/"/>
    <url>/2015/07/27/leetcode_lowest_common_ancestor_of_a_binary_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p><pre><code class="hljs">         _______3______        /              \     ___5__          ___1__    /      \        /      \    6      _2       0       8          /  \          7   4</code></pre><p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p><p>The original problem is <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LowestCommonAncestorOfABinaryTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Lowest Common Ancestor of a Binary Tree*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;      if (root == NULL) return NULL;         if (root == p || root == q) return root;         TreeNode *L = lowestCommonAncestor(root-&gt;left, p, q);         TreeNode *R = lowestCommonAncestor(root-&gt;right, p, q);         if (L &amp;&amp; R) return root;         return L ? L : R;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, recursion is needed.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Validate Binary Search Tree</title>
    <link href="/2015/07/27/leetcode_validate_binary_search_tree/"/>
    <url>/2015/07/27/leetcode_validate_binary_search_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><ul><li><p>The left subtree of a node contains only nodes with keys less than the node’s key.</p></li><li><p>The right subtree of a node contains only nodes with keys greater than the node’s key.</p></li><li><p>Both the left and right subtrees must also be binary search trees.</p></li></ul><p>The original problem is <a href="https://leetcode.com/problems/validate-binary-search-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ValidateBinarySearchTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Validate Binary Search Tree  *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isValidBST(TreeNode* root) &#123;        if(root==NULL)            return true;        vector&lt;int&gt; nums;        stack&lt;TreeNode*&gt; myStack;        TreeNode *leftNode  = root-&gt;left;        TreeNode *rightNode = root-&gt;right;                if(rightNode != NULL)            myStack.push(rightNode);                root-&gt;left = root-&gt;right = NULL;        myStack.push(root);                if(leftNode != NULL)            myStack.push(leftNode);                while(!myStack.empty())&#123;            TreeNode * node = myStack.top();            myStack.pop();            leftNode  = node-&gt;left;            rightNode = node-&gt;right;            if(leftNode==NULL &amp;&amp; rightNode==NULL)&#123;                int size = nums.size();                if(size &gt;=1 &amp;&amp; nums[size-1] &gt;= node-&gt;val)                    return false;                else                    nums.push_back(node-&gt;val);            &#125;                            else&#123;                if(rightNode != NULL)                    myStack.push(rightNode);                                node-&gt;left = node-&gt;right = NULL;                myStack.push(node);                                if(leftNode != NULL)                    myStack.push(leftNode);            &#125;        &#125;        return true;        &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, travseral the tree inorder and save the value to the vector. If the new added value is smaller than the last one in the vector, then return false, else return true.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Rectangle Area</title>
    <link href="/2015/07/26/leetcode_rectangle_area/"/>
    <url>/2015/07/26/leetcode_rectangle_area/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Find the total area covered by two rectilinear rectangles in a 2D plane.</p><p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.</p><p>The original problem is <a href="https://leetcode.com/problems/rectangle-area/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RectangleArea.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Rectangle Area*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123;        double area1 = (C-A) * (D-B);        double area2 = (G-E) * (H-F);        double area3 = max(min((double)C,(double)G) - max((double)A,(double)E),0.0) * max(min((double)D,(double)H)-max((double)B,(double)F),0.0);                double area = area1 + area2 - area3;                return (int)area;    &#125;&#125;;int main()&#123;    Solution s;    int result = s.computeArea(-1500000001, 0, -1500000000, 1, 1500000000, 0, 1500000001, 1);    cout&lt;&lt;&quot;result=&quot;&lt;&lt;result&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we need compute the areas of rectangles and then minus the area of the intersection part. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Remove Duplicates From Sorted List2</title>
    <link href="/2015/07/26/leetcode_remove_duplicates_from_sorted_list2/"/>
    <url>/2015/07/26/leetcode_remove_duplicates_from_sorted_list2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p><p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.</p><p>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p><p>The original problem is <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RemoveDuplicatesFromSortedList2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Remove Duplicates from Sorted List II *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(head == NULL || head-&gt;next == NULL)            return head;        ListNode *node = head-&gt;next;        int headVal = head-&gt;val;        if(node != NULL &amp;&amp; node-&gt;val == headVal)&#123;            while(true)&#123;                while(node != NULL &amp;&amp; node-&gt;val == headVal)                    node = node-&gt;next;                                if(node == NULL)&#123;                    head = NULL;                    return head;                &#125;                head = node;                node = head-&gt;next;                headVal = head-&gt;val;                if(node==NULL || node-&gt;val != headVal)                    break;            &#125;        &#125;        if(head==NULL || head-&gt;next == NULL)            return head;        ListNode *lastNode = head, *currNode=head-&gt;next, *nextNode;                while(currNode != NULL)&#123;            nextNode = currNode-&gt;next;            int currVal = currNode-&gt;val;            if(nextNode!=NULL &amp;&amp; currVal == nextNode-&gt;val)&#123;                while(true)&#123;                    while(nextNode!=NULL &amp;&amp; currVal == nextNode-&gt;val)&#123;                        nextNode = nextNode-&gt;next;                    &#125;                                        currNode = nextNode;                    if(currNode == NULL)                        break;                    nextNode = currNode-&gt;next;                    currVal = currNode-&gt;val;                    if(nextNode==NULL || currVal != nextNode-&gt;val)                        break;                &#125;                lastNode-&gt;next = currNode;                lastNode = currNode;                if(currNode != NULL)                    currNode = currNode-&gt;next;            &#125;            else&#123;                                lastNode = currNode;                currNode = currNode-&gt;next;            &#125;        &#125;        return head;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, just remove all the duplicates. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Roman To Integer</title>
    <link href="/2015/07/26/leetcode_roman_to_integer/"/>
    <url>/2015/07/26/leetcode_roman_to_integer/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a roman numeral, convert it to an integer.</p><p>Input is guaranteed to be within the range from 1 to 3999.</p><p>The original problem is <a href="https://leetcode.com/problems/roman-to-integer/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RomanToInteger.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Roman to Integer *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int romanToInt(string s) &#123;        int len = s.size();        if(len&lt;=0)            return 0;        char roman[] = &#123;&#39;I&#39;,&#39;V&#39;,&#39;X&#39;,&#39;L&#39;,&#39;C&#39;,&#39;D&#39;,&#39;M&#39;&#125;;        int  myInt[] = &#123;1,5,10,50,100,500,1000&#125;;        map&lt;char, int&gt; romanMap;        for(int i=0;i&lt;7;i++)            romanMap[roman[i]] = myInt[i];        int result = 0;        result += romanMap[s[0]];        char lastCh = s[0];        for(int i=1;i&lt;len;i++)&#123;            if(romanMap[lastCh] &lt; romanMap[s[i]])&#123;                result = result - 2*romanMap[lastCh] + romanMap[s[i]];                lastCh = s[i];            &#125;            else&#123;                result = result + romanMap[s[i]];                lastCh = s[i];            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, first map all the roman to integer. If the integer of current roman is lager than the last roman, then add the integer to the result, else minus the 2*integer of the last roman, and plus the integer of current roman. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Longest Palindromic Substring</title>
    <link href="/2015/07/26/leetcode_longest_palindromic_substring/"/>
    <url>/2015/07/26/leetcode_longest_palindromic_substring/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p><p>The original problem is <a href="https://leetcode.com/problems/longest-palindromic-substring/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LongestPalindromicSubstring.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Longest Palindromic Substring *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    string longestPalindrome(string s) &#123;        int len = s.length();        if(len &lt;= 1)            return s;        string str;        int maxLen = 0;        bool p[1000][1000] = &#123;0&#125;;                for(int i=len-1;i&gt;=0;i--)&#123;            for(int j=i;j&lt;len;j++)&#123;                if(s[i] == s[j] &amp;&amp; (j-i&lt;=2 || p[i+1][j-1]))&#123;                    p[i][j] = true;                    int sublen = j - i +1;                    if(sublen &gt; maxLen)&#123;                        str = s.substr(i,sublen);                        maxLen = sublen;                    &#125;                &#125;                else                    p[i][j] = false;            &#125;        &#125;        return str;    &#125;&#125;;int main()&#123;    string str(&quot;aaabaaaa&quot;);    Solution s;    cout&lt;&lt;&quot;str=&quot;&lt;&lt;str&lt;&lt;endl;    //string new_str = s.inverse(str);    //cout&lt;&lt;&quot;new str=&quot;&lt;&lt;new_str&lt;&lt;endl;    //cout&lt;&lt;&quot;isPalindrome=&quot;&lt;&lt;s.isPalindrome(str);    string substr = s.longestPalindrome(str);    cout&lt;&lt;&quot;substr=&quot;&lt;&lt;substr&lt;&lt;endl;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, dynamic program is used. P[i][j] labels whether the substr(i,j) is palindrome or not.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode String To Integer</title>
    <link href="/2015/07/26/leetcode_string_to_integer/"/>
    <url>/2015/07/26/leetcode_string_to_integer/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Implement atoi to convert a string to an integer.</p><p>The original problem is <a href="https://leetcode.com/problems/string-to-integer-atoi/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/StringToInteger.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**String To Integer*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int myAtoi(string str) &#123;        double result = 0.0;        int flag = 1, work = 0;        int size = str.size(), i = 0;        while(str[i] == &#39; &#39;)            i++;        if(str[i] == &#39;-&#39;)&#123;            i ++;            flag = 0;        &#125;        else if(str[i] == &#39;+&#39;)        &#123;            i++;            flag = 1;        &#125;                for(;i&lt;size;i++)&#123;            if(str[i]&gt;=&#39;0&#39; &amp;&amp; str[i]&lt;=&#39;9&#39;)&#123;                result = result * 10 + (str[i] - &#39;0&#39;);                work = 1;            &#125;            else                break;        &#125;        if(work == 0)            return 0;        if(flag == 1 &amp;&amp; result  &gt;= INT_MAX)            return INT_MAX;        if(flag == 0 &amp;&amp; result &gt; INT_MAX)            return INT_MIN;                int myInt = (int) result;        if(flag == 0)            myInt = -1 * myInt;        return myInt;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, first discards as many whitespace characters as necessary until the first non-whitespace character is found.</p><p>When occur additional characters after those that form the integral number, stop the function, and return the current result. </p><p>If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 4 Sum</title>
    <link href="/2015/07/26/leetcode_4_sum/"/>
    <url>/2015/07/26/leetcode_4_sum/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p><p>Note:<br>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)<br>The solution set must not contain duplicate quadruplets.</p><pre><code class="hljs">For example, given array S = &#123;1 0 -1 0 -2 2&#125;, and target = 0.A solution set is:(-1,  0, 0, 1)(-2, -1, 1, 2)(-2,  0, 0, 2)</code></pre><p>The original problem is <a href="https://leetcode.com/problems/4sum/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/4Sum.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**4Sum*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;        int size = nums.size();        if(size &lt;= 3)            return result;        sort(nums.begin(),nums.end());        for(int i=0;i&lt;size-3;i++)        &#123;            if(i&gt;0 &amp;&amp; nums[i]==nums[i-1] )                continue;            for(int j=i+1;j&lt;size-2;j++)&#123;                if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1] )                    continue;                twoSum(nums, j+1, size-1, nums[i], nums[j], target);            &#125;        &#125;        return result;    &#125;    void twoSum(vector&lt;int&gt; &amp;nums, int start, int end, int num1, int num2, int target)&#123;        vector&lt;int&gt; oneSet;                while(start&lt;end)&#123;            if(nums[start]+nums[end] + num1 + num2 == target)&#123;                oneSet.push_back(num1);                oneSet.push_back(num2);                oneSet.push_back(nums[start]);                oneSet.push_back(nums[end]);                result.push_back(oneSet);                oneSet.clear();                while(start&lt;end &amp;&amp; nums[start]==nums[start+1]) start++;                while(start&lt;end &amp;&amp; nums[end]==nums[end-1]) end--;                start ++;                end --;            &#125;            else if(nums[start]+nums[end] + num1 + num2 &lt; target)                start ++;            else                end--;        &#125;        return ;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>For the problem, first sort the array. Then, for a number A in the array,  abd next number B, select two numbers(C and D) from the set after A and B, which A+B+C+D=target. When select C and D, we find them from the head and tail of the array.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 3 Sum Closest</title>
    <link href="/2015/07/25/leetcode_3_sum_closest/"/>
    <url>/2015/07/25/leetcode_3_sum_closest/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><pre><code class="hljs">For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</code></pre><p>The original problem is <a href="https://leetcode.com/problems/3sum-closest/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/3SumClosest.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**3Sum Closest*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int sumNum;    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;        int size = nums.size();        if(size&lt;=2)            return -1;        sort(nums.begin(),nums.end());        sumNum = nums[0] + nums[1] + nums[2];        for(int i=0;i&lt;size-2;i++)&#123;            if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])                continue;            twoSum(nums, i+1, size-1, nums[i], target);            if(sumNum == target)                return sumNum;        &#125;        return sumNum;    &#125;    void twoSum(vector&lt;int&gt; &amp;nums, int start, int end, int num, int target)&#123;        while(start&lt;end)&#123;            int oneSum = nums[start] + nums[end] + num;            if(oneSum == target)&#123;                sumNum = oneSum;                return;            &#125;            if( oneSum &lt; target )&#123;                if(abs(oneSum - target) &lt; abs(sumNum - target))                    sumNum = oneSum;                start ++;            &#125;            else            &#123;                if(abs(oneSum - target) &lt; abs(sumNum - target))                    sumNum = oneSum;                end --;            &#125;        &#125;        return ;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>The problem is similar to 3sum, first sort the array. Then, for a number A in the array, select two numbers(B and C) from the set after A, which A+B+C is closest to the target. When select B and C, we find them from the head and tail of the array.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 3 Sum</title>
    <link href="/2015/07/25/leetcode_3_sum/"/>
    <url>/2015/07/25/leetcode_3_sum/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:<br>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)<br>The solution set must not contain duplicate triplets.</p><pre><code class="hljs">For example, given array S = &#123;-1 0 1 2 -1 -4&#125;,A solution set is:(-1, 0, 1)(-1, -1, 2)</code></pre><p>The original problem is <a href="https://leetcode.com/problems/3sum/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/3Sum.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**3Sum*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        if(size &lt;= 2)            return result;        sort(nums.begin(),nums.end());        for(int i=0;i&lt;size-2;i++)        &#123;            if(i&gt;0 &amp;&amp; nums[i]==nums[i-1])                continue;            twoSum(nums, i+1,size-1, nums[i]);        &#125;        return result;    &#125;    void twoSum(vector&lt;int&gt; &amp;nums, int start, int end, int target)&#123;        vector&lt;int&gt; oneSet;                while(start&lt;end)&#123;            if(nums[start]+nums[end]+target == 0)&#123;                oneSet.push_back(target);                oneSet.push_back(nums[start]);                oneSet.push_back(nums[end]);                result.push_back(oneSet);                oneSet.clear();                while(start&lt;end &amp;&amp; nums[start]==nums[start+1]) start++;                while(start&lt;end &amp;&amp; nums[end]==nums[end-1]) end--;                start ++;                end --;            &#125;            else if(nums[start]+nums[end]+target &lt; 0)                start ++;            else                end--;        &#125;        return ;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>For the problem, first sort the array. Then, for a number A in the array, select two numbers(B and C) from the set after A, which A+B+C=0. When select B and C, we find them from the head and tail of the array.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Path Sum2</title>
    <link href="/2015/07/24/leetcode_path_sum2/"/>
    <url>/2015/07/24/leetcode_path_sum2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p>For example:<br>Given the below binary tree and sum = 22,</p><pre><code class="hljs">          5         / \        4   8       /   / \      11  13  4     /  \    / \    7    2  5   1</code></pre><p>return</p><pre><code class="hljs">[   [5,4,11,2],   [5,8,4,5]]</code></pre><p>The original problem is <a href="https://leetcode.com/problems/path-sum-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PathSum2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Path Sum II *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt; vector&lt;int&gt; &gt; pathSum(TreeNode* root, int sum) &#123;        if(root == NULL)            return result;        vector&lt;int&gt; onePath;        sumNum(root,onePath,0,sum);        return result;    &#125;    void sumNum(TreeNode * root, vector&lt;int&gt; onePath, int oneSum, int sum)&#123;        if(root == NULL)            return;        oneSum +=  root-&gt;val;        onePath.push_back(root-&gt;val);        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)&#123;            if(oneSum == sum)                result.push_back(onePath);            else                return;        &#125;        sumNum(root-&gt;left, onePath, oneSum, sum);        sumNum(root-&gt;right, onePath, oneSum, sum);    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>This problem is similar to “path sum”. In the solution, recursion is needed. During these steps, we need compute the sum of all the values in the path and save the values in a vector. If the sum of the path is equal to the given sum, we push the vector to the result.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Evaluate Reverse Polish Notation</title>
    <link href="/2015/07/24/leetcode_evaluate_reverse_polish_notation/"/>
    <url>/2015/07/24/leetcode_evaluate_reverse_polish_notation/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p><p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p><p>Some examples:</p><pre><code class="hljs">[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6</code></pre><p>The original problem is <a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/EvaluateReversePolishNotation.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Evaluate Reverse Polish Notation*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt; #include&lt;stack&gt;#include&lt;sstream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        int size = tokens.size();        stack&lt;string&gt; myStack;        stringstream ss;        for(int i=0;i&lt;size;i++)&#123;            if(tokens[i]==&quot;+&quot; || tokens[i]==&quot;-&quot; || tokens[i]==&quot;*&quot; || tokens[i]==&quot;/&quot;)&#123;                int num2;                ss&lt;&lt;myStack.top();                ss&gt;&gt;num2;                ss.clear();                myStack.pop();                int num1;                ss&lt;&lt;myStack.top();                ss&gt;&gt;num1;                ss.clear();                myStack.pop();                int num = 0;                if(tokens[i]==&quot;+&quot;)                    num = num1 + num2;                else if(tokens[i]==&quot;-&quot;)                    num = num1 - num2;                else if(tokens[i]==&quot;*&quot;)                    num = num1 * num2;                else                    num = num1 / num2;                string strNum;                ss&lt;&lt;num;                ss&gt;&gt;strNum;                ss.clear();                myStack.push(strNum);            &#125;            else                myStack.push(tokens[i]);        &#125;        int result;        ss&lt;&lt;myStack.top();        ss&gt;&gt;result;        ss.clear();        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we need a stack to save the string. If one string is operator, we compute the expression with the two nums in the top of the stack.<br>Finally, we can get one number, which is the final result.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Next Permutation</title>
    <link href="/2015/07/24/leetcode_next_permutation/"/>
    <url>/2015/07/24/leetcode_next_permutation/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be in-place, do not allocate extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p><p>The original problem is <a href="https://leetcode.com/problems/next-permutation/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/NextPermutation.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Next Permutation*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt; #include&lt;algorithm&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;        int size=nums.size();        if(size&lt;=1)            return;        int indexBegin=-1, indexLarge;         for(int i=size-1;i&gt;0;i--)&#123;            if(nums[i]&gt;nums[i-1])&#123;                indexBegin = i;                break;            &#125;            &#125;        if(indexBegin == -1)&#123;            sort(nums.begin(),nums.end());            return;        &#125;        int minNum = nums[indexBegin];        indexLarge = indexBegin;        for(int i=indexBegin;i&lt;size;i++)&#123;            if(nums[i]&gt;nums[indexBegin-1] &amp;&amp; nums[i]&lt;=minNum)&#123;                minNum = nums[i];                indexLarge = i;            &#125;        &#125;        int temp = nums[indexBegin-1];        nums[indexBegin-1] = nums[indexLarge];        nums[indexLarge] = temp;                sort(nums.begin()+indexBegin,nums.end());        return;    &#125;&#125;;//The code under below is used for testint main()&#123;    Solution s;    vector&lt;int&gt; nums;    nums.push_back(1);    nums.push_back(2);    nums.push_back(3);        s.nextPermutation(nums);    for(int i=0;i&lt;nums.size();i++)&#123;        cout&lt;&lt;nums[i]&lt;&lt;endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, first, find the first position which the nums[i] is larger than nums[i-1] from end to begin. Second, exchange the nums[i-1] with the number from the range from the position to the end, and the number is smallest but larger than nums[i-1]. Finally, sort the range from the position to the end.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Reverse Nodes In K Group</title>
    <link href="/2015/07/23/leetcode_reverse_nodes_in_k_group/"/>
    <url>/2015/07/23/leetcode_reverse_nodes_in_k_group/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>You may not alter the values in the nodes, only nodes itself may be changed.</p><p>Only constant memory is allowed.</p><p>For example,<br>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>The original problem is <a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ReverseNodesInKGroup.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Reverse Nodes in k-Group *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseKGroup(ListNode* head, int k) &#123;        if(head == NULL || head-&gt;next == NULL)            return head;        if(k &lt;= 1)            return head;                stack&lt;ListNode*&gt; myStack;        ListNode* node=NULL, *lastNode=NULL;        node = head;        int i = 0;        while(node != NULL)&#123;            myStack.push(node);            node = node-&gt;next;            i ++;            if(i%k == 0)&#123;                if(i==k)&#123;                    if(!myStack.empty())                        head = myStack.top();                    lastNode = head;                    myStack.pop();                &#125;                while(!myStack.empty())&#123;                    lastNode-&gt;next = myStack.top();                    myStack.pop();                    lastNode = lastNode-&gt;next;                    lastNode-&gt;next = NULL;                &#125;            &#125;        &#125;        if(lastNode == NULL)            return head;                while(!myStack.empty())&#123;            node = myStack.top();            myStack.pop();        &#125;        if(node!=NULL)            lastNode-&gt;next = node;                return head;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, stack is used to save each group of nodes and reverse the nodes. Finally, joint groups together to a new linked list.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Sliding Window Maximum</title>
    <link href="/2015/07/23/leetcode_sliding_window_maximum/"/>
    <url>/2015/07/23/leetcode_sliding_window_maximum/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p><p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p><pre><code class="hljs">Window position                Max---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7</code></pre><p>Therefore, return the max sliding window as [3,3,5,5,6,7].</p><p>The original problem is <a href="https://leetcode.com/problems/sliding-window-maximum/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SlidingWindowMaximum.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Sliding Window Maximum *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        int size = nums.size();        vector&lt;int&gt; result;        int maxNum;                if(size&lt;=0)            return result;        if(k==1)            return nums;                maxNum = maxArray(nums, 0, k-1);        result.push_back(maxNum);                for(int i=k;i&lt;size;i++)&#123;            maxNum = maxArray(nums, i-k+1, i);            result.push_back(maxNum);        &#125;        return result;    &#125;    int maxArray(vector&lt;int&gt;&amp; nums, int start, int end)&#123;        int maxNum = nums[start];        for(int i = start+1;i&lt;=end;i++)&#123;            if(nums[i] &gt; maxNum)                maxNum = nums[i];        &#125;        return maxNum;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, when sliding the window, get the maximum number.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Minimum Size Subarray Sum</title>
    <link href="/2015/07/23/leetcode_minimum_size_subarray_sum/"/>
    <url>/2015/07/23/leetcode_minimum_size_subarray_sum/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p><p>For example, given the array [2,3,1,2,4,3] and s = 7,<br>the subarray [4,3] has the minimal length under the problem constraint.</p><p>The original problem is <a href="https://leetcode.com/problems/minimum-size-subarray-sum/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MinimumSizeSubarraySum.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Minimum Size Subarray Sum *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        int begin=0;        if(size&lt;=0)            return 0;        int len = 1, minLen = size, totalNum = nums[0];        int i = 1;        while(totalNum &lt; s &amp;&amp; i &lt; size)&#123;            totalNum += nums[i];            i ++;            len ++;        &#125;        if(totalNum &lt; s)            return 0;        i--;        do&#123;            while(totalNum &gt; s)&#123;                totalNum -= nums[begin];                len --;                begin ++;            &#125;            if(totalNum &lt; s &amp;&amp; begin &gt;= 1)&#123;                begin --;                totalNum += nums[begin];                len ++;            &#125;            if(len &lt; minLen)                minLen = len;                            i++;            if(i&lt;size)&#123;                totalNum += nums[i];                len ++;            &#125;                    &#125;while(i&lt;size);                if(totalNum &lt; s)            return 0;        else            return minLen;    &#125;&#125;;// the code under below is used for testint main()&#123;    Solution s;    vector&lt;int&gt; nums;    nums.push_back(1);    nums.push_back(4);    nums.push_back(4);        int result = s.minSubArrayLen(4,nums);    cout&lt;&lt;&quot;result=&quot;&lt;&lt;result&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, two position indces are needed. Traversal the array from begin to end, after adding each number, we drop some elements from the begining of the subarray, in the same time the sum of the subarray is equal to or larger than the target. Then, we can get the minimum size of the subarray. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Longest Consecutive Sequence</title>
    <link href="/2015/07/23/leetcode_longest_consecutive_sequence/"/>
    <url>/2015/07/23/leetcode_longest_consecutive_sequence/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p><p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p><p>Your algorithm should run in O(n) complexity.</p><p>The original problem is <a href="https://leetcode.com/problems/longest-consecutive-sequence/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LongestConsecutiveSequence.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Longest Consecutive Sequence *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;        int longestNum = 0, num;        int size = nums.size();        if(size&lt;=0)               return longestNum;           if(size == 1)               return 1;        sort(nums.begin(),nums.end());                longestNum = 1;        num = 1;        for(int i=1;i&lt;size;i++)&#123;            if(nums[i]-nums[i-1] == 0)                ;            else if(nums[i]-nums[i-1] == 1)                num ++;            else                num = 1;            if(num &gt; longestNum)                longestNum = num;        &#125;        return longestNum;    &#125;&#125;;// the code under below is used for testint main()&#123;    Solution s;    vector&lt;int&gt; nums;    nums.push_back(0);    nums.push_back(-1);        int num = s.longestConsecutive(nums);    cout&lt;&lt;&quot;num=&quot;&lt;&lt;num&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>First, sort the vector. Then count the consecutive sequence, select the largest length. Note the equal number doesn’t contribute to the length.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Search A 2D Matrix 2</title>
    <link href="/2015/07/23/leetcode_search_a_2d_matrix2/"/>
    <url>/2015/07/23/leetcode_search_a_2d_matrix2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,</p><p>Consider the following matrix:</p><pre><code class="hljs">[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]</code></pre><p>Given target = 5, return true.</p><p>Given target = 20, return false.</p><p>The original problem is <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SearchA2DMatrix2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Search a 2D Matrix 2*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int rowSize = matrix.size();        if(rowSize &lt;= 0)            return false;        vector&lt;int&gt; oneRow = matrix[0];        int colSize = oneRow.size();        if(colSize&lt;=0)            return false;                int coli = 0, colj = colSize -1;        int maxCol;        while(coli&lt;=colj)&#123;            maxCol = colj;            int middle = (coli+colj)/2;            if(matrix[0][middle] == target)                return true;            else if(matrix[0][middle] &lt; target)                coli = middle + 1;            else                colj = middle - 1;        &#125;                for(int i=0;i&lt;=maxCol;i++)&#123;            if(matrix[0][i]==target)                return true;            else if(matrix[0][i]&lt;target)&#123;                int rowi=0, rowj=rowSize-1;                while(rowi&lt;=rowj)&#123;                    int middle = (rowi+rowj)/2;                    if(matrix[middle][i] == target)                        return true;                    else if(matrix[middle][i] &lt; target)                        rowi = middle + 1;                    else                        rowj = middle - 1;                &#125;            &#125;            else                break;        &#125;        return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>First, find all the columns which the first elements of the columns are less than or equal to the target. We use binary search to find them.</p><p>Second, for these columns, use binary search to find the target.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Add Binary</title>
    <link href="/2015/07/22/leetcode_add_binary/"/>
    <url>/2015/07/22/leetcode_add_binary/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two binary strings, return their sum (also a binary string).</p><p>For example,<br>a = “11”<br>b = “1”<br>Return “100”.</p><p>The original problem is <a href="https://leetcode.com/problems/add-binary/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/AddBinary.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Add Binary*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    string addBinary(string a, string b) &#123;        vector&lt;char&gt; result;        string str;        int sizeA = a.size();        int sizeB = b.size();        int countA = sizeA-1, countB = sizeB-1;         int Add = 0;                while(countA&gt;=0 &amp;&amp; countB&gt;=0)&#123;            int num = a[countA]-&#39;0&#39; + b[countB]-&#39;0&#39;;                        if(Add == 1)&#123;                num++;                Add = 0;             &#125;                        if(num==2)&#123;                Add = 1;                num = 0;            &#125;            else if(num==3)&#123;                Add = 1;                num = 1;            &#125;            result.push_back(num + &#39;0&#39;);            countA--;            countB--;        &#125;        while(countA&gt;=0)&#123;            int num = a[countA] - &#39;0&#39;;            if(Add == 1)&#123;                num++;                Add = 0;            &#125;            if(num == 2)&#123;                Add = 1;                num = 0;            &#125;            result.push_back(num + &#39;0&#39;);            countA--;        &#125;        while(countB&gt;=0)&#123;            int num = b[countB] - &#39;0&#39;;            if(Add == 1)&#123;                num++;                Add = 0;            &#125;            if(num == 2)&#123;                Add = 1;                num = 0;            &#125;            result.push_back(num + &#39;0&#39;);            countB--;        &#125;        if(Add == 1)            result.push_back(&#39;1&#39;);        for(int i=result.size()-1;i&gt;=0;i--)            str.push_back(result[i]);                return str;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, just add the two binary from end to begin. Don’t forget the carry bit. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Decode Ways</title>
    <link href="/2015/07/22/leetcode_decode_ways/"/>
    <url>/2015/07/22/leetcode_decode_ways/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p><pre><code class="hljs">&#39;A&#39; -&gt; 1&#39;B&#39; -&gt; 2...&#39;Z&#39; -&gt; 26</code></pre><p>Given an encoded message containing digits, determine the total number of ways to decode it.</p><p>For example,<br>Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p><p>The number of ways decoding “12” is 2.</p><p>The original problem is <a href="https://leetcode.com/problems/decode-ways/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/DecodeWays.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Decode Ways*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int numDecodings(string s) &#123;        int size = s.size();        vector&lt;int&gt; nums(size, 0);        if(size&lt;=0)            return 0;                if(s[0]==&#39;0&#39;)            return 0;        else            nums[0] = 1;                if(size==1)            return nums[size-1];                if(s[1]==&#39;0&#39;)&#123;            if(s[0] &lt;= &#39;2&#39;)                nums[1] = 1;            else                return 0;        &#125;        else&#123;            if(s[0] == &#39;1&#39;) nums[1] = 2;            if(s[0] == &#39;2&#39;)&#123;                if(s[1] &lt;= &#39;6&#39;)                     nums[1]=2;                else                    nums[1] = 1;            &#125;            if(s[0] &gt;= &#39;3&#39;) nums[1] = 1;        &#125;                for(int i=2;i&lt;size;i++)&#123;            if(s[i] == &#39;0&#39;)&#123;                nums[i] = nums[i-2];                if(s[i-1] &gt;= &#39;3&#39; || s[i-1] &lt;= &#39;0&#39;)                    return 0;            &#125;            else&#123;                if(s[i-1] == &#39;1&#39;)                    nums[i] = nums[i-1] + nums[i-2];                else if(s[i-1] == &#39;2&#39;) &#123;                    if(s[i] &lt;= &#39;6&#39;)                        nums[i] = nums[i-1] + nums[i-2];                    else                        nums[i] = nums[i-1];                &#125;                else&#123;                    nums[i] = nums[i-1];                &#125;            &#125;        &#125;        return nums[size-1];    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>For the problem, note the zeros. If the current char is ‘0’, we need to verify whether it is valid or not. A vecotr nums is used to save the decode ways from the begin to the current char. If the current char can be a valid letter itself and also can join with the last char, then the decode ways of the current is nums[i-1] + nums[i-2].   </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Median of Two Sorted Arrays</title>
    <link href="/2015/07/22/leetcode_median_of_two_sorted_arrays/"/>
    <url>/2015/07/22/leetcode_median_of_two_sorted_arrays/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>The original problem is <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MedianOfTwoSortedArrays.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Median of Two Sorted Arrays*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        vector&lt;int&gt; nums;        double result = 0;        int size1 = nums1.size(), size2 = nums2.size();        if(size1+size2 &lt;= 0)            return result;        int i=0, j=0;        while(i&lt;size1 &amp;&amp; j&lt;size2)&#123;            if(nums1[i] &lt;= nums2[j])&#123;                nums.push_back(nums1[i]);                i++;            &#125;            else&#123;                nums.push_back(nums2[j]);                j++;            &#125;        &#125;        while(i&lt;size1)&#123;            nums.push_back(nums1[i]);            i++;        &#125;        while(j&lt;size2)&#123;            nums.push_back(nums2[j]);            j++;        &#125;        if((size1+size2)%2 == 0)&#123;            int middle = (size1+size2)/2;            result = (nums[middle]+nums[middle-1])/2.0;        &#125;        else&#123;            int middle = (size1+size2)/2;            result = nums[middle];               &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I first merge the two arrays. Then find the median of the sorted array. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Search For A Range</title>
    <link href="/2015/07/21/leetcode_search_for_a_range/"/>
    <url>/2015/07/21/leetcode_search_for_a_range/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>If the target is not found in the array, return [-1, -1].</p><p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p><p>The original problem is <a href="https://leetcode.com/problems/search-for-a-range/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SearchForARange.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Search for a Range*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;int&gt; notfound, result;        notfound.push_back(-1);        notfound.push_back(-1);        result.push_back(0);        result.push_back(0);                int size = nums.size();        if(size &lt;= 0)            return notfound;        if(size == 1 &amp;&amp; nums[0] == target)            return result;                int begin=0, end= size-1, middle=0;        bool isfind = false;        int index = 0;        while(begin &lt;= end)&#123;            if(begin == end)&#123;                if(nums[begin] != target)                    return notfound;                else&#123;                    isfind = true;                    index = begin;                &#125;                    break;            &#125;            middle = (begin + end) / 2;            if(nums[middle] == target)&#123;                isfind = true;                index = middle;                break;            &#125;            else if(nums[middle] &lt; target)                begin = middle + 1;            else                end = middle - 1;        &#125;        if(isfind)&#123;            int i = index-1;                        while(i&gt;=0 &amp;&amp; nums[i]==target)                i--;                        begin = i+1;            i = index + 1;            while(i&lt;size &amp;&amp; nums[i]==target)                i++;            end = i - 1;                        result[0] = begin;            result[1] = end;            return result;        &#125;        else            return notfound;     &#125;&#125;;// the code under below is used for testint main()&#123;    Solution s;    vector&lt;int&gt; nums;    nums.push_back(1);    nums.push_back(3);        vector&lt;int&gt; result = s.searchRange(nums, 1);    for(int i=0;i&lt;result.size();i++)        cout&lt;&lt;result[i]&lt;&lt;endl;            system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, my algorithm’s runtime complexity must be in the order of O(log n). So, binary search is used. If we get the index of the target, we just need find the begin and tail of the range.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Partition List</title>
    <link href="/2015/07/21/leetcode_partition_list/"/>
    <url>/2015/07/21/leetcode_partition_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p><p>The original problem is <a href="https://leetcode.com/problems/partition-list/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PartitionList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Partition List *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* partition(ListNode* head, int x) &#123;        if(head == NULL)            return head;        queue&lt;ListNode*&gt; largeQueue, smallQueue;        ListNode * node = head;        while(node != NULL)&#123;            if(node-&gt;val &gt;= x)                largeQueue.push(node);            else                smallQueue.push(node);            node = node-&gt;next;        &#125;        head = NULL;        if(!smallQueue.empty())&#123;            head = smallQueue.front();            smallQueue.pop();             node = head;            while(!smallQueue.empty())&#123;                node-&gt;next = smallQueue.front();                node = node-&gt;next;                smallQueue.pop();            &#125;        &#125;        if(head == NULL)&#123;            head = largeQueue.front();            largeQueue.pop();            node = head;        &#125;        while(!largeQueue.empty())&#123;            node-&gt;next = largeQueue.front();            largeQueue.pop();            node = node-&gt;next;        &#125;        node-&gt;next = NULL;        return head;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, two queues are used. During traversal the list, put the node which is smaller than x to one queue, put the node which is larger or equal to x to the other queue. And to build the new list, the small node queue is at front, the large queue is at back.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Triangle</title>
    <link href="/2015/07/21/leetcode_triangle/"/>
    <url>/2015/07/21/leetcode_triangle/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><pre><code class="hljs">[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]</code></pre><p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p><p>The original problem is <a href="https://leetcode.com/problems/triangle/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Triangle.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Triangle *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int minimumTotal(vector&lt;vector&lt;int&gt; &gt;&amp; triangle) &#123;        vector&lt;vector&lt;int&gt; &gt; distance = triangle;        int rowSize = distance.size();        if(rowSize&lt;=0)            return 0;        if(rowSize == 1)            return distance[0][0];                for(int i=1;i&lt;rowSize;i++)&#123;            int colSize = i+1;            for(int j=0;j&lt;colSize;j++)&#123;                if(j==0)                    distance[i][j] += distance[i-1][0];                else if(j==colSize-1)                     distance[i][j] += distance[i-1][j-1];                else                    distance[i][j] += min(distance[i-1][j-1],distance[i-1][j]);            &#125;        &#125;        int minTotal = distance[rowSize-1][0];        int colSize = distance[rowSize-1].size();        for(int i=1;i&lt;colSize;i++)&#123;            if(distance[rowSize-1][i] &lt; minTotal)                minTotal = distance[rowSize-1][i];        &#125;        return minTotal;    &#125;&#125;;int main()&#123;    Solution s;    vector&lt;vector&lt;int&gt; &gt; triangle;    vector&lt;int&gt; oneRow;    oneRow.push_back(-1);    triangle.push_back(oneRow);    oneRow.clear();    oneRow.push_back(-2);    oneRow.push_back(-3);    triangle.push_back(oneRow);    int total = s.minimumTotal(triangle);    cout&lt;&lt;&quot;total=&quot;&lt;&lt;total&lt;&lt;endl;        system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, a vector distance which has the same size with the vector triangle is used to save the minimum path sum from the begin to the current. Finally, we just compute the minimum path sum of the last row in the vector.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Trapping Rain Water</title>
    <link href="/2015/07/21/leetcode_trapping_rain_water/"/>
    <url>/2015/07/21/leetcode_trapping_rain_water/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p><p>The original problem is <a href="https://leetcode.com/problems/trapping-rain-water/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/TrappingRainWater.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Trapping Rain Water *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int trap(vector&lt;int&gt;&amp; height) &#123;        int size = height.size();        if(size&lt;=1)             return 0;        int left=0, right=size-1;        int area = 0, secondH = 0;        while(left &lt; right)&#123;            if(height[left] &lt; height[right])&#123;                secondH = max(height[left], secondH);                area += secondH - height[left];                left ++;            &#125;            else&#123;                secondH = max(height[right],secondH);                area += secondH - height[right];                right --;            &#125;        &#125;        return area;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, reference to  <a href="http://www.xuebuyuan.com/1586534.html" title="Reference">here</a>.  We traversal the vector from head and tail to the middle. If the left height is less than the right one, we move the left one to right by one step, else we move the right one to left by one step. And each step, we compute the secondHeight and the added area by secondHeight - left height or right height.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Spiral Matrix 2</title>
    <link href="/2015/07/21/leetcode_spiral_matrix2/"/>
    <url>/2015/07/21/leetcode_spiral_matrix2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p><p>For example,<br>Given n = 3,</p><p>You should return the following matrix:<br>    [<br>     [ 1, 2, 3 ],<br>     [ 8, 9, 4 ],<br>     [ 7, 6, 5 ]<br>    ]</p><p>The original problem is <a href="https://leetcode.com/problems/spiral-matrix-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SpiralMatrix2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Spiral Matrix 2*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt; vector&lt;int&gt; &gt; generateMatrix(int n) &#123;        vector&lt; vector&lt;int&gt; &gt; matrix;        vector&lt;int&gt; oneRow;         if(n&lt;=0)            return matrix;        for(int i=0;i&lt;n;i++)            oneRow.push_back(0);        for(int i=0;i&lt;n;i++)            matrix.push_back(oneRow);                int rowBegin=0, rowEnd=n-1;        int colBegin=0, colEnd=n-1;        int num = 1;        while(rowBegin&lt;rowEnd &amp;&amp; colBegin&lt;colEnd)&#123;            for(int i=colBegin;i&lt;colEnd;i++)&#123;                matrix[rowBegin][i] = num++;                            &#125;                            for(int i=rowBegin;i&lt;rowEnd;i++)                matrix[i][colEnd] = num++;            for(int i=colEnd;i&gt;colBegin;i--)                matrix[rowEnd][i] = num++;            for(int i=rowEnd;i&gt;rowBegin;i--)                matrix[i][colBegin] = num++;            rowBegin ++; rowEnd --;            colBegin ++; colEnd --;        &#125;        if(rowBegin == rowEnd &amp;&amp; colBegin == colEnd)&#123;            matrix[rowBegin][colBegin] = num;        &#125;        return matrix;         &#125;&#125;;//The code under below is used for testint main()&#123;    Solution s;    int n=2;    vector&lt; vector&lt;int&gt; &gt; matrix = s.generateMatrix(n);    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;n;j++)            cout&lt;&lt;matrix[i][j]&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;    &#125;        system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, four anchors are needed: rowBegin, rowEnd, colBegin, colEnd. The order I add number to the matrix: rowBegin, colEnd, rowEnd, colBegin. In the end, only one row or one column is remained, then add the number to it.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Spiral Matrix</title>
    <link href="/2015/07/21/leetcode_spiral_matrix/"/>
    <url>/2015/07/21/leetcode_spiral_matrix/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p><p>For example,<br>Given the following matrix:</p><pre><code class="hljs">[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]</code></pre><p>You should return [1,2,3,6,9,8,7,4,5].</p><p>The original problem is <a href="https://leetcode.com/problems/spiral-matrix/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SpiralMatrix.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Spiral Matrix *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int rowBegin, rowEnd;        int colBegin, colEnd;        vector&lt;int&gt; result;        int rowSize = matrix.size();        if(rowSize&lt;=0)            return result;                    int colSize = matrix[0].size();        if(colSize&lt;=0)            return result;                rowBegin = 0; rowEnd = rowSize-1;        colBegin = 0; colEnd = colSize-1;        while(rowBegin&lt;rowEnd &amp;&amp; colBegin&lt;colEnd) &#123;            for(int i=colBegin;i&lt;colEnd;i++)                result.push_back(matrix[rowBegin][i]);            for(int i=rowBegin;i&lt;rowEnd;i++)                result.push_back(matrix[i][colEnd]);            for(int i=colEnd;i&gt;colBegin;i--)                result.push_back(matrix[rowEnd][i]);            for(int i=rowEnd;i&gt;rowBegin;i--)                result.push_back(matrix[i][colBegin]);            rowBegin ++; rowEnd --;            colBegin ++; colEnd --;        &#125;        if(rowBegin == rowEnd &amp;&amp; colBegin == colEnd)            result.push_back(matrix[rowBegin][colBegin]);        else&#123;            if(rowBegin == rowEnd)&#123;                for(int i=colBegin;i&lt;=colEnd;i++)                    result.push_back(matrix[rowBegin][i]);            &#125;            if(colBegin == colEnd)&#123;                for(int i=rowBegin;i&lt;=rowEnd;i++)                    result.push_back(matrix[i][colBegin]);            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, four anchors are needed: rowBegin, rowEnd, colBegin, colEnd. The order I traveral the matrix: rowBegin, colEnd, rowEnd, colBegin. In the end, only one row or one column is remained, then traversal it.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Reverse Linked List 2</title>
    <link href="/2015/07/20/leetcode_reverse_linked_list2/"/>
    <url>/2015/07/20/leetcode_reverse_linked_list2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p><p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p><p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p><p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p><p>The original problem is <a href="https://leetcode.com/problems/reverse-linked-list-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ReverseLinkedList2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Reverse Linked List II*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseBetween(ListNode* head, int m, int n) &#123;        if(head == NULL || head-&gt;next == NULL)            return head;        if(m&gt;n)            return NULL;        if(m==n)            return head;                ListNode * newHead;        ListNode * lastNode, *currNode, *nextNode, *node;        if(n&lt;=1)            return head;                node = head;        for(int i=1;i&lt;n;i++)&#123;            node = node-&gt;next;        &#125;        nextNode = node-&gt;next;                if(m==1)&#123;            newHead = reverseList(head, n-m+1);            head-&gt;next = nextNode;            return newHead;         &#125;        else&#123;            lastNode = head;            currNode = head-&gt;next;            for(int i=2;i&lt;m;i++)&#123;                lastNode = lastNode-&gt;next;                currNode = currNode-&gt;next;             &#125;            newHead = reverseList(currNode,n-m+1);            currNode-&gt;next = nextNode;            lastNode-&gt;next = newHead;        &#125;        return head;    &#125;    ListNode* reverseList(ListNode* head, int k)&#123;        stack&lt;ListNode*&gt; myStack;        ListNode* newHead, *node, *nextNode;        node = head;        myStack.push(node);        for(int i=1;i&lt;k;i++)&#123;            node = node-&gt;next;            myStack.push(node);        &#125;        newHead = node;        myStack.pop();        while(!myStack.empty())&#123;            nextNode = myStack.top();            myStack.pop();            node-&gt;next = nextNode;            node = node-&gt;next;        &#125;        return newHead;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, first, we need to get the head and tail of list need to reverse. Then, reverse the list(from m to n). Finally, join the new list to the original one.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Subsets2</title>
    <link href="/2015/07/20/leetcode_subsets2/"/>
    <url>/2015/07/20/leetcode_subsets2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets.</p><p>Note:<br>Elements in a subset must be in non-descending order.<br>The solution set must not contain duplicate subsets.<br>For example,<br>If nums = [1,2,2], a solution is:</p><pre><code class="hljs">[  [2],  [1],  [1,2,2],  [2,2],  [1,2],  []]</code></pre><p>The original problem is <a href="https://leetcode.com/problems/subsets-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Subsets2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Subsets 2*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:     vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums)&#123;        vector&lt;vector&lt;int&gt;&gt; result;        if(nums.size()&lt;=0)            return result;        sort(nums.begin(),nums.end());                vector&lt;int&gt; vec;        int lastSize = 0;        result.push_back(vec);        vec.push_back(nums[0]);        result.push_back(vec);        lastSize = 1;                for(int i=1;i&lt;nums.size();i++)&#123;            if(nums[i] != nums[i-1])&#123;                int resultSize = result.size();                lastSize = resultSize;                for(int j=0;j&lt;resultSize;j++)&#123;                    vector&lt;int&gt; vec = result[j];                    vec.push_back(nums[i]);                    sort(vec.begin(),vec.end());                    result.push_back(vec);                &#125;            &#125;            else&#123;                int resultSize = result.size();                for(int j=0;j&lt;lastSize;j++)&#123;                    vector&lt;int&gt; vec = result[resultSize - j - 1];                    vec.push_back(nums[i]);                    sort(vec.begin(),vec.end());                    result.push_back(vec);                &#125;            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I add one element of the nums to each vector of the result each iterator. If the current number is same to the last one, we just add the current number to the vectors which contain the last number(in other word, the vectors were add to result last iterator).</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Insertion Sort List</title>
    <link href="/2015/07/20/leetcode_insertion_sort_list/"/>
    <url>/2015/07/20/leetcode_insertion_sort_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Sort a linked list using insertion sort.</p><p>The original problem is <a href="https://leetcode.com/problems/insertion-sort-list/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/InsertionSortList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Insertion Sort List *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* insertionSortList(ListNode* head) &#123;        if(head == NULL || head-&gt;next == NULL)            return head;                int sortedNum = 1;        ListNode *currNode=head-&gt;next, *lastNode=head;        while(currNode != NULL)&#123;            if(currNode-&gt;val &lt; lastNode-&gt;val)&#123;                lastNode-&gt;next = currNode-&gt;next;                head = insertNode(head, currNode, sortedNum);            &#125;            else                lastNode = lastNode-&gt;next;                    currNode = lastNode-&gt;next;            sortedNum ++;        &#125;        return head;    &#125;    ListNode* insertNode(ListNode* head, ListNode* node, int k)&#123;        int val = node-&gt;val;        if(val &lt; head-&gt;val)&#123;            node-&gt;next = head;            head = node;            return head;         &#125;        ListNode* lastNode=head, *currNode=head-&gt;next;        for(int i=1;i&lt;k;i++)&#123;            if(val &lt; currNode-&gt;val)&#123;                node-&gt;next = currNode;                 lastNode-&gt;next = node;                return head;            &#125;            lastNode = lastNode-&gt;next;            currNode = currNode-&gt;next;        &#125;        return head;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, insertion sort is used. I traversal the list, if the current node is samller than the last one, then insert the node to the sorted list before the current node. The function  “insertNode()” is used for insert a node to the sorted list.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Subsets</title>
    <link href="/2015/07/20/leetcode_subsets/"/>
    <url>/2015/07/20/leetcode_subsets/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a set of distinct integers, nums, return all possible subsets.</p><p>Note:<br>Elements in a subset must be in non-descending order.<br>The solution set must not contain duplicate subsets.<br>For example,<br>If nums = [1,2,3], a solution is:</p><pre><code class="hljs">[  [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  []]</code></pre><p>The original problem is <a href="https://leetcode.com/problems/subsets/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Subsets.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Subsets *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        if(nums.size()&lt;=0)            return result;        vector&lt;int&gt; vec;        result.push_back(vec);        for(int i=0;i&lt;nums.size();i++)&#123;            int resultSize = result.size();            for(int j=0;j&lt;resultSize;j++)&#123;                vector&lt;int&gt; vec = result[j];                vec.push_back(nums[i]);                sort(vec.begin(),vec.end());                result.push_back(vec);            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I add one element of the nums to each vector of the result each iterator.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Combinations</title>
    <link href="/2015/07/20/leetcode_combinations/"/>
    <url>/2015/07/20/leetcode_combinations/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p>For example,<br>If n = 4 and k = 2, a solution is:</p><pre><code class="hljs">[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p>The original problem is <a href="https://leetcode.com/problems/combinations/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Combinations.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Combinations   *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;        if(k&lt;=0)            return result;        vector&lt;int&gt; nums;        vector&lt;int&gt; res;        for(int i=1;i&lt;=n;i++)            nums.push_back(i);        getCombine(nums,res,0,k);        return result;    &#125;    void getCombine(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; res, int start, int k)&#123;        if(k == 1)&#123;            for(int i=start;i&lt;nums.size();i++)&#123;                res.push_back(nums[i]);                result.push_back(res);                res.pop_back();            &#125;        &#125;        for(int i=start;i&lt;nums.size();i++)&#123;            res.push_back(nums[i]);            getCombine(nums,res,i+1,k-1);            res.pop_back();        &#125;    &#125;&#125;; </code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve this problem, recursion is needed. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Search A 2D Matrix</title>
    <link href="/2015/07/19/leetcode_search_a_2d_matrix/"/>
    <url>/2015/07/19/leetcode_search_a_2d_matrix/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><p>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.<br>For example,</p><p>Consider the following matrix:</p><pre><code class="hljs">[  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]</code></pre><p>Given target = 3, return true.</p><p>The original problem is <a href="https://leetcode.com/problems/search-a-2d-matrix/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SearchA2DMatrix.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Search a 2D Matrix  *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;        int rowSize = matrix.size();        if(rowSize &lt;= 0)            return false;        vector&lt;int&gt; oneRow = matrix[0];        int colSize = oneRow.size();        int rowTarget = -1;        for(int i=0;i&lt;rowSize;i++)&#123;            if(target &lt;= matrix[i][colSize-1])&#123;                rowTarget = i;                break;            &#125;        &#125;        if(rowTarget == -1)            return false;        for(int i=0;i&lt;colSize;i++)&#123;            if(target == matrix[rowTarget][i])&#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;    </code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>First, judge which row this target belongs to; and then traversal this row to judge whether the target is in this row or not.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Generate Parentheses</title>
    <link href="/2015/07/19/leetcode_generate_parentheses/"/>
    <url>/2015/07/19/leetcode_generate_parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p><p>“((()))”, “(()())”, “(())()”, “()(())”, “()()()”</p><p>The original problem is <a href="https://leetcode.com/problems/generate-parentheses/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/GenerateParentheses.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Generate Parentheses *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public:    vector&lt;string&gt; generateParenthesis(int n) &#123;          vector&lt;string&gt; result;          if(n&lt;=0)              return result;        string str=&quot;&quot;;        generate(result,str,n,n);        return result;    &#125;    void generate(vector&lt;string&gt;&amp; result,string str, int left, int right)&#123;        if(left == 0 &amp;&amp; right == 0)&#123;            result.push_back(str);        &#125;        string str1 = str;        if(left &gt; 0)&#123;            str.push_back(&#39;(&#39;);            generate(result,str,left-1,right);        &#125;        if(left &lt; right)&#123;            str1.push_back(&#39;)&#39;);            generate(result,str1,left,right-1);        &#125;        return;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve this problem,  recursion is need. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Product Of Array Except Self</title>
    <link href="/2015/07/17/leetcode_product_of_array_except_self/"/>
    <url>/2015/07/17/leetcode_product_of_array_except_self/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p><p>Solve it without division and in O(n).</p><p>For example, given [1,2,3,4], return [24,12,8,6].</p><p>The original problem is <a href="https://leetcode.com/problems/product-of-array-except-self/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ProductOfArrayExceptSelf.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Permutations *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; result;        int size = nums.size();        if(size &lt;= 1)&#123;            result.push_back(0);            return result;        &#125;        vector&lt;int&gt; product1, product2;                product1.push_back(nums[0]);        for(int i=1;i&lt;size;i++)&#123;            int product = nums[i] * product1[i-1];            product1.push_back(product);        &#125;                product2 = product1;        product2[size-1] = nums[size-1];        for(int i=size-2;i&gt;=0;i--)&#123;            int product = nums[i]  * product2[i+1];            product2[i] = product;        &#125;                        for(int i=0;i&lt;size;i++)&#123;            int product = 0;            if(i==0)                product = product2[i+1];            else if(i==size-1)                product = product1[i-1];            else                product = product1[i-1] * product2[i+1];                        result.push_back(product);        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>I need two extra array, one array to save the products of the current number and the numbers before it, the other one to save the products of the current number and the numbers afer it.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Permutations</title>
    <link href="/2015/07/17/leetcode_permutations/"/>
    <url>/2015/07/17/leetcode_permutations/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a collection of numbers, return all possible permutations.</p><p>For example,<br>[1,2,3] have the following permutations:</p><p>[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].</p><p>The original problem is <a href="https://leetcode.com/problems/permutations/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Permutations.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Permutations *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        if(nums.size() &lt;= 0)            return result;        findResult(nums, 0, result);        return result;    &#125;    void findResult(vector&lt;int&gt;&amp; nums, int i, vector&lt;vector&lt;int&gt;&gt; &amp;result)&#123;        int size = nums.size();        if(i == size-1)&#123;            result.push_back(nums);            return;        &#125;        for(int j=i;j&lt;nums.size();j++)&#123;            int temp = nums[i];            nums[i] = nums[j];            nums[j] = temp;                        findResult(nums, i+1, result);                        temp = nums[i];            nums[i] = nums[j];            nums[j] = temp;        &#125;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, recursion is needed.  And, we need replace the current number with the numbers after the current. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Delete Node In A Linked List</title>
    <link href="/2015/07/16/leetcode_delete_node_in_a_linked_list/"/>
    <url>/2015/07/16/leetcode_delete_node_in_a_linked_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p><p>The original problem is <a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" title="Problem">here</a>.<br>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/DeleteNodeInALinkedList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Delete Node in a Linked List*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std; /** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    void deleteNode(ListNode* node) &#123;        if(node-&gt;next == NULL)            return;        ListNode *nextNode = node-&gt;next;        node-&gt;val = nextNode-&gt;val;        node-&gt;next = nextNode-&gt;next;        return;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>I just copy the value of the next node to the current node, and remove the next node by jump it(set the next of the current node to the next of the next node). </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Lowest Common Ancestor of a Binary Search Tree</title>
    <link href="/2015/07/14/leetcode_lowest_common_ancestor_of_a_binary_search_tree/"/>
    <url>/2015/07/14/leetcode_lowest_common_ancestor_of_a_binary_search_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p><pre><code class="hljs">        _______6______       /              \    ___2__          ___8__   /      \        /      \   0      _4       7       9         /  \         3   5</code></pre><p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p><p>The original problem is <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LowestCommonAncestorOfABinarySearchTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Lowest Common Ancestor of a Binary Search Tree*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;math&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;        int pValue = p-&gt;val;        int qValue = q-&gt;val;        int rValue = root-&gt;val;        if(min(pValue,qValue)&lt;=rValue &amp;&amp; max(pValue,qValue)&gt;=rValue)            return root;        else if(min(pValue,qValue)&gt;=rValue)            return lowestCommonAncestor(root-&gt;right,p,q);        else if(max(pValue,qValue)&lt;=rValue)            return lowestCommonAncestor(root-&gt;left,p,q);    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Because the tree is binary search tree, for the two nodes, if one value is less than the root, the other is larger than the root, then the root is the result. If the two values are all smaller than the root, we go on to find the result from the left of the root. If the two values are all larger than the root, we go on to find the result from the right of the root. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Minimum Path Sum</title>
    <link href="/2015/07/14/leetcode_minimum_path_sum/"/>
    <url>/2015/07/14/leetcode_minimum_path_sum/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p><p>Note: You can only move either down or right at any point in time.</p><p>The original problem is <a href="https://leetcode.com/problems/minimum-path-sum/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MinimumPathSum.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Minimum Path Sum*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;math&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int rowSize = grid.size();        if(rowSize&lt;=0)            return 0;        vector&lt;int&gt; oneRow = grid[0];        int colSize = oneRow.size();                int **matrix = new int*[rowSize];        for(int i=0;i&lt;rowSize;i++)&#123;            matrix[i] = new int[colSize];            for(int j=0;j&lt;colSize;j++)                matrix[i][j] = 0;        &#125;        matrix[0][0] = grid[0][0];        for(int i=1;i&lt;colSize;i++)            matrix[0][i] = matrix[0][i-1] + grid[0][i];        for(int i=1;i&lt;rowSize;i++)            matrix[i][0] = matrix[i-1][0] + grid[i][0];                for(int i=1;i&lt;rowSize;i++)&#123;            for(int j=1;j&lt;colSize;j++)&#123;                matrix[i][j] = grid[i][j] + min(matrix[i-1][j],matrix[i][j-1]);            &#125;        &#125;        return matrix[rowSize-1][colSize-1];    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To get the minimum path, I use a matrix to record the sum of every step. For every step, always choose the minimum step(down or right). </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Gray Code</title>
    <link href="/2015/07/14/leetcode_gray_code/"/>
    <url>/2015/07/14/leetcode_gray_code/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p><p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p><p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:</p><pre><code class="hljs">00 - 001 - 111 - 310 - 2</code></pre><p>The original problem is <a href="https://leetcode.com/problems/gray-code/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/GrayCode.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Gray Code*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;math&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;int&gt; grayCode(int n) &#123;        vector&lt;int&gt; result;        if(n&lt;0)            return result;                result.push_back(0);        if(n==0)            return result;        result.push_back(1);        if(n==1)            return result;                for(int i=2;i&lt;=n;i++)&#123;            int size = result.size();            int addNum = pow(2,i-1);            for(int j=size-1;j&gt;=0;j--)&#123;                int num = result[j] + addNum;                result.push_back(num);            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>The Gray Code of n contains two parts: One part is the codes which add 0 to front of all codes of n-1; The other part is the codes which add 1 to front of all codes of n-1 in the reverse order. </p><p>For example, when n=2, the Grad code is </p><pre><code class="hljs">00 - 001 - 111 - 310 - 2</code></pre><p>So, when n=3, the Gray code is</p><pre><code class="hljs">000 - 0001 - 1011 - 3010 - 2110 - 6111 - 7101 - 5100 - 4</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Binary Search Tree Iterator</title>
    <link href="/2015/07/14/leetcode_binary_search_tree_iterator/"/>
    <url>/2015/07/14/leetcode_binary_search_tree_iterator/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p><p>Calling next() will return the next smallest number in the BST.</p><p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p><p>The original problem is <a href="https://leetcode.com/problems/binary-search-tree-iterator/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BinarySearchTreeIterator.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Binary Search Tree Iterator *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for binary tree * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;public:    int nextMin = 0;    stack&lt;TreeNode*&gt; myStack;    BSTIterator(TreeNode *root) &#123;        while(root!=NULL)&#123;            myStack.push(root);            root=root-&gt;left;        &#125;    &#125;    /** @return whether we have a next smallest number */    bool hasNext() &#123;        if(!myStack.empty())&#123;            TreeNode * node = myStack.top();            myStack.pop();            nextMin = node-&gt;val;                            node = node-&gt;right;            while(node)&#123;                myStack.push(node);                node=node-&gt;left;            &#125;                        return true;        &#125;        return false;    &#125;    /** @return the next smallest number */    int next() &#123;        return nextMin;    &#125;&#125;;/** * Your BSTIterator will be called like this: * BSTIterator i = BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); */</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To get the next smallest value in the binary tree, is similar to traversal the tree by in-order. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Flatten Binary Tree To Linked List</title>
    <link href="/2015/07/14/leetcode_flatten_binary_tree_to_linked_list/"/>
    <url>/2015/07/14/leetcode_flatten_binary_tree_to_linked_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example,<br>Given</p><pre><code class="hljs">     1    / \   2   5  / \   \ 3   4   6</code></pre><p>The flattened tree should look like:</p><pre><code class="hljs">   1    \     2      \       3        \         4          \           5            \             6</code></pre><p>The original problem is <a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/FlattenBinaryTreeToLinkedList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Flatten Binary Tree to Linked List *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    void flatten(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; myStack;        if(root==NULL)            return;        if(root-&gt;right!=NULL)            myStack.push(root-&gt;right);        if(root-&gt;left!=NULL)            myStack.push(root-&gt;left);        root-&gt;left = NULL;        root-&gt;right= NULL;         TreeNode * lastNode = root;        while(!myStack.empty())&#123;            TreeNode * node = myStack.top();            myStack.pop();            if(node-&gt;right!=NULL)                    myStack.push(node-&gt;right);            if(node-&gt;left!=NULL)                myStack.push(node-&gt;left);            node-&gt;left=NULL;            node-&gt;right=NULL;            lastNode-&gt;right=node;            lastNode-&gt;left =NULL;                        lastNode = lastNode-&gt;right;        &#125;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In order to flatten the binary tree, we need to traversal the tree by pre-order and put the all child nodes to right of the father node. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Binary Tree Zigzag Level Order Traversal</title>
    <link href="/2015/07/14/leetcode_binary_tree_zigzag_level_order_traversal/"/>
    <url>/2015/07/14/leetcode_binary_tree_zigzag_level_order_traversal/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p><pre><code class="hljs">    3   / \  9  20    /  \   15   7</code></pre><p>return its zigzag level order traversal as:</p><pre><code class="hljs">[  [3],  [20,9],  [15,7]]</code></pre><p>The original problem is <a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BinaryTreeZigzagLevelOrderTraversal.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Binary Tree Zigzag Level Order Traversal*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        vector&lt;TreeNode*&gt; currLevel, nextLevel;        if(root==NULL)            return result;        currLevel.push_back(root);        for(int count=0;currLevel.size()&gt;0;count++)&#123;            vector&lt;int&gt; vec;            for(int i=currLevel.size()-1;i&gt;=0;i--)&#123;                TreeNode * node = currLevel[i];                vec.push_back(node-&gt;val);                if(count%2==0)&#123;                    if(node-&gt;left)                        nextLevel.push_back(node-&gt;left);                    if(node-&gt;right)                        nextLevel.push_back(node-&gt;right);                &#125;                else&#123;                    if(node-&gt;right)                        nextLevel.push_back(node-&gt;right);                    if(node-&gt;left)                        nextLevel.push_back(node-&gt;left);                &#125;            &#125;            result.push_back(vec);            currLevel = nextLevel;            nextLevel.clear();        &#125;        return result;     &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>when traversal the binary tree, use a vector to save the current level nodes and use a vector to save the next level nodes. In order to traversal the tree by zigzag, if the level number can be modulus by 2, traversal the level nodes from left to right, else from right to left.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Convert Sorted List to Binary Search Tree</title>
    <link href="/2015/07/14/leetcode_convert_sorted_list_to_binary_search_tree/"/>
    <url>/2015/07/14/leetcode_convert_sorted_list_to_binary_search_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>The original problem is <a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ConvertSortedListToBinarySearchTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Convert Sorted List to Binary Search Tree*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* sortedListToBST(ListNode* head) &#123;        if(head == NULL)            return NULL;        TreeNode *root = new TreeNode(-1);        if(head-&gt;next == NULL)&#123;            root-&gt;val = head-&gt;val;            return root;        &#125;                    ListNode *before, *slow, *fast;        before=head;        slow = head;        fast = head;        while(fast-&gt;next!=NULL &amp;&amp; fast-&gt;next-&gt;next!=NULL)&#123;            if(slow != head)                before = before-&gt;next;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        &#125;        if(fast-&gt;next == NULL)&#123;            fast = slow;            before-&gt;next = NULL;        &#125;        else&#123;               fast = slow-&gt;next;            slow-&gt;next = NULL;        &#125;        root-&gt;val = fast-&gt;val;        root-&gt;left  = sortedListToBST(head);        if(fast-&gt;next != NULL)            root-&gt;right = sortedListToBST(fast-&gt;next);        else            root-&gt;right = NULL;                return root;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Because the array is sorted, so the middle of the list is the root of the tree(I use two pointer slow and fast to find the middle node of the list). Then the the left and right parts of the root contains the elements before and after the middle, respectively . Recursively, the binary search tree can be built. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Binary Tree Postorder Traversal</title>
    <link href="/2015/07/13/leetcode_binary_tree_postorder_traversal/"/>
    <url>/2015/07/13/leetcode_binary_tree_postorder_traversal/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p><p>For example:<br>Given binary tree {1,#,2,3},</p><pre><code class="hljs">   1    \     2    /   3</code></pre><p>return [3,2,1].</p><p>The original problem is <a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BinaryTreePostorderTraversal.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Binary Tree Postorder Traversal *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; vec;        stack&lt;TreeNode*&gt; myStack;        if(root==NULL)            return vec;           myStack.push(root);        while(!myStack.empty())&#123;            TreeNode *node = myStack.top();            myStack.pop();            TreeNode *left = node-&gt;left;            TreeNode *right = node-&gt;right;             if(left == NULL &amp;&amp; right == NULL)&#123;                vec.push_back(node-&gt;val);                &#125;            else&#123;                node-&gt;left = NULL;                node-&gt;right = NULL;                myStack.push(node);            &#125;            if(right!=NULL)                myStack.push(right);            if(left!=NULL)                myStack.push(left);        &#125;        return vec;       &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, a stack is used. The postorder traversal of the binary tree is left, right and root. So that the order in the stack is root, right and left.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Sort List</title>
    <link href="/2015/07/13/leetcode_sort_list/"/>
    <url>/2015/07/13/leetcode_sort_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Sort a linked list in O(n log n) time using constant space complexity.</p><p>The original problem is <a href="https://leetcode.com/problems/sort-list/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SortList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Sort List*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        if(head==NULL)            return head;        if(head-&gt;next==NULL)            return head;        ListNode *slow, *fast;        slow = head, fast = head;        while(fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL)&#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        &#125;        fast = slow-&gt;next;        slow-&gt;next = NULL;                ListNode *l1 = sortList(head);        ListNode *l2 = sortList(fast);        ListNode *l3 = mergeTwoLists(l1,l2);        return l3;    &#125;    ListNode* mergeTwoLists(ListNode *l1, ListNode *l2)&#123;        ListNode node(-1);        for(ListNode *p = &amp;node;l1!=NULL || l2!=NULL;p=p-&gt;next)&#123;            int val1 = l1 == NULL ? INT_MAX : l1-&gt;val;            int val2 = l2 == NULL ? INT_MAX : l2-&gt;val;            if(val1&lt;=val2)&#123;                p-&gt;next = l1;                l1 = l1-&gt;next;            &#125;            else&#123;                p-&gt;next = l2;                l2 = l2-&gt;next;            &#125;        &#125;        return node.next;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, use a low pointer and a fast pointer to divide the list to two sorted list from the middle. And then merge the two sorted lists into one sorted list. The sort list is a recursive function, until divide the list into only one node. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Kth Smallest Element In A BST</title>
    <link href="/2015/07/13/leetcode_kth_smallest_element_in_a_bst/"/>
    <url>/2015/07/13/leetcode_kth_smallest_element_in_a_bst/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p><p>The original problem is <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/KthSmallestElementInABST.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Kth Smallest Element in a BST *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    int kthSmallest(TreeNode* root, int k) &#123;        stack&lt;TreeNode*&gt; myStack;        vector&lt;int&gt; result;        if(root==NULL)            return 0;        myStack.push(root);                while(!myStack.empty())&#123;            TreeNode * node = myStack.top();            myStack.pop();            if(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL)                result.push_back(node-&gt;val);            else&#123;                if(node-&gt;right != NULL)                    myStack.push(node-&gt;right);                TreeNode *left = node-&gt;left;                node-&gt;left = NULL;                node-&gt;right = NULL;                myStack.push(node);                if(left != NULL)                    myStack.push(left);                                           &#125;            if(result.size()==k)                return result[k-1];        &#125;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I traversal the BST use a stack, and pop the stack from samll element to large. Finally, return the kth smallest element.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Unique Paths2</title>
    <link href="/2015/07/12/leetcode_unique_paths2/"/>
    <url>/2015/07/12/leetcode_unique_paths2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Follow up for “Unique Paths”:</p><p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p><p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p><pre><code class="hljs">[  [0,0,0],  [0,1,0],  [0,0,0]]</code></pre><p>The total number of unique paths is 2.</p><p>The original problem is <a href="https://leetcode.com/problems/unique-paths-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/UniquePaths2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Unique Paths 2*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;        int matrix[100][100];        int rowSize=obstacleGrid.size();        if(rowSize&lt;=0)            return 0;        vector&lt;int&gt;oneRow = obstacleGrid[0];        int colSize = oneRow.size();        if(obstacleGrid[0][0]==0)            matrix[0][0] = 1;        else            matrix[0][0] = 0;        for(int i=1;i&lt;colSize;i++)&#123;            if(obstacleGrid[0][i]==1)                matrix[0][i] = 0;            else                matrix[0][i] = matrix[0][i-1];        &#125;        for(int j=1;j&lt;rowSize;j++)&#123;            if(obstacleGrid[j][0]==1)                matrix[j][0] = 0;            else                matrix[j][0] = matrix[j-1][0];        &#125;                for(int i=1;i&lt;rowSize;i++)&#123;            for(int j=1;j&lt;colSize;j++)&#123;                if(obstacleGrid[i][j]==1)                    matrix[i][j] = 0;                else                    matrix[i][j] = matrix[i-1][j] + matrix[i][j-1];            &#125;        &#125;        return matrix[rowSize-1][colSize-1];    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Dynamic programming is used. The number of paths to get (i,j) in grid is equal to the sum of matrix(i,j-1) and matrix(i-1,j). However, if the grid(i,j) is equal to 1, set matrix(i,j) = 0.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Implement strStr</title>
    <link href="/2015/07/12/leetcode_implement_strstr/"/>
    <url>/2015/07/12/leetcode_implement_strstr/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The original problem is <a href="https://leetcode.com/problems/implement-strstr/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ImplementStrStr.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Implement strStr()  *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        int i, j;        for (i = j = 0; i &lt; haystack.size() &amp;&amp; j &lt; needle.size();) &#123;            if (haystack[i] == needle[j])&#123;                ++i; ++j;            &#125;            else&#123;                i -= j - 1; j = 0;            &#125;        &#125;        return j != needle.size() ? -1 : i - j;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Traversal the haystack, and find whether the substring is match to needle. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Set Matrix Zeros</title>
    <link href="/2015/07/12/leetcode_set_matrix_zeros/"/>
    <url>/2015/07/12/leetcode_set_matrix_zeros/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p><p>The original problem is <a href="https://leetcode.com/problems/set-matrix-zeroes/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SetMatrixZeroes.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Set Matrix Zeroes *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int rowSize = matrix.size();        if(rowSize&lt;=0)            return;        bool firstRow=false, firstCol=false;        vector&lt;int&gt; oneRow = matrix[0];        int colSize = oneRow.size();                for(int i=0;i&lt;colSize;i++)&#123;            if(matrix[0][i]==0)                firstRow = true;        &#125;        for(int i=0;i&lt;rowSize;i++)&#123;            if(matrix[i][0]==0)                firstCol = true;        &#125;                for(int i=1;i&lt;rowSize;i++)&#123;            for(int j=1;j&lt;colSize;j++)&#123;                if(matrix[i][j]==0)&#123;                    matrix[i][0]=0;                    matrix[0][j]=0;                &#125;            &#125;        &#125;        //Set rows to zeros        for(int i=1;i&lt;rowSize;i++)&#123;            if(matrix[i][0]==0)&#123;                for(int j=1;j&lt;colSize;j++)                    matrix[i][j] = 0;            &#125;        &#125;        //Set columns to zeros        for(int i=1;i&lt;colSize;i++)&#123;            if(matrix[0][i]==0)&#123;                for(int j=1;j&lt;rowSize;j++)                    matrix[j][i] = 0;            &#125;        &#125;        //Set first row to zeros        if(firstRow)&#123;            for(int i=0;i&lt;colSize;i++)                matrix[0][i]=0;        &#125;        //Set first column to zeros        if(firstCol)&#123;            for(int i=0;i&lt;rowSize;i++)                matrix[i][0] = 0;        &#125;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To save time, during traversal the matrix, if the element(i,j) is zero, set the (i,0) and (0,j) to zero. After traversal the matrix, we just check whether (i,0) and (0,j) are zero or not. If so, set the row or column to zeros. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Rotate Image</title>
    <link href="/2015/07/12/leetcode_rotate_image/"/>
    <url>/2015/07/12/leetcode_rotate_image/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>You are given an n x n 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><p>Follow up:<br>Could you do this in-place?</p><p>The original problem is <a href="https://leetcode.com/problems/rotate-image/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RotateImage.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Rotate Image*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        int size = matrix.size();        for(int i=0;i&lt;size/2;i++)&#123;                        for(int j=i;j&lt;size-i-1;j++)&#123;                int num = matrix[i][j];                matrix[i][j] = matrix[size-j-1][i];                matrix[size-j-1][i] = matrix[size-i-1][size-j-1];                matrix[size-i-1][size-j-1] = matrix[j][size-i-1];                matrix[j][size-i-1] = num;            &#125;        &#125;        return;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To rotate the image, I rotate the “circle” from outside to the center. For example, the first row, last row, first column and last column together to make up one circle. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Sort Colors</title>
    <link href="/2015/07/12/leetcode_sort_colors/"/>
    <url>/2015/07/12/leetcode_sort_colors/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p>The original problem is <a href="https://leetcode.com/problems/sort-colors/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SortColors.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Sort Colors *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    void sortColors(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()&lt;=0)            return;                int c0=0,c1=0,c2=0;        for(int i=0;i&lt;nums.size();i++)&#123;            if(nums[i]==0)                c0++;            else if(nums[i]==1)                c1++;            else if(nums[i]==2)                c2++;        &#125;        for(int i=0;i&lt;nums.size();i++)&#123;            if(i&lt;c0)                nums[i] = 0;            else if(i-c0&lt;c1)                nums[i] = 1;            else                nums[i] = 2;        &#125;        return;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Best Time to Buy and Sell Stock</title>
    <link href="/2015/07/12/leetcode_best_time_to_buy_and_sell_stock/"/>
    <url>/2015/07/12/leetcode_best_time_to_buy_and_sell_stock/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>The original problem is <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BestTimeToBuyAndSellStock.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Best Time to Buy and Sell Stock *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int size = prices.size();        if(size&lt;=0)            return 0;        int maxPro = 0, profit=0;        int start=0, end=0;        for(int i=1;i&lt;size;i++)&#123;            profit = prices[i] - prices[start];            if(maxPro &lt; profit)                maxPro = profit;             if(profit &lt;= 0)                start = i;        &#125;        return maxPro;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Traversal the prices, and compute the profit by prices[i]-prices[start], if the profit is larger than the max profit, then let modify the max profit. If the profit is less than zero, then modify the time when to buy.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Unique Paths</title>
    <link href="/2015/07/12/leetcode_unique_paths/"/>
    <url>/2015/07/12/leetcode_unique_paths/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><p>The original problem is <a href="https://leetcode.com/problems/unique-paths/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/UniquePaths.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Unique Paths *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int uniquePaths(int m, int n) &#123;        int matrix[100][100];        matrix[0][0] = 1;        for(int i=1;i&lt;n;i++)            matrix[0][i]=1;        for(int j=1;j&lt;m;j++)            matrix[j][0] = 1;        for(int i=1;i&lt;m;i++)&#123;            for(int j=1;j&lt;n;j++)&#123;                matrix[i][j] = matrix[i-1][j] + matrix[i][j-1];            &#125;        &#125;        return matrix[m-1][n-1];    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Dynamic programming is used. The number of paths to get (i,j) in grid is equal to the sum of  the result of (i,j-1) and (i-1,j).</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Convert Sorted Array to Binary Search Tree</title>
    <link href="/2015/07/12/leetcode_convert_sorted_array_to_binary_search_tree/"/>
    <url>/2015/07/12/leetcode_convert_sorted_array_to_binary_search_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>The original problem is <a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ConvertSortedArrayToBinarySearchTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Convert Sorted Array to Binary Search Tree*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()&lt;=0)            return NULL;        TreeNode* root;         root = convert(nums,0,nums.size()-1);        return root;    &#125;    TreeNode* convert(vector&lt;int&gt;&amp; nums, int low, int high)&#123;        TreeNode * node;        if(low&lt;high)&#123;            int midd = (low+high+1)/2;            node = new TreeNode(nums[midd]);            node-&gt;left = convert(nums,low,midd-1);            node-&gt;right = convert(nums,midd+1,high);                    &#125;        else if(low==high)&#123;            int midd = low;            node = new TreeNode(nums[midd]);            node-&gt;left  = NULL;            node-&gt;right = NULL;        &#125;        else            return NULL;        return node;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Because the array is sorted, so the middle of the array is the root of the tree. Then the the left and right parts of the root contains the elements before and after the middle, respectively . Recursively, the binary search tree can be built. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Unique Binary Search Trees</title>
    <link href="/2015/07/11/leetcode_unique_binary_search_trees/"/>
    <url>/2015/07/11/leetcode_unique_binary_search_trees/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p><p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p><p>   1         3     3      2      1<br>    \       /     /      / \      <br>     3     2     1      1   3      2<br>    /     /       \                 <br>   2     1         2                 3</p><p>The original problem is <a href="https://leetcode.com/problems/unique-binary-search-trees/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/UniqueBinarySearchTrees.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Unique Binary Search Trees*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;class Solution &#123;public:    int numTrees(int n) &#123;        vector&lt;int&gt; nums;         nums.push_back(1);        for(int i=1;i&lt;=n;i++)&#123;            nums.push_back(0);            if(i&lt;=2)                nums[i] = i;            else&#123;                for(int j=1;j&lt;=i;j++)&#123;                    nums[i] += nums[j-1]*nums[i-j];                &#125;            &#125;        &#125;        return nums[n];    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Dynamic programming is used. For n, the number of trees is the sum of all j-1 and n-j.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Implement Stack Using Queues</title>
    <link href="/2015/07/10/leetcode_implement_stack_using_queues/"/>
    <url>/2015/07/10/leetcode_implement_stack_using_queues/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>empty() – Return whether the stack is empty.</li></ul><p>The original problem is <a href="https://leetcode.com/problems/implement-stack-using-queues/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ImplementStackUsingQueues.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Implement Stack using Queues *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stdlib.h&gt;class Stack &#123;public:    queue&lt;int&gt; myQueue;    // Push element x onto stack.    void push(int x) &#123;        myQueue.push(x);    &#125;    // Removes the element on top of the stack.    void pop() &#123;        queue&lt;int&gt; queue2;        int num;        while(myQueue.size() &gt; 1)&#123;            num = myQueue.front();            myQueue.pop();            queue2.push(num);        &#125;        myQueue = queue2;    &#125;    // Get the top element.    int top() &#123;        return myQueue.back();    &#125;    // Return whether the stack is empty.    bool empty() &#123;        return myQueue.empty();    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>For the pop, we need pop all the data to a new queue except the final number. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Populating Next Right Pointers in Each Node</title>
    <link href="/2015/07/10/leetcode_populating_next_right_pointers_in_each_node/"/>
    <url>/2015/07/10/leetcode_populating_next_right_pointers_in_each_node/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree</p><pre><code class="hljs">struct TreeLinkNode &#123;  TreeLinkNode *left;  TreeLinkNode *right;  TreeLinkNode *next;&#125;</code></pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p><p>Initially, all next pointers are set to NULL.</p><p>For example,<br>Given the following perfect binary tree,<br>         1<br>       /  <br>      2    3<br>     / \  / <br>    4  5  6  7<br>After calling your function, the tree should look like:<br>         1 -&gt; NULL<br>       /  <br>      2 -&gt; 3 -&gt; NULL<br>     / \  / <br>    4-&gt;5-&gt;6-&gt;7 -&gt; NULL</p><p>The original problem is <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PopulatingNextRightPointersInEachNode.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Populating Next Right Pointers in Each Node *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; *  int val; *  TreeLinkNode *left, *right, *next; *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    void connect(TreeLinkNode *root) &#123;        if(root == NULL)            return;        vector&lt;TreeLinkNode*&gt; currLevel;        vector&lt;TreeLinkNode*&gt; nextLevel;        currLevel.push_back(root);        while(currLevel.size()&gt;0)&#123;            for(int i=0;i&lt;currLevel.size();i++)&#123;                TreeLinkNode * node = currLevel[i];                if(i+1&lt;currLevel.size())                    node-&gt;next = currLevel[i+1];                if(node-&gt;left != NULL)                    nextLevel.push_back(node-&gt;left);                if(node-&gt;right != NULL)                    nextLevel.push_back(node-&gt;right);            &#125;            currLevel = nextLevel;            nextLevel.clear();        &#125;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I use a vector to save the nodes of each level, and Populat next pointer of each node to point to its next right node.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Populating Next Right Pointers in Each Node 2</title>
    <link href="/2015/07/10/leetcode_populating_next_right_pointers_in_each_node2/"/>
    <url>/2015/07/10/leetcode_populating_next_right_pointers_in_each_node2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p><p>What if the given tree could be any binary tree? Would your previous solution still work?</p><p>Note:</p><p>You may only use constant extra space.<br>For example,<br>Given the following binary tree,</p><pre><code class="hljs">         1       /  \      2    3     / \    \    4   5    7</code></pre><p>After calling your function, the tree should look like:</p><pre><code class="hljs">     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \    \4-&gt; 5 -&gt; 7 -&gt; NULL</code></pre><p>The original problem is <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PopulatingNextRightPointersInEachNode2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Populating Next Right Pointers in Each Node *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; *  int val; *  TreeLinkNode *left, *right, *next; *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    void connect(TreeLinkNode *root) &#123;        if(root == NULL)            return;        vector&lt;TreeLinkNode*&gt; currLevel;        vector&lt;TreeLinkNode*&gt; nextLevel;        currLevel.push_back(root);        while(currLevel.size()&gt;0)&#123;            for(int i=0;i&lt;currLevel.size();i++)&#123;                TreeLinkNode * node = currLevel[i];                if(i+1&lt;currLevel.size())                    node-&gt;next = currLevel[i+1];                if(node-&gt;left != NULL)                    nextLevel.push_back(node-&gt;left);                if(node-&gt;right != NULL)                    nextLevel.push_back(node-&gt;right);            &#125;            currLevel = nextLevel;            nextLevel.clear();        &#125;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I use a vector to save the nodes of each level, and Populat next pointer of each node to point to its next right node.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Climbing Stairs</title>
    <link href="/2015/07/10/leetcode_climbing_stairs/"/>
    <url>/2015/07/10/leetcode_climbing_stairs/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>The original problem is <a href="https://leetcode.com/problems/climbing-stairs/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ClimbingStairs.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Climbing Stairs  *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int climbStairs(int n) &#123;                    vector&lt;int&gt; vec;        vec.push_back(1);        vec.push_back(1);        if(n&lt;=1)            return vec[n];        for(int i=2;i&lt;=n;i++)&#123;            int num = vec[i-1] + vec[i-2];            vec.push_back(num);        &#125;        return vec[n];    &#125;&#125;;//The code below is used for testint main()&#123;    int n = 44;    Solution s;    int result = s.climbStairs(n);    cout&lt;&lt;&quot;result=&quot;&lt;&lt;result&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I use a vector to save the result of every step, and the distinct ways of the i(th) step is the sum of the i-1 and i-2 steps. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Binary Tree Inorder Traversal</title>
    <link href="/2015/07/10/leetcode_binary_tree_inorder_traversal/"/>
    <url>/2015/07/10/leetcode_binary_tree_inorder_traversal/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p><p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    <br>     2<br>    /<br>   3<br>return [1,3,2].</p><p>The original problem is <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BinaryTreeInorderTraversal.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Binary Tree Inorder Traversal  *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        stack&lt;TreeNode*&gt; myStack;        vector&lt;int&gt; result;        if(root == NULL)            return result;        myStack.push(root);        while(!myStack.empty())&#123;            TreeNode * node = myStack.top();            myStack.pop();            if(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL)                result.push_back(node-&gt;val);            else&#123;                TreeNode * left = NULL;                if(node-&gt;right != NULL)&#123;                    myStack.push(node-&gt;right);                    node-&gt;right = NULL;                &#125;                if(node-&gt;left != NULL)&#123;                    left = node-&gt;left;                    node-&gt;left = NULL;                 &#125;                myStack.push(node);                if(left != NULL)                    myStack.push(left);            &#125;        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I use a stack to save the node of the tree. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Palindrome Linked List</title>
    <link href="/2015/07/10/leetcode_palindrome_linked_list/"/>
    <url>/2015/07/10/leetcode_palindrome_linked_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a singly linked list, determine if it is a palindrome.</p><p>The original problem is <a href="https://leetcode.com/problems/palindrome-linked-list/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PalindromeLinkedList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Palindrome Linked List   *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */  struct ListNode &#123;    int val;    ListNode *next;    ListNode(int x) : val(x), next(NULL) &#123;&#125; &#125;;class Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        if(head == NULL)             return true;        ListNode *list1 = head;        ListNode *list2 = new ListNode(head-&gt;val);                list2-&gt;next = NULL;        list1 = list1-&gt;next;        while(list1 != NULL)&#123;            int num = list1-&gt;val;            ListNode *node = new ListNode(num);            node-&gt;next = list2;            list2 = node;            list1 = list1-&gt;next;        &#125;        list1 = head;        while(list1 != NULL &amp;&amp; list2-&gt;next != NULL)&#123;            if(list1-&gt;val != list2-&gt;val)                return false;            list1 = list1-&gt;next;            list2 = list2-&gt;next;        &#125;        return true;    &#125;&#125;;//The code under below is used for testint main()&#123;    ListNode * head = new ListNode(1);    ListNode * node1 = new ListNode(2);    ListNode * node2 = new ListNode(0);    head-&gt;next = node1;    node1-&gt;next = node2;        Solution s;    bool isP = s.isPalindrome(head);    cout&lt;&lt;&quot;isP=&quot;&lt;&lt;isP&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;    &#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I first get the reverse linked list, and then compare whether the two lists is equal or not. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Implement Queue Using Stacks</title>
    <link href="/2015/07/09/leetcode_implement_queue_using_stacks/"/>
    <url>/2015/07/09/leetcode_implement_queue_using_stacks/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Implement the following operations of a queue using stacks.</p><ul><li>push(x) – Push element x to the back of queue.</li><li>pop() – Removes the element from in front of queue.</li><li>peek() – Get the front element.</li><li>empty() – Return whether the queue is empty.</li></ul><p>The original problem is <a href="https://leetcode.com/problems/implement-queue-using-stacks/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ImplementQueueUsingStacks.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Implement Queue using Stacks*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;class Queue &#123;public:    stack&lt;int&gt; stack1,stack2;    // Push element x to the back of queue.    void push(int x) &#123;        stack1.push(x);    &#125;    // Removes the element from in front of queue.    void pop(void) &#123;        if(!stack2.empty())            stack2.pop();        else&#123;            Stack1ToStack2();            stack2.pop();        &#125;    &#125;    // Get the front element.    int peek(void) &#123;        if(!stack2.empty())            return stack2.top();        else&#123;            Stack1ToStack2();            return stack2.top();        &#125;    &#125;    // Return whether the queue is empty.    bool empty(void) &#123;        if(stack1.empty()&amp;&amp;stack2.empty())            return true;        else            return false;    &#125;    void Stack1ToStack2()&#123;        if(!stack2.empty())            return;        while(!stack1.empty())&#123;            int num = stack1.top();            stack1.pop();            stack2.push(num);        &#125;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, two stacks are needed. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Pascal&#39;s Triangle2</title>
    <link href="/2015/07/09/leetcode_pascal_triangle2/"/>
    <url>/2015/07/09/leetcode_pascal_triangle2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an index k, return the kth row of the Pascal’s triangle.</p><p>For example, given k = 3,<br>Return [1,3,3,1].</p><p>The original problem is <a href="https://leetcode.com/problems/pascals-triangle-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Pascal'sTriangle2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Pascal&#39;s Triangle II *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;int&gt; getRow(int rowIndex) &#123;        vector&lt;int&gt; lastRow;        vector&lt;int&gt; row;        if(rowIndex &lt; 0)            return row;        lastRow.push_back(1);        if(rowIndex == 0)            return lastRow;                    for(int i=1;i&lt;=rowIndex;i++)&#123;            int num = 0;            row.push_back(1);            for(int j=1;j&lt;i;j++)&#123;                num = lastRow[j-1] + lastRow[j];                row.push_back(num);            &#125;            row.push_back(1);            lastRow = row;            row.clear();        &#125;        return lastRow;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>The number at index i of each row(except the begin and the end) is the sum of the numbers at index i-1 and i of the last row. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Best Time To Buy And Sell Stock 2</title>
    <link href="/2015/07/09/leetcode_best_time_to_buy_and_sell_stock2/"/>
    <url>/2015/07/09/leetcode_best_time_to_buy_and_sell_stock2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Say you have an array for which the i(th) element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p>The original problem is <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BestTimeToBuyAndSellStock2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Best Time to Buy and Sell Stock II*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;       if(prices.size()&lt;=0)           return 0;       int profit = 0;       for(int i=1;i&lt;prices.size();i++)&#123;               int diff = prices[i]-prices[i-1];               if(diff&gt;=0)                   profit += diff;       &#125;                          return profit;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I compute the difference between the current price and the last price. If the difference is non-negative, then add to the profit. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Maximum Subarray</title>
    <link href="/2015/07/09/leetcode_maximum_subarray/"/>
    <url>/2015/07/09/leetcode_maximum_subarray/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p><p>The original problem is <a href="https://leetcode.com/problems/maximum-subarray/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MaximumSubarray.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Maximum Subarray *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()&lt;=0)            return 0;        int maxSum=nums[0], sum=nums[0];        for(int i=1;i&lt;nums.size();i++)&#123;            if(sum &lt; 0)                sum = 0;            sum += nums[i];            maxSum = max(maxSum, sum);        &#125;        return maxSum;     &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, Jay Kadane’s algorithm is used. During traversal the array, we get the sum of the elements, if sum is less than zero, we set it to zero, and go on computing the sum. When a new element come, we also judge whether the sum is the maximum by now. Finally, we get the maximum of the sum. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Linked List Cycle2</title>
    <link href="/2015/07/09/leetcode_linked_list_cycle2/"/>
    <url>/2015/07/09/leetcode_linked_list_cycle2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The original problem is <a href="https://leetcode.com/problems/linked-list-cycle-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LinkedListCycle2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Linked List Cycle2*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;        map&lt;ListNode*,int&gt; myMap;        if(head == NULL)             return NULL;        if(head-&gt;next == NULL)            return NULL;        ListNode * node = head;        while(node!=NULL)&#123;            if(myMap.find(node)==myMap.end())                myMap[node] = 1;            else                return node;            node = node-&gt;next;        &#125;        return NULL;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, a hash(map in C++) is need to judge whether a node is unique in the list. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Linked List Cycle</title>
    <link href="/2015/07/09/leetcode_linked_list_cycle/"/>
    <url>/2015/07/09/leetcode_linked_list_cycle/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The original problem is <a href="https://leetcode.com/problems/linked-list-cycle/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LinkedListCycle.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Linked List Cycle*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        map&lt;ListNode*,int&gt; myMap;        if(head == NULL)             return false;        if(head-&gt;next == NULL)            return false;        ListNode * node = head;        while(node!=NULL)&#123;            if(myMap.find(node)==myMap.end())                myMap[node] = 1;            else                return true;            node = node-&gt;next;        &#125;        return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, a hash(map in C++) is need to judge whether a node is unique in the list. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Summary Ranges</title>
    <link href="/2015/07/09/leetcode_summary_ranges/"/>
    <url>/2015/07/09/leetcode_summary_ranges/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p><p>For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”].</p><p>The original problem is <a href="https://leetcode.com/problems/summary-ranges/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SummaryRanges.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Summary Ranges*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;string&gt; result;        string str,tempStr;        stringstream ss;        int size = nums.size();        if(nums.size()&lt;=0)            return result;        ss&lt;&lt;nums[0];        ss&gt;&gt;str;        ss.clear();        if(size == 1)&#123;            result.push_back(str);            return result;        &#125;        if(nums[1]-nums[0] != 1)&#123;            result.push_back(str);            str=&quot;&quot;;        &#125;        for(int i=1;i&lt;nums.size()-1;i++)&#123;            if(nums[i] - nums[i-1] != 1 &amp;&amp; nums[i+1]-nums[i] != 1)&#123;                ss&lt;&lt;nums[i];                ss&gt;&gt;str;                ss.clear();                result.push_back(str);                str = &quot;&quot;;            &#125;            else if(nums[i] - nums[i-1] == 1 &amp;&amp; nums[i+1]-nums[i] != 1)&#123;                str.push_back(&#39;-&#39;);                str.push_back(&#39;&gt;&#39;);                ss&lt;&lt;nums[i];                ss&gt;&gt;tempStr;                ss.clear();                str += tempStr;                result.push_back(str);                str = &quot;&quot;;            &#125;            else if(nums[i] - nums[i-1] != 1)&#123;                str = &quot;&quot;;                ss&lt;&lt;nums[i];                ss&gt;&gt;str;                ss.clear();            &#125;        &#125;        if(nums[size-1] - nums[size-2] == 1)&#123;            str.push_back(&#39;-&#39;);            str.push_back(&#39;&gt;&#39;);            ss&lt;&lt;nums[size-1];            ss&gt;&gt;tempStr;            ss.clear();            cout&lt;&lt;&quot;tempStr=&quot;&lt;&lt;tempStr&lt;&lt;endl;            str += tempStr;            result.push_back(str);        &#125;        else&#123;            str = &quot;&quot;;            ss&lt;&lt;nums[size-1];            ss&gt;&gt;str;            ss.clear();            result.push_back(str);        &#125;        return result;    &#125;&#125;;//the code below is used for testint main()&#123;    Solution s;    vector&lt;int&gt; nums;    vector&lt;string&gt; result;        nums.push_back(0);    nums.push_back(1);    result=s.summaryRanges(nums);    for(int i=0;i&lt;result.size();i++)&#123;        string str = result[i];        cout&lt;&lt;str&lt;&lt;endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we need to judge whether the value is 1 larger than the before. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Binary Tree Right Side View</title>
    <link href="/2015/07/09/leetcode_binary_tree_right_side_view/"/>
    <url>/2015/07/09/leetcode_binary_tree_right_side_view/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p>For example:<br>Given the following binary tree,<br>   1            &lt;—<br> /   <br>2     3         &lt;—<br> \     <br>  5     4       &lt;—<br>You should return [1, 3, 4].</p><p>The original problem is <a href="https://leetcode.com/problems/binary-tree-right-side-view/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BinaryTreeRightSideView.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Binary Tree Right Side View*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;        vector&lt;int&gt; value;        if(root == NULL)            return value;                vector&lt;TreeNode*&gt; oneLevel;        vector&lt;vector&lt;TreeNode*&gt;&gt; myTree;        TreeNode *node;        oneLevel.push_back(root);        myTree.push_back(oneLevel);        while(oneLevel.size()&gt;=1)&#123;            vector&lt;TreeNode*&gt; nextLevel;            for(int i=0;i&lt;oneLevel.size();i++)            &#123;                node = oneLevel[i];                if(node-&gt;left != NULL)                    nextLevel.push_back(node-&gt;left);                if(node-&gt;right != NULL)                    nextLevel.push_back(node-&gt;right);            &#125;            if(nextLevel.size()&gt;=1)                myTree.push_back(nextLevel);            oneLevel = nextLevel;        &#125;        for(int i=0;i&lt;myTree.size();i++)&#123;            vector&lt;TreeNode*&gt; level = myTree[i];            int size = level.size();            node = level[size-1];            value.push_back(node-&gt;val);        &#125;        return value;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we use breadth-first search to search the tree. We get the all values of final node in one level. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Remove Linked List Elements</title>
    <link href="/2015/07/09/leetcode_remove_linked_list_elements/"/>
    <url>/2015/07/09/leetcode_remove_linked_list_elements/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two binary trees, write a function to check if they are equal or not.</p><p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p><p>The original problem is <a href="https://leetcode.com/problems/remove-linked-list-elements/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RemoveLinkedListElements.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Remove Linked List Elements *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        while(head != NULL &amp;&amp; head-&gt;val == val)            head = head-&gt;next;                if(head == NULL)            return NULL;        ListNode *lastNode = head;        ListNode *currNode = head-&gt;next;        while(currNode != NULL) &#123;            if(currNode-&gt;val == val)&#123;                lastNode-&gt;next = currNode-&gt;next;                currNode = currNode-&gt;next;            &#125;            else&#123;                lastNode = lastNode-&gt;next;                currNode = currNode-&gt;next;            &#125;        &#125;        return head;            &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we traversal the list and remove the node whos value is equal to val. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Sqrt(x)</title>
    <link href="/2015/07/09/leetcode_sqrt_x/"/>
    <url>/2015/07/09/leetcode_sqrt_x/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two binary trees, write a function to check if they are equal or not.</p><p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p><p>The original problem is <a href="https://leetcode.com/problems/sqrtx/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Sqrt(x).cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Sqrt(x) *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int mySqrt(int x) &#123;        if(x &lt;= 0)            return -1;        if(x == 1)            return 1;                int low  = 1;        int high = x/2+1;        int mid;        while(low&lt;=high)&#123;            mid = (low+high)/2;                         if(mid &lt;= x/mid  &amp;&amp; (mid+1) &gt; x/(mid+1))                return mid;            else if(mid &gt; x/mid)                high -= 1;            else                low += 1;        &#125;        return -1;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, binary search is needed.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Pascal&#39;s Triangle</title>
    <link href="/2015/07/08/leetcode_pascal_triangle/"/>
    <url>/2015/07/08/leetcode_pascal_triangle/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given numRows, generate the first numRows of Pascal’s triangle.</p><p>For example, given numRows = 5,<br>Return</p><p>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p><p>The original problem is <a href="https://leetcode.com/problems/pascals-triangle/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Pascal'sTriangle.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Pascal&#39;s Triangle *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;        vector&lt;vector&lt;int&gt;&gt; result;        if(numRows &lt;= 0)            return result;        vector&lt;int&gt; oneRow;        oneRow.push_back(1);        result.push_back(oneRow);        if(numRows == 1)            return result;                    for(int i=1;i&lt;numRows;i++)&#123;            vector&lt;int&gt; row;            int num = 0;            row.push_back(1);            for(int j=1;j&lt;i;j++)&#123;                num = result[i-1][j-1] + result[i-1][j];                row.push_back(num);            &#125;            row.push_back(1);            result.push_back(row);        &#125;        return result;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h1><p>The number at index i of each row(except the begin and the end) is the sum of the numbers at index i-1 and i of the last row.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Find Minimum In Rotated Sorted Array</title>
    <link href="/2015/07/08/leetcode_find_minimum_in_rotated_sorted_array/"/>
    <url>/2015/07/08/leetcode_find_minimum_in_rotated_sorted_array/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.</p><p>The original problem is <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/FindMinimumInRotatedSortedArray.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/*Find Minimum in Rotated Sorted Array*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()==0)            return 0;        if(nums.size()==1)            return nums[0];        for(int i=1;i&lt;nums.size();i++)&#123;            if(nums[i-1]&gt;nums[i])                return nums[i];        &#125;        return nums[0];    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h1><p>Find the number which is smaller than the number before it.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Search Insert Position</title>
    <link href="/2015/07/07/leetcode_search_insert_position/"/>
    <url>/2015/07/07/leetcode_search_insert_position/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p>Here are few examples.<br>[1,3,5,6], 5 → 2<br>[1,3,5,6], 2 → 1<br>[1,3,5,6], 7 → 4<br>[1,3,5,6], 0 → 0</p><p>The original problem is <a href="https://leetcode.com/problems/search-insert-position/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SearchInsertPosition.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Search Insert Position*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;unordered_set&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;        if(nums.size()&lt;=0)            return 0;        int size = nums.size();        for(int i=0;i&lt;nums.size();i++)&#123;            if(target &lt;= nums[i])                return i;        &#125;        return size;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Just traversal the vector, and return the index of first number which is equal or larger than the target number.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Power Of Two</title>
    <link href="/2015/07/07/leetcode_power_of_two/"/>
    <url>/2015/07/07/leetcode_power_of_two/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an integer, write a function to determine if it is a power of two.</p><p>The original problem is <a href="https://leetcode.com/problems/power-of-two/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PowerOfTwo.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Power of Two*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;unordered_set&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool isPowerOfTwo(int n) &#123;        if(n&lt;=0)            return false;        if(n==1)            return true;        while(n&gt;2&amp;&amp;n%2==0)&#123;            if(n%2==0)                n=n/2;            else                return false;        &#125;                if(n%2==0)            return true;        else            return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>The input integer n must larger than zero. If n is equal to 1, return true.   </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Rotate List</title>
    <link href="/2015/07/02/leetcode_rotate_list/"/>
    <url>/2015/07/02/leetcode_rotate_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a list, rotate the list to the right by k places, where k is non-negative.</p><p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p><p>The original problem is <a href="https://leetcode.com/problems/rotate-list/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RotateList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Rotate List  *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* rotateRight(ListNode* head, int k) &#123;        if(head == NULL)            return head;        int nodeSize = 0;        vector&lt;ListNode*&gt; vec;        ListNode* node = head;                while(node!=NULL)&#123;            vec.push_back(node);            node=node-&gt;next;        &#125;        nodeSize = vec.size();        k = k % nodeSize;        if(k==0)            return head;                head = NULL;                for(int i=0;i&lt;k;++i)&#123;                node = vec[nodeSize-1-i];            if(i==0)                node-&gt;next = vec[0];            else                node-&gt;next = head;            head = node;        &#125;        node = vec[nodeSize-1-k];        node-&gt;next = NULL;        return head;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>If k is larger than the number of nodes, we need to modular k by the number of nodes. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Basic Calculator2</title>
    <link href="/2015/07/02/leetcode_basic_calculator2/"/>
    <url>/2015/07/02/leetcode_basic_calculator2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p><p>You may assume that the given expression is always valid.</p><p>Some examples:<br>“3+2*2” = 7<br>“ 3/2 “ = 1<br>“ 3+5 / 2 “ = 5</p><p>The original problem is <a href="https://leetcode.com/problems/basic-calculator-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BasicCalculator2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Basic Calculator2*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int calculate(string s) &#123;        if(s.length() &lt;= 0)            return 0;        s.push_back(&#39; &#39;);        vector&lt;int&gt;  myNumber;        vector&lt;char&gt; myOperator;        int num=0, sizeO=0, sizeN=0;        bool isNum = false;        for(int i=0;i&lt;s.length();i++)&#123;            cout&lt;&lt;&quot;s[&quot;&lt;&lt;i&lt;&lt;&quot;]=&quot;&lt;&lt;s[i]&lt;&lt;endl;            if(s[i]&gt;=&#39;0&#39; &amp;&amp; s[i]&lt;=&#39;9&#39;)&#123;                num = num * 10 + (s[i]-&#39;0&#39;);                isNum = true;            &#125;            else&#123;                if(isNum)&#123;                    isNum = false;                    sizeO = myOperator.size();                    sizeN = myNumber.size();                    if(sizeN == 0)&#123;                        myNumber.push_back(num);                    &#125;                    else&#123;                        cout&lt;&lt;&quot;sizeO=&quot;&lt;&lt;sizeO&lt;&lt;endl&lt;&lt;&quot;sizeN=&quot;&lt;&lt;sizeN&lt;&lt;endl;                        if(myOperator[sizeO-1] ==&#39;*&#39;)&#123;                            myNumber[sizeN-1]  *=  num;                            myOperator.pop_back();                        &#125;                        else if(myOperator[sizeO-1]==&#39;/&#39;)&#123;                            myNumber[sizeN-1]  /=  num;                            myOperator.pop_back();                        &#125;                        else&#123;                            myNumber.push_back(num);                        &#125;                    &#125;                    num = 0;                &#125;                if(s[i]==&#39;+&#39; || s[i]==&#39;-&#39; || s[i]==&#39;*&#39; || s[i]==&#39;/&#39;)&#123;                    cout&lt;&lt;&quot;!!s=&quot;&lt;&lt;s[i]&lt;&lt;endl;                    myOperator.push_back(s[i]);                &#125;                                &#125;        &#125;        if(myNumber.size()==0)            return 0;        if(myNumber.size()==1)            return myNumber[0];        int total = myNumber[0];        for(int i=1;i&lt;myNumber.size();i++)&#123;            if(myOperator[i-1]==&#39;+&#39;)                total += myNumber[i];            else if(myOperator[i-1]==&#39;-&#39;)                total -= myNumber[i];        &#125;        return total;    &#125;&#125;;//the code under below is used for testint main()&#123;    Solution s;    string str(&quot;2*3+4&quot;) ;    int num = s.calculate(str);    cout&lt;&lt;&quot;num=&quot;&lt;&lt;num&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>We should note the priority of the operators: ‘+’, ‘-‘, ‘*’, ‘/‘. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Count And Say</title>
    <link href="/2015/07/01/leetcode_count_and_say/"/>
    <url>/2015/07/01/leetcode_count_and_say/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The count-and-say sequence is the sequence of integers beginning as follows:<br>1, 11, 21, 1211, 111221, …</p><p>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.<br>Given an integer n, generate the nth sequence.</p><p>Note: The sequence of integers will be represented as a string.</p><p>The original problem is <a href="https://leetcode.com/problems/count-and-say/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/CountAndSay.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Count and Say *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    string countAndSay(int n) &#123;        if(n==0)            return &quot;&quot;;        if(n==1)            return &quot;1&quot;;        string str(&quot;1&quot;);        for(int i=1;i&lt;n;i++)&#123;            str = countNext(str);        &#125;        return str;    &#125;    string countNext(string str)&#123;        int count = 1;        char lastCh=str[0],countCh;        string newStr;        for(int i=1;i&lt;str.length();++i)&#123;            if(str[i]==lastCh)&#123;                count ++;            &#125;            else&#123;                countCh = &#39;0&#39;+count;                newStr.push_back(countCh);                newStr.push_back(lastCh);                lastCh = str[i];                count = 1;            &#125;        &#125;        countCh = &#39;0&#39;+count;        newStr.push_back(countCh);        newStr.push_back(lastCh);        return newStr;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Just count the continous same number in the string.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Reorder List</title>
    <link href="/2015/06/30/leetcode_reorder_list/"/>
    <url>/2015/06/30/leetcode_reorder_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>You must do this in-place without altering the nodes’ values.</p><p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p><p>The original problem is <a href="https://leetcode.com/problems/reorder-list/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ReorderList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Reorder List *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    void reorderList(ListNode* head) &#123;        if(head==NULL)            return;        if(head-&gt;next==NULL)            return;        ListNode* node;        vector&lt;ListNode*&gt; vec;        int totalNum = 0;        node = head-&gt;next;        while(node!=NULL)&#123;            vec.push_back(node);            node = node-&gt;next;        &#125;        int size = vec.size();        node = head;        for(int i=0;i&lt;size/2;i++)&#123;            node-&gt;next = vec[size-1-i];            node = node-&gt;next;            node-&gt;next = vec[i];            node = node-&gt;next;        &#125;        if(size%2!=0)&#123;            node-&gt;next = vec[size/2];            node = node-&gt;next;        &#125;        node-&gt;next=NULL;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, use a vector to save the list and reconstruct the list. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Binary Tree Level Order Traversal2</title>
    <link href="/2015/06/30/leetcode_binary_tree_level_order_traversal2/"/>
    <url>/2015/06/30/leetcode_binary_tree_level_order_traversal2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>return its bottom-up level order traversal as:<br>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]</p><p>The original problem is <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BinaryTreeLevelOrderTraversal2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Binary Tree Level Order Traversal*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;        vector&lt;int&gt; vec;        vector&lt;vector&lt;int&gt;&gt; res;        TreeNode* node;        vector&lt;TreeNode*&gt; currentLevel, nextLevel;        if(root==NULL)            return res;        if(root!=NULL)            currentLevel.push_back(root);        do&#123;            for(int i=0;i&lt;currentLevel.size();i++)&#123;                node = currentLevel[i];                vec.push_back(node-&gt;val);                if(node-&gt;left!=NULL)                    nextLevel.push_back(node-&gt;left);                if(node-&gt;right!=NULL)                    nextLevel.push_back(node-&gt;right);            &#125;            res.push_back(vec);            vec.clear();            currentLevel.clear();            currentLevel = nextLevel;            nextLevel.clear();        &#125;while(!currentLevel.empty());                int size = res.size()-1;        for(int i=0;i&lt;=size/2;i++)&#123;            vec = res[i];            res[i] = res[size-i];            res[size-i] = vec;        &#125;        return res;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>The problem is almost the same to the “Binary Tree Level Order Traversal”, just reverse the final result. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Binary Tree Level Order Traversal</title>
    <link href="/2015/06/30/leetcode_binary_tree_level_order_traversal/"/>
    <url>/2015/06/30/leetcode_binary_tree_level_order_traversal/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><p>The original problem is <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BinaryTreeLevelOrderTraversal.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Binary Tree Level Order Traversal*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;        vector&lt;int&gt; vec;        vector&lt;vector&lt;int&gt;&gt; res;        TreeNode* node;        vector&lt;TreeNode*&gt; currentLevel, nextLevel;        if(root==NULL)            return res;        if(root!=NULL)            currentLevel.push_back(root);        do&#123;            for(int i=0;i&lt;currentLevel.size();i++)&#123;                node = currentLevel[i];                vec.push_back(node-&gt;val);                if(node-&gt;left!=NULL)                    nextLevel.push_back(node-&gt;left);                if(node-&gt;right!=NULL)                    nextLevel.push_back(node-&gt;right);            &#125;            res.push_back(vec);            vec.clear();            currentLevel.clear();            currentLevel = nextLevel;            nextLevel.clear();        &#125;while(!currentLevel.empty());        return res;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, a vector is needed to save tree nodes at one level. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Binary Tree Preorder Traversal</title>
    <link href="/2015/06/29/leetcode_binary_tree_preorder_traversal/"/>
    <url>/2015/06/29/leetcode_binary_tree_preorder_traversal/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p><p>For example:<br>Given binary tree {1,#,2,3},<br>    1<br>    <br>     2<br>    /<br>    3<br>return [1,2,3].</p><p>The original problem is <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BinaryTreePreorderTraversal.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Binary Tree Preorder Traversal *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; vec;        stack&lt;TreeNode*&gt; myStack;        TreeNode * node;        if(root != NULL)            myStack.push(root);        while(!myStack.empty())&#123;            node = myStack.top();            vec.push_back(node-&gt;val);            myStack.pop();            if(node-&gt;right!=NULL)                myStack.push(node-&gt;right);            if(node-&gt;left!=NULL)            myStack.push(node-&gt;left);        &#125;        return vec;            &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>A stack is needed for traversal the tree iteratively.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Basic Calculator</title>
    <link href="/2015/06/28/leetcode_basic_calculator/"/>
    <url>/2015/06/28/leetcode_basic_calculator/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p><p>You may assume that the given expression is always valid.</p><p>Some examples:</p><pre><code class="hljs">&quot;1 + 1&quot; = 2&quot; 2-1 + 2 &quot; = 3&quot;(1+(4+5+2)-3)+(6+8)&quot; = 23</code></pre><p>The original problem is <a href="https://leetcode.com/problems/basic-calculator/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BasicCalculator.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Basic Calculator*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string.h&gt;#include&lt;sstream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int calculate(string s) &#123;        stack&lt;char&gt; myStack;        string substr=&quot;&quot;,totalStr;        int sign=1;        int num=0, total = 0;        for(int i=0;i&lt;s.length();i++)&#123;            if(s[i]==&#39;(&#39; || s[i]==&#39;+&#39; || s[i]==&#39;-&#39;)                myStack.push(s[i]);            else if(s[i]&gt;=&#39;0&#39; &amp;&amp; s[i]&lt;=&#39;9&#39;)&#123;                myStack.push(s[i]);            &#125;            else if(s[i]==&#39;)&#39;)&#123;                while(myStack.top() != &#39;(&#39;)&#123;                    substr.push_back(myStack.top());                    myStack.pop();                &#125;                myStack.pop();                totalStr = compute(substr);                //cout&lt;&lt;&quot;totalStr=&quot;&lt;&lt;totalStr&lt;&lt;endl;                                if(totalStr[0]==&#39;-&#39; &amp;&amp; !myStack.empty())&#123;                    if(myStack.top()==&#39;+&#39;)                        myStack.pop();                    if(myStack.top()==&#39;-&#39;)&#123;                        totalStr[0] = &#39;+&#39;;                        myStack.pop();                    &#125;                &#125;                for(int j=0;j&lt;totalStr.length();j++)&#123;                    myStack.push(totalStr[j]) ;                &#125;                substr=&quot;&quot;;            &#125;        &#125;        while(!myStack.empty())&#123;            substr.push_back(myStack.top());            myStack.pop();        &#125;        totalStr = compute(substr);        substr=&quot;&quot;;        total = atoi(totalStr.c_str()) ;        return total;    &#125;    string compute(string str)&#123;        string s,totalStr;        stringstream ss;        for(int i=str.length()-1;i&gt;=0;i--)&#123;            s.push_back(str[i]);        &#125;        int sign=1;        int num=0, total = 0;        for(int i=0;i&lt;s.length();i++)&#123;            if(s[i]&gt;=&#39;0&#39; &amp;&amp; s[i]&lt;=&#39;9&#39;)&#123;                num = num * 10 + (s[i]-&#39;0&#39;);            &#125;            else&#123;                total = total + sign * num;                num = 0;                if(s[i]== &#39;+&#39;)                    sign = 1;                    else if(s[i]==&#39;-&#39;)                    sign = -1;            &#125;        &#125;        total += sign * num;        ss&lt;&lt;total;        ss&gt;&gt;totalStr;        return totalStr;    &#125;&#125;;//The code under below is used for testint main()&#123;    string str(&quot;(5-(1+(5)))&quot;);    Solution s;    int result = s.calculate(str);    cout&lt;&lt;&quot;result=&quot;&lt;&lt;result&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, a stack is need to deal with the “(“ and “)”. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Valid Sudoku</title>
    <link href="/2015/06/28/leetcode_valid_sudoku/"/>
    <url>/2015/06/28/leetcode_valid_sudoku/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.</p><p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p><p><img src="/image/sudoku.png" alt="sudoku"></p><p>A partially filled sudoku which is valid.</p><p>The original problem is <a href="https://leetcode.com/problems/valid-sudoku/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ValidSudoku.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Valid Sudoku*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        for(int row=0;row&lt;board.size();row++)&#123;            if(!isValid(board,row,row,0,board[row].size()-1))                return false;        &#125;        for(int col=0;col&lt;board[0].size();col++)&#123;            if(!isValid(board,0,board.size()-1,col,col))                return false;        &#125;        for(int row=0;row&lt;board.size();row+=3)&#123;            for(int col=0;col&lt;board[0].size();col+=3)&#123;                if(!isValid(board,row,row+2,col,col+2))                    return false;            &#125;        &#125;        return true;    &#125;    bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int rowi, int rowj, int coli, int colj) &#123;        int index[10]=&#123;0&#125;;        int num;        for(int row=rowi;row&lt;=rowj;row++)&#123;            for(int col=coli;col&lt;=colj;col++)&#123;                if(board[row][col]!=&#39;.&#39;)&#123;                    num = board[row][col] - &#39;0&#39;;                    index[num] += 1;                    if(index[num] &gt; 1)                        return false;                &#125;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, just check whether each row(each column, each 3*3 area) has repeat digitals resoectively. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Gas Station</title>
    <link href="/2015/06/27/leetcode_gas_station/"/>
    <url>/2015/06/27/leetcode_gas_station/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p><p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p><p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p><p>The original problem is <a href="https://leetcode.com/problems/gas-station/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/GasStation.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Gas Station *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;public:    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;        int i = 0, j = 0;         while(i&lt;gas.size())&#123;            j = i;            if(isCircuit(gas,cost,&amp;j))&#123;                return i;            &#125;            else if(i==j)&#123;                i++;                            &#125;            else                i = j;        &#125;        return -1;    &#125;    bool isCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost,int *i)&#123;        int gasLeft = 0;        int count = *i;        do&#123;            gasLeft += gas[count] -cost[count];            if(gasLeft &lt; 0)&#123;                *i = count+1;                return false;            &#125;            count ++;            if(count == gas.size())                count = 0;        &#125;while(count != *i);                return true;    &#125;&#125;;//Method2: Time Limit Exceededclass Solution &#123;public:    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;        for(int i=0;i&lt;gas.size();++i)&#123;            if(isCircuit(gas,cost,i))                return i;        &#125;        return -1;    &#125;    bool isCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost,int i)&#123;        int gasLeft = 0;        int count = i;        do&#123;            gasLeft += gas[count] -cost[count];            if(gasLeft &lt; 0)                return false;            count ++;            if(count == gas.size())                count = 0;        &#125;while(count != i);        return true;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, the basic idea which tests every station as the begining is expand the time.  A good idea is that if start from i and end at j, because at j the gas is unenough, then we restart from j+1, and test wheather j+1 is right. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Number Of Islands</title>
    <link href="/2015/06/26/leetcode_number_of_islands/"/>
    <url>/2015/06/26/leetcode_number_of_islands/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p>Example 1:</p><p>11110</p><p>11010</p><p>11000</p><p>00000</p><p>Answer: 1</p><p>Example 2:</p><p>11000</p><p>11000</p><p>00100</p><p>00011</p><p>Answer: 3</p><p>The original problem is <a href="https://leetcode.com/problems/number-of-islands/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/NumberOfIslands.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Number of Islands*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int num = 0;        for(int i=0;i&lt;grid.size();++i)&#123;            for(int j=0;j&lt;grid[i].size();++j)&#123;                if(isIsland(grid,i,j))&#123;                    num ++;                &#125;            &#125;        &#125;        return num;    &#125;    bool isIsland(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)&#123;        if(i&gt;=0 &amp;&amp; i&lt;grid.size() &amp;&amp; j &gt;=0 &amp;&amp; j&lt;=grid[i].size() &amp;&amp; grid[i][j]==&#39;1&#39;)&#123;            grid[i][j]=&#39;_&#39;;            isIsland(grid,i-1,j);            isIsland(grid,i+1,j);            isIsland(grid,i,j-1);            isIsland(grid,i,j+1);            return true;        &#125;        return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, recursion is needed. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Reverse Words in a String</title>
    <link href="/2015/06/26/leetcode_reverse_words_in_a_string/"/>
    <url>/2015/06/26/leetcode_reverse_words_in_a_string/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an input string, reverse the string word by word.</p><p>For example,<br>Given s = “the sky is blue”,<br>return “blue is sky the”.</p><p>The original problem is <a href="https://leetcode.com/problems/reverse-words-in-a-string/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ReverseWordsInAString.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Reverse Words in a String*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    void reverseWords(string &amp;s) &#123;        s = filter(s);        if(s.length()&lt;=0)            return;                //cout&lt;&lt;&quot;s=&quot;&lt;&lt;s&lt;&lt;endl;        string substr, newstr;        int begin,end,sublen;        end = s.length() - 1;        for(int i=s.length()-1;i&gt;=0;i--)&#123;            if(s[i] == &#39; &#39;)&#123;                begin = i+1;                sublen = end - begin + 1;                end = i - 1;                substr=s.substr(begin,sublen);                strcat(newstr,substr);            &#125;        &#125;        substr=s.substr(0,end+1);        strcat(newstr,substr);        s = newstr;    &#125;    void strcat(string &amp;s, string str)&#123;        if(s.length() &gt; 0)&#123;            s.push_back(&#39; &#39;);        &#125;        for(int i=0;i&lt;str.length();++i)&#123;            s.push_back(str[i]);        &#125;    &#125;    //Remove the space at the begining, middle or end of the string    string filter(string s)&#123;        string str;        int begin = 0, end=s.length()-1;        while(begin &lt; s.length() &amp;&amp; s[begin] == &#39; &#39;)&#123;            begin ++;        &#125;        while(end &gt;=0 &amp;&amp; s[end] == &#39; &#39;)&#123;            end --;        &#125;        for(int count=begin;count&lt;=end;count++)&#123;            if(s[count]!= &#39; &#39;)                str.push_back(s[count]);            else if(s[count+1] != &#39; &#39;)                str.push_back(s[count]);        &#125;        return str;    &#125;&#125;;//The code under below is used for testint main()&#123;    string str(&quot; We are   friends &quot;);    Solution s;    s.reverseWords(str);    cout&lt;&lt;&quot;new str=&quot;&lt;&lt;str&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, first, we remove the space in the begining and end of the string, and the multiple spaces between two words. Then, we traverse the string from end to the begining, if we get a space, we know that it is separator of a word. Put all the words in a new string with space as the separator. Finally, we get the string with the reverse words. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Path Sum</title>
    <link href="/2015/06/26/leetcode_path_sum/"/>
    <url>/2015/06/26/leetcode_path_sum/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>For example:<br>Given the below binary tree and sum = 22,<br>              5<br>             / <br>            4   8<br>           /   / <br>          11  13  4<br>         /  \      <br>        7    2      1<br>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p><p>The original problem is <a href="https://leetcode.com/problems/path-sum/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PathSum.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/** Path Sum*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    bool hasPathSum(TreeNode* root, int sum) &#123;        if(root == NULL)            return false;        return     sumNum(root,0,sum);    &#125;    bool sumNum(TreeNode * root, int val,int sum)&#123;        if(root == NULL)            return false;            val = val + root-&gt;val;        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)&#123;            if(val == sum)                return true;            else                return false;        &#125;        return (sumNum(root-&gt;left,val,sum) || sumNum(root-&gt;right,val,sum));    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, recursion is needed. During these steps, we need compute the sum of all the values in the path.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Sum Root to Leaf Numbers</title>
    <link href="/2015/06/26/leetcode_sum_root_to_leaf_numbers/"/>
    <url>/2015/06/26/leetcode_sum_root_to_leaf_numbers/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p><p>Find the total sum of all root-to-leaf numbers.</p><p>For example,</p><p>   1<br>   / <br>  2   3</p><p>The root-to-leaf path 1-&gt;2 represents the number 12.<br>The root-to-leaf path 1-&gt;3 represents the number 13.<br>Return the sum = 12 + 13 = 25.</p><p>The original problem is <a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SumRootToLeafNumbers.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Maximum Depth of Binary Tree*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */struct TreeNode &#123;     int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; &#125;;class Solution &#123;public:    int sum;    int sumNumbers(TreeNode* root) &#123;        if(root == NULL)            return 0;        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)            return root-&gt;val;        sum = 0;        sumNum(root,0);        return sum;    &#125;    void sumNum(TreeNode * root, int num)&#123;        if(root == NULL)            return;        num = twoSum(num,root-&gt;val);        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)            sum += num;                if(root-&gt;left != NULL)            sumNum(root-&gt;left,num);        if(root-&gt;right != NULL)            sumNum(root-&gt;right,num);    &#125;    int twoSum(int a, int b) &#123;        int bNum = b, aNum = a;        if(bNum == 0)            aNum = aNum * 10;        while(bNum&gt;0)&#123;            aNum = aNum * 10;            aNum = aNum + bNum;            bNum = bNum / 10;        &#125;        return aNum;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, recursion is needed. Function twoSum is used for combine two numbers to a new one. When we visit to a leaf node, we can get the sum of one path. Finally, we can add all the sums, and get the result.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Maximum Depth of Binary Tree</title>
    <link href="/2015/06/26/leetcode_maximum_depth_of_binary_tree/"/>
    <url>/2015/06/26/leetcode_maximum_depth_of_binary_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p>The original problem is <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MaximumDepthOfBinaryTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Maximum Depth of Binary Tree*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if(root==NULL)            return 0;        if(root-&gt;left!=NULL &amp;&amp; root-&gt;right==NULL)            return 1+maxDepth(root-&gt;left);        if(root-&gt;left==NULL &amp;&amp; root-&gt;right!=NULL)            return 1+maxDepth(root-&gt;right);        return max(1+maxDepth(root-&gt;left),1+maxDepth(root-&gt;right));    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, recursion is needed.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Minimum Depth of Binary Tree</title>
    <link href="/2015/06/26/leetcode_minimum_depth_of_binary_tree/"/>
    <url>/2015/06/26/leetcode_minimum_depth_of_binary_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p>The original problem is <a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MinimumDepthOfBinaryTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Minimum Depth of Binary Tree*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ class Solution &#123;public:    int minDepth(TreeNode* root) &#123;        if(root==NULL)            return 0;        if(root-&gt;left!=NULL &amp;&amp; root-&gt;right==NULL)            return 1+minDepth(root-&gt;left);        if(root-&gt;left==NULL &amp;&amp; root-&gt;right!=NULL)            return 1+minDepth(root-&gt;right);                return min(1+minDepth(root-&gt;left),1+minDepth(root-&gt;right));    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, recursion is needed.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Kth Largest Element in an Array</title>
    <link href="/2015/06/25/leetcode_kth_largest_element_in_an_array/"/>
    <url>/2015/06/25/leetcode_kth_largest_element_in_an_array/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><p>The original problem is <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/KthLargestElementInAnArray.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Kth Largest Element in an Array *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int *KNum = new int[k];        int minNum,minIndex;        for(int i=0;i&lt;k;i++)&#123;            KNum[i] = nums[i];        &#125;        minIndex = minIndexOfNums(KNum,k);        minNum   = KNum[minIndex];        for(int i=k;i&lt;nums.size();i++)&#123;            if(nums[i]&gt;minNum)&#123;                KNum[minIndex] = nums[i];                minIndex = minIndexOfNums(KNum,k);                minNum   = KNum[minIndex];            &#125;        &#125;        return minNum;    &#125;    int minIndexOfNums(int *num, int k)&#123;        int min = num[0];        int index = 0;        for(int count=1;count&lt;k;count++)&#123;            if(num[count]&lt;min)&#123;                min = num[count];                index = count;            &#125;        &#125;        return index;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I create a array KNum to save the top k largest numbers. if any number in the input array nums is larger than the minimum in the KNum, then replace the number with the minimum. Repeate these steps, untils the end of the array. Finally, the minimum number of the KNum is what we wanted.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Isomorphic Strings</title>
    <link href="/2015/06/25/leetcode_isomorphic_strings/"/>
    <url>/2015/06/25/leetcode_isomorphic_strings/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two strings s and t, determine if they are isomorphic.</p><p>Two strings are isomorphic if the characters in s can be replaced to get t.</p><p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p><p>For example,<br>Given “egg”, “add”, return true.</p><p>Given “foo”, “bar”, return false.</p><p>Given “paper”, “title”, return true.</p><p>Note:<br>You may assume both s and t have the same length.</p><p>The original problem is <a href="https://leetcode.com/problems/isomorphic-strings/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/IsomorphicStrings.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Isomorphic Strings *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool isIsomorphic(string s, string t) &#123;        if(s == t)            return true;        map&lt;char,int&gt; mapS, mapT;        vector&lt;int&gt;   vectorS,vectorT;        int countS=0,countT=0;        for(int count=0;count&lt;s.length();++count)&#123;            if(mapS.find(s[count]) == mapS.end())&#123;                mapS[s[count]] = countS;                vectorS.push_back(countS);                countS ++;            &#125;            else&#123;                vectorS.push_back(mapS[s[count]]);            &#125;        &#125;        for(int count=0;count&lt;t.length();++count)&#123;            if(mapT.find(t[count]) == mapT.end())&#123;                mapT[t[count]] = countT;                vectorT.push_back(countT);                countT ++;            &#125;            else&#123;                vectorT.push_back(mapT[t[count]]);            &#125;        &#125;                for(int count=0;count&lt;vectorS.size();++count)&#123;            //cout&lt;&lt;&quot;S=&quot;&lt;&lt;vectorS[count]&lt;&lt;&quot; &quot;&lt;&lt;&quot;T=&quot;&lt;&lt;vectorT[count]&lt;&lt;endl;            if(vectorS[count] != vectorT[count])                return false;        &#125;        return true;    &#125;&#125;;//The code under below is used for testint main()&#123;    Solution solution;    string s(&quot;ab&quot;), t(&quot;ac&quot;);    bool isIs = solution.isIsomorphic(s,t);    cout&lt;&lt;&quot;isIs=&quot;&lt;&lt;isIs&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I map the characters to intergers, and save the map in a hash(map in C++). The first character appears in the string is convert to 0, if the second character is not in the hash, then is convert to 1, else map to the intergers in the hash. Doing the upper steps, until to the end of the string. Then, we just compare the intergers sequences of the two strings, if they are the same, then return true, else return false.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Word Break</title>
    <link href="/2015/06/25/leetcode_word_break/"/>
    <url>/2015/06/25/leetcode_word_break/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p><p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p><p>Return true because “leetcode” can be segmented as “leet code”.</p><p>The original problem is <a href="https://leetcode.com/problems/word-break/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/WordBreak.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Word Break*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;unordered_set&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) &#123;        if(wordDict.find(s)!=wordDict.end())            return true;        vector&lt;int&gt; wordIndex;        int sublen = 0, subBegin = 0, subEnd = 0;        string substr;        wordIndex.push_back(-1);        for(int count=0;count&lt;s.length();++count)&#123;            for(int i=0;i&lt;wordIndex.size();i++)&#123;                subBegin = wordIndex[i]+1;                sublen = count - subBegin + 1;                substr = s.substr(subBegin,sublen);                if(wordDict.find(substr)!=wordDict.end())&#123;                    wordIndex.push_back(count);                    break;                &#125;            &#125;        &#125;        int len = wordIndex.size();        if(wordIndex[len-1] == s.length()-1)            return true;        else            return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I use a vector to save the index(i) of string, which means from begin to i, the substring can be segmented as one or more word in the dictionary. Traverse the string and judge if the substring from any index in the vector to the current index is in the dictionary. If so, put the current to the vector and go on until the end of the string.<br>Finally, if the index of the end of string is in the vector, we can say the string can be segmented successfully, else return false.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Contains Duplicate2</title>
    <link href="/2015/06/25/leetcode_contains_duplicate2/"/>
    <url>/2015/06/25/leetcode_contains_duplicate2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of integers and an integer k, find out whether there there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</p><p>The original problem is <a href="https://leetcode.com/problems/contains-duplicate-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ContainsDuplicate2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Contains Duplicate2*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;        if(nums.size()&lt;=1)            return false;        map&lt;int,int&gt; myMap;        map&lt;int,int&gt;::iterator mapIter;        for(int count=0;count&lt;nums.size();++count)&#123;            if(myMap.find(nums[count])==myMap.end())                myMap[nums[count]] = count;            else&#123;                if(count - myMap[nums[count]] &lt;= k)                    return true;                else                    myMap[nums[count]] = count;            &#125;                        &#125;        return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I use a hash(map in C++) to save the num and its index. If a new num is in the map, compute the difference of the index. If the difference is not larger than k, then return true. Finally, if not return true before, then return false.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Contains Duplicate</title>
    <link href="/2015/06/25/leetcode_contains_duplicate/"/>
    <url>/2015/06/25/leetcode_contains_duplicate/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><p>The original problem is <a href="https://leetcode.com/problems/contains-duplicate/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ContainsDuplicate.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Contains Duplicate*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()&lt;=1)            return false;        map&lt;int,int&gt; myMap;        map&lt;int,int&gt;::iterator mapIter;        for(int count=0;count&lt;nums.size();++count)&#123;            if(myMap.find(nums[count])==myMap.end())                myMap[nums[count]] = 1;            else&#123;                myMap[nums[count]] += 1;                return true;            &#125;                        &#125;        for(mapIter=myMap.begin();mapIter!=myMap.end();++mapIter)&#123;            if(mapIter-&gt;second &gt; 1)                return true;        &#125;        return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I use a hash(map in C++) to save the num and its count. If any count is bigger than 1, then return true, else return false.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Length Of Last Word</title>
    <link href="/2015/06/25/leetcode_length_of_last_word/"/>
    <url>/2015/06/25/leetcode_length_of_last_word/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p><p>If the last word does not exist, return 0.</p><p>Note: A word is defined as a character sequence consists of non-space characters only.</p><p>For example,<br>Given s = “Hello World”,<br>return 5.</p><p>The original problem is <a href="https://leetcode.com/problems/length-of-last-word/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LengthOfLastWord.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Length of Last Word*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int lengthOfLastWord(string s) &#123;        if(s==&quot; &quot; || s==&quot;&quot;)            return 0;        s = filter(s);        int spaceIndex=-1;        int len = s.length();        for(int count=0;count&lt;len-1;++count)&#123;            if(s[count] == &#39; &#39;)&#123;                spaceIndex = count;            &#125;        &#125;        if(spaceIndex == -1)            return len;        int wordLen = len - 1 - spaceIndex;        return wordLen;    &#125;    //Remove the space at the begining or end of the string    string filter(string s)&#123;        string str;        int begin = 0, end=s.length()-1;        while(s[begin] == &#39; &#39;)&#123;            begin ++;        &#125;        while(s[end] == &#39; &#39;)&#123;            end --;        &#125;         for(int count=begin;count&lt;=end;count++)&#123;                        str.push_back(s[count]);        &#125;        return str;    &#125;    &#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, first remove all the spaces at the begining or end of the string. Then, find the space which nearest to the end of the string. So, we can compute the length from the space to the end. If we don’t find the space, return the length of the string.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Happy Number</title>
    <link href="/2015/06/25/leetcode_happy_number/"/>
    <url>/2015/06/25/leetcode_happy_number/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Write an algorithm to determine if a number is “happy”.</p><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p>Example: 19 is a happy number</p><p>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p><p>The original problem is <a href="https://leetcode.com/problems/happy-number/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/HappyNumber.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Happy Number*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool isHappy(int n) &#123;        map&lt;int,int&gt; myMap;        myMap[n] = 1;        while(n!=1)&#123;            n = squareSum(n);            if(n == 1)                break;            if(myMap.find(n)==myMap.end())&#123;                myMap[n] = 1;            &#125;            else&#123;                return false;            &#125;        &#125;        return true;    &#125;    int squareSum(int n)&#123;        vector&lt;int&gt; vec;        int elem = 0, sum = 0;                while(n&gt;0)&#123;            elem = n % 10;            vec.push_back(elem);            n = n / 10;        &#125;        for(int count=0;count&lt;vec.size();++count)&#123;            sum += vec[count] * vec[count];        &#125;        return sum;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we should compute the square sum of each digits of the number. It is important that when to finish the procedure of computation of the square sum. I use a hash(map in C++) to save the sum computed before, and when a new sum come, if we can get it from the hash, then we know that a circle exists, and the number is not a happy number. However, if the sum is equal to 1, then it is a happy number. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Valid Palindrome</title>
    <link href="/2015/06/25/leetcode_valid_palindrome/"/>
    <url>/2015/06/25/leetcode_valid_palindrome/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>For example,<br>“A man, a plan, a canal: Panama” is a palindrome.<br>“race a car” is not a palindrome.</p><p>The original problem is <a href="https://leetcode.com/problems/valid-palindrome/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ValidPalindrome.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Valid Palindrome*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool isPalindrome(string s) &#123;        s = filter(s);        if(s.size() &lt;=1)            return true;        int len = s.length();        for(int count=0;count&lt;len/2;count++)&#123;            if(s[count] != s[len-count-1])                return false;        &#125;        return true;    &#125;        string filter(string s)&#123;        if(s == &quot;&quot;)            return s;        int len = s.length();        string str;        for(int count=0;count&lt;len;++count)&#123;            char  ch = s[count];            if(ch&gt;=&#39;A&#39;&amp;&amp;ch&lt;=&#39;Z&#39;)                str.push_back(ch+32);            else if((ch&gt;=&#39;a&#39;&amp;&amp;ch&lt;=&#39;z&#39;) || (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;))                str.push_back(ch);        &#125;        return str;    &#125;&#125;;//The codes under below is used for testint main()&#123;    string str(&quot;aa&quot;);    Solution s;    string filter_str = s.filter(str);    cout&lt;&lt;&quot;Filter=&quot;&lt;&lt;filter_str&lt;&lt;endl;    bool isP = s.isPalindrome(str);    cout&lt;&lt;&quot;isPalindrome=&quot;&lt;&lt;isP&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, first we should filter the string except alphanumeric characters. Then, we can compare the characters the two point of the string.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode House Robber</title>
    <link href="/2015/06/25/leetcode_house_robber/"/>
    <url>/2015/06/25/leetcode_house_robber/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.<br>The original problem is <a href="https://leetcode.com/problems/house-robber/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/HouseRobber.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**House Robber*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int rob(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt;::iterator iter=nums.begin();        if(nums.size() &lt;= 0)            return 0;        if(nums.size() == 1)            return *iter;                int size = nums.size();        int *money = new int[size];        //Dynamic programming        money[0] = nums[0];        money[1] = max(nums[0],nums[1]);        for(int count=2;count&lt;size;++count)&#123;            money[count] = max(money[count-1],money[count-2]+nums[count]);        &#125;        return money[size-1];    &#125;&#125;;//The code under below is used for testint main()&#123;    Solution s;    vector&lt;int&gt; nums;    nums.push_back(1);    nums.push_back(12);    nums.push_back(3);        int maxMoney = s.rob(nums);    cout&lt;&lt;&quot;money=&quot;&lt;&lt;maxMoney&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, dynamic programming is used. Assume the robber get one house i, he just need to compute the maximum of the  nums[i-1] and (nums[i-2]+nums[i]) as the money[i], this will not alert police. In the end, the robber can get the maximum of money[end-1]; </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Majority Element</title>
    <link href="/2015/06/25/leetcode_majority_element/"/>
    <url>/2015/06/25/leetcode_majority_element/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><p>The original problem is <a href="https://leetcode.com/problems/majority-element/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MajorityElement.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Majority Element *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size() == 0)            return 0;        map&lt;int,int&gt; myMap;        map&lt;int,int&gt;::iterator mapIter;                vector&lt;int&gt;::iterator iter;        int n = 0;        for(iter=nums.begin();iter&lt;nums.end();++iter)&#123;            if(myMap.find(*iter) == myMap.end())                myMap[*iter] = 1;            else                myMap[*iter] += 1;                    &#125;        n = nums.size()/2;        int max = 0, maxCount = 0;        mapIter=myMap.begin();        max = mapIter-&gt;first;        maxCount = mapIter-&gt;second;         for(mapIter=myMap.begin();mapIter!=myMap.end();++mapIter) &#123;            if(mapIter-&gt;second &gt;= maxCount)&#123;                max = mapIter-&gt;first;                maxCount = mapIter-&gt;second;            &#125;        &#125;        return max;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, I use a hash(map in C++) to save the num and its count. Then, the num with maximum count is the result.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Merge Two Sorted Lists</title>
    <link href="/2015/06/25/leetcode_merge_two_sorted_lists/"/>
    <url>/2015/06/25/leetcode_merge_two_sorted_lists/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p>The original problem is <a href="https://leetcode.com/problems/merge-two-sorted-lists/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MergeTwoSortedLists.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Merge Two Sorted Lists*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if(l1 == NULL &amp;&amp; l2 != NULL)            return l2;        if(l1 != NULL &amp;&amp; l2 == NULL)            return l1;        if(l1 == NULL &amp;&amp; l2 == NULL)            return NULL;                ListNode *head, *list;        if(l1-&gt;val &lt; l2-&gt;val)&#123;            head = l1;            l1 = l1-&gt;next;            &#125;        else&#123;            head = l2;            l2 = l2-&gt;next;        &#125;        list = head;        while(l1!=NULL &amp;&amp; l2!=NULL)&#123;            if(l1-&gt;val &lt; l2-&gt;val)&#123;                list-&gt;next = l1;                list = list-&gt;next;                l1 = l1-&gt;next;            &#125;            else&#123;                list-&gt;next = l2;                list = list-&gt;next;                l2 = l2-&gt;next;            &#125;        &#125;        if(l1 != NULL)            list-&gt;next = l1;        if(l2 != NULL)            list-&gt;next = l2;                return head;            &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, merge sort algorithm is need.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Valid Parentheses</title>
    <link href="/2015/06/24/leetcode_valid_parentheses/"/>
    <url>/2015/06/24/leetcode_valid_parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p><p>The original problem is <a href="https://leetcode.com/problems/valid-parentheses/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ValidParentheses.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Valid Parentheses *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool isValid(string s) &#123;        if(s.size() &lt;= 0)            return true;        if(s.size() == 1)            return false;        stack&lt;char&gt; myStack;        for(int count=0;count&lt;s.size();++count)&#123;            if(myStack.empty())                myStack.push(s.at(count));            else&#123;                if(abs(s.at(count) - myStack.top()) &lt;= 2 &amp;&amp; abs(s.at(count) - myStack.top()) &gt; 0)                    myStack.pop();                else                    myStack.push(s.at(count));            &#125;        &#125;        if(myStack.empty())            return true;        else            return false;    &#125;&#125;;//The code underblow is used for testint main()&#123;    Solution s;    string str(&quot;[(])&quot;);    bool isV = s.isValid(str);    cout&lt;&lt;&quot;isValid=&quot;&lt;&lt;isV&lt;&lt;endl;        system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, stack is need. We traverse the string, if it is match to the top, then pop the stack, otherwise push the char to stack. After we finish the string, if the stack is empty, we can say it is valid, otherwise invalid.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Container With Most Water</title>
    <link href="/2015/06/24/leetcode_container_with_most_water/"/>
    <url>/2015/06/24/leetcode_container_with_most_water/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of integers, every element appears three times except for one. Find that single one.</p><p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p>The original problem is <a href="https://leetcode.com/problems/container-with-most-water/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ContainerWithMostWater.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Container With Most Water*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int maxArea(vector&lt;int&gt;&amp; height) &#123;        if(height.size()&lt;=0)            return 0;        vector&lt;int&gt;::iterator iter1,iter2;        int count1,count2;        int maxNum = 0, num = 0;        iter1=height.begin();        count1=0;        iter2=height.end()-1;        count2=height.size()-1;        while(iter1&lt;iter2)&#123;            num = (count2 - count1) * minOfTwoNum(*iter1,*iter2) ;            if(num &gt; maxNum)                maxNum = num;            if(*iter1 &lt; *iter2)&#123;                iter1++;                count1++;            &#125;            else&#123;                iter2--;                count2--;                &#125;        &#125;        return maxNum;    &#125;    int minOfTwoNum(int x, int y)&#123;        if(x&lt;y)            return x;        else            return y;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In this solution, we use two pointers(left and right), also begin and end of the array. We move the left to right or the right to left at one step. If the number of left is smaller than the number of right, we move the left, else we move the right. Until the left is equal to right, we finish it.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Single Number2</title>
    <link href="/2015/06/24/leetcode_single_number2/"/>
    <url>/2015/06/24/leetcode_single_number2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of integers, every element appears three times except for one. Find that single one.</p><p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p>The original problem is <a href="https://leetcode.com/problems/single-number-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SingleNumber2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Single Number*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size() &lt;= 0)            return 0;        map&lt;int,int&gt; nums_map;        map&lt;int,int&gt;::iterator mapIter;        vector&lt;int&gt;::iterator iter;        for(iter=nums.begin();iter&lt;nums.end();++iter)&#123;            int num = *iter;            if(nums_map.find(num) == nums_map.end())                nums_map[num] = 1;            else                nums_map[num] += 1;        &#125;        for(mapIter=nums_map.begin();mapIter!=nums_map.end();++mapIter)&#123;            if(mapIter-&gt;second == 1)                return mapIter-&gt;first;        &#125;            &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In this solution, a hash is needed(map in C++ ). We traverse the array of numbers, and put each unique number and its frequence to the hash. Then, we can get the number whos frequence is one.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Single Number</title>
    <link href="/2015/06/24/leetcode_single_number/"/>
    <url>/2015/06/24/leetcode_single_number/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of integers, every element appears twice except for one. Find that single one.</p><p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p>The original problem is <a href="https://leetcode.com/problems/single-number/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SingleNumber.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Single Number*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size() &lt;= 0)            return 0;        map&lt;int,int&gt; nums_map;        map&lt;int,int&gt;::iterator mapIter;        vector&lt;int&gt;::iterator iter;        for(iter=nums.begin();iter&lt;nums.end();++iter)&#123;            int num = *iter;            if(nums_map.find(num) == nums_map.end())                nums_map[num] = 1;            else                nums_map[num] = 2;        &#125;        for(mapIter=nums_map.begin();mapIter!=nums_map.end();++mapIter)&#123;            if(mapIter-&gt;second == 1)                return mapIter-&gt;first;        &#125;            &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In this solution, a hash is needed(map in C++ ). We traverse the array of numbers, and put each unique number and its frequence to the hash. Then, we can get the number whos frequence is one.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Min Stack</title>
    <link href="/2015/06/24/leetcode_min_stack/"/>
    <url>/2015/06/24/leetcode_min_stack/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p>The original problem is <a href="https://leetcode.com/problems/min-stack/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MinStack.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Min Stack *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class MinStack &#123;public:    vector&lt;int&gt; stack;    vector&lt;int&gt; minStack;    vector&lt;int&gt;::iterator iter, minIter;    vector&lt;int&gt;::reverse_iterator reiter;    void push(int x) &#123;        stack.push_back(x);        if(minStack.size()&lt;1)            minStack.push_back(x);        else&#123;            reiter = minStack.rbegin();            if(x &lt;= *reiter)                minStack.push_back(x);        &#125;    &#125;    void pop() &#123;        if(stack.size() &lt; 1)            return ;         reiter = stack.rbegin();        int num = * reiter;        reiter = minStack.rbegin();        int minNum = *reiter;                stack.pop_back();        if(num == minNum)&#123;            minStack.pop_back();        &#125;    &#125;    int top() &#123;        reiter = stack.rbegin();        return *reiter;    &#125;    int getMin() &#123;        reiter = minStack.rbegin();        return *reiter;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>The operations of stack are easy but the getMin, we need create another stack to save the minimum value.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Reverse Linked List</title>
    <link href="/2015/06/23/leetcode_reverse_linked_list/"/>
    <url>/2015/06/23/leetcode_reverse_linked_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Reverse a singly linked list.</p><p>The original problem is <a href="https://leetcode.com/problems/reverse-linked-list/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ReverseLinkedList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Reverse Linked List *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if(head == NULL)             return NULL;        ListNode *newList=NULL;        ListNode *currentNode=head;        while(currentNode != NULL)        &#123;            int val = currentNode-&gt;val;            currentNode = currentNode-&gt;next;                        ListNode *newNode = new ListNode(val);            newNode-&gt;val  = val;            newNode-&gt;next = newList;            newList = newNode;        &#125;        return newList;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we traverse the list and create a new list which add elements at the begining of the new list.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Intersection of Two Linked Lists</title>
    <link href="/2015/06/22/leetcode_intersection_of_two_linked_lists/"/>
    <url>/2015/06/22/leetcode_intersection_of_two_linked_lists/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The original problem is <a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/IntersectionOfTwoLinkedLists.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Intersection of Two Linked Lists *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        ListNode *listA=headA, *listB=headB;        if(listA==NULL || listB==NULL)            return NULL;                int lenA=0,lenB=0;        lenA = lengthOfList(listA);        lenB = lengthOfList(listB);                while(lenA &gt; lenB)&#123;            listA = listA-&gt;next;            lenA --;        &#125;        while(lenB &gt; lenA)&#123;            listB = listB-&gt;next;            lenB --;        &#125;        while(listA!=NULL &amp;&amp; listB != NULL)&#123;            if(listA == listB)                return listA;            listA = listA-&gt;next;            listB = listB-&gt;next;        &#125;        return NULL;    &#125;    int lengthOfList(ListNode * head)&#123;        ListNode *list=head;        int len = 0;        while(list != NULL)        &#123;            len ++ ;            list = list-&gt;next;        &#125;        return len;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>The two linked lists have the same list in the end. So, I get the longer list of the two and skip the redundants at the begining. Then, the two lists have same length, we can traverse them and find the first same node. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Invert Binary Tree</title>
    <link href="/2015/06/22/leetcode_invert_binary_tree/"/>
    <url>/2015/06/22/leetcode_invert_binary_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>nvert a binary tree.</p><p>   4<br>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>to<br>   4<br>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p><p>The original problem is <a href="https://leetcode.com/problems/invert-binary-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/InvertBinaryTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Invert Binary Tree*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* invertTree(TreeNode* root) &#123;        TreeNode *temp;        if(root == NULL)            return root;        temp = root-&gt;left;        root-&gt;left  = root-&gt;right;        root-&gt;right = temp;                root-&gt;left  = invertTree(root-&gt;left);        root-&gt;right = invertTree(root-&gt;right);                return root;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In the solution, recursion is needed. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Symmetric Tree</title>
    <link href="/2015/06/22/leetcode_symmetric_tree/"/>
    <url>/2015/06/22/leetcode_symmetric_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p><p>For example, this binary tree is symmetric:</p><p>1<br>   /  <br>   2    2<br> / \   / <br>3  4   4  3<br>But the following is not:<br>    1<br>   / <br>  2   2<br>   \    <br>   3     3</p><p>The original problem is <a href="https://leetcode.com/problems/symmetric-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SymmetricTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Symmetric Tree*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isSymmetric(TreeNode* root) &#123;        if(root == NULL)            return true;        return isSym(root-&gt;left,root-&gt;right);    &#125;    bool isSym(TreeNode *p, TreeNode *q)&#123;        if(p==NULL &amp;&amp; q==NULL)            return true;         if(p==NULL &amp;&amp; q!= NULL)            return false;        if(p!=NULL &amp;&amp; q==NULL)            return false;        if(p-&gt;val != q-&gt;val)            return false;        if(isSym(p-&gt;left,q-&gt;right) &amp;&amp; isSym(p-&gt;right,q-&gt;left))&#123;            return true;        &#125;        return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>This problem is similar to <a href="https://leetcode.com/problems/same-tree/" title="Problem">Same Tree</a>. In the process, recursion is needed. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Plus One</title>
    <link href="/2015/06/21/leetcode_plus_one/"/>
    <url>/2015/06/21/leetcode_plus_one/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a non-negative number represented as an array of digits, plus one to the number.</p><p>The digits are stored such that the most significant digit is at the head of the list.</p><p>The original problem is <a href="https://leetcode.com/problems/plus-one/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PlusOne.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Plus One*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;math.h&gt; #include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;        vector&lt;int&gt; new_digits,temp_digits;        if(digits.size() &lt;= 0)&#123;            new_digits.push_back(1);            return new_digits;        &#125;        vector&lt;int&gt;::iterator iter;        vector&lt;int&gt;::reverse_iterator reiter;        int flag = 0;        for(reiter=digits.rbegin();reiter&lt;digits.rend();++reiter)&#123;            int num = 0;             if(reiter == digits.rbegin())                num = *reiter + 1;            else                                num = *reiter;            if(flag == 1)                num = num +1;                        if(num &gt; 9)&#123;                num  = 0;                flag = 1;            &#125;else&#123;                flag = 0;            &#125;            temp_digits.push_back(num);        &#125;        if(flag == 1)            temp_digits.push_back(1);                for(reiter=temp_digits.rbegin();reiter&lt;temp_digits.rend();++reiter)&#123;            new_digits.push_back(*reiter);        &#125;        return new_digits;    &#125;&#125;;// The codes below are used for testint main()&#123;    Solution s;    vector&lt;int&gt; digits;    digits.push_back(1);    digits.push_back(2);        digits.push_back(9);    vector&lt;int&gt; new_digits = s.plusOne(digits);    vector&lt;int&gt;::iterator iter= new_digits.begin();    for(;iter&lt;new_digits.end();++iter)&#123;        cout&lt;&lt;*iter&lt;&lt;endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the proble, I traverse the vector from end to begin and plus one to the element at end. If the element is larger than 10, we need a carry to the next element. Finally, we should reverse the vector.   </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Same Tree</title>
    <link href="/2015/06/21/leetcode_same_tree/"/>
    <url>/2015/06/21/leetcode_same_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two binary trees, write a function to check if they are equal or not.</p><p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p><p>The original problem is <a href="https://leetcode.com/problems/same-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SameTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Same Tree*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        if(p==NULL &amp;&amp; q!=NULL)            return false;        if(p!=NULL &amp;&amp; q==NULL)            return false;        if(p == NULL &amp;&amp; q == NULL)            return true;        if(p-&gt;val != q-&gt;val)            return false;        if(isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right))            return true;        else            return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we use depth-first search to search the tree. In the process, recursion is needed. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Ppalindrome Number</title>
    <link href="/2015/06/21/leetcode_palindrome_number/"/>
    <url>/2015/06/21/leetcode_palindrome_number/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this in place with constant memory.</p><p>For example,<br>Given input array nums = [1,1,2],</p><p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p><p>The original problem is <a href="https://leetcode.com/problems/palindrome-number/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/PalindromeNumber.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Palindrome Number  *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    bool isPalindrome(int x) &#123;        if(x &lt; 0)            return false;        int y = x;        int len = numberLength(y);        if(len == 1)            return true;        int high_num, low_num;        int high_divisor, low_divisor;        high_divisor = pow(10,len-1);        low_divisor  = 10;        while(high_divisor &gt;= low_divisor)&#123;            high_num = y / high_divisor;            low_num  = y % low_divisor;             if(high_num != low_num)                return false;            y = y - high_num * high_divisor;            y = y / low_divisor;            high_divisor = high_divisor / 100;        &#125;                return true;    &#125;    int numberLength(int x)&#123;        int y = x;        int len = 0;        while(y&gt;0)&#123;            y = y / 10;            len ++;        &#125;        return len;    &#125;&#125;;//the code under below is for testint main()&#123;    Solution s;    int x = -2147447412;    int len = s.numberLength(x);    bool p = s.isPalindrome(x);    cout&lt;&lt;&quot;len=&quot;&lt;&lt;len&lt;&lt;endl;    cout&lt;&lt;&quot;p=&quot;&lt;&lt;p&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we just find the high number and the low number of x. Then compare them, if the same go to the next, else return false. Before next step, we should remove the high number and low number of x. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Remove Nth Node From End Of List</title>
    <link href="/2015/06/20/leetcode_remove_nth_node_from_end_of_list/"/>
    <url>/2015/06/20/leetcode_remove_nth_node_from_end_of_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a linked list, remove the nth node from the end of list and return its head.</p><p>For example,</p><p>   Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p><p>   After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p><p>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p><p>The original problem is <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RemoveNthNodeFromEndOfList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Remove Nth Node from End of List *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        if(head==NULL)            return NULL;        if(head-&gt;next == NULL &amp;&amp; n == 1)            return NULL;        ListNode *ptr, *ptr_nth, *ptr_before;        int count  = 0;        ptr = head;        ptr_nth    = head;        ptr_before = head;        while(ptr-&gt;next != NULL)&#123;            if(count &gt; n)&#123;                ptr_before = ptr_nth;                ptr_nth = ptr_nth-&gt;next;            &#125;            count ++;            ptr = ptr-&gt;next;        &#125;        if(ptr_before == ptr_nth)            head = head-&gt;next;        else            ptr_before-&gt;next = ptr_nth-&gt;next;                    return head;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To solve the problem, we need three pointers, one pointer traverse the list and the second one point the element which always keeps n distance to the first pointer. The third pointer will always before the second one. Finally, after traverse the list, remove the element which pointed by the second pointer.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Remove Duplicates from Sorted List</title>
    <link href="/2015/06/20/leetcode_remove_duplicates_from_sorted_list/"/>
    <url>/2015/06/20/leetcode_remove_duplicates_from_sorted_list/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p><p>The original problem is <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RemoveDuplicatesFromSortedList.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Remove Duplicates from Sorted List *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*//** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(head == NULL || head-&gt;next == NULL)            return head;        ListNode *ptr_all = head-&gt;next;        ListNode *ptr_use = head;        while(ptr_all != NULL)&#123;            if(ptr_all-&gt;val != ptr_use-&gt;val)&#123;                ptr_use-&gt;next = ptr_all;                ptr_use = ptr_use-&gt;next;            &#125;            ptr_all = ptr_all-&gt;next;        &#125;        ptr_use-&gt;next = NULL;        return head;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Firstly, we need judge whether the list is null or only has one elemet or not.<br>To solve the problem, I use two pointers ptr_all and ptr_use. Then, traverse the list use ptr_all, add the unqiue number to ptr_use.  </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Merge Sorted Array</title>
    <link href="/2015/06/19/leetcode_merge_sorted_array/"/>
    <url>/2015/06/19/leetcode_merge_sorted_array/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p>Note:<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.</p><p>The original problem is <a href="https://leetcode.com/problems/merge-sorted-array/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/MergeSortedArray.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;        vector&lt;int&gt; nums3;        vector&lt;int&gt;::iterator  iter1, iter2,iter3;        int count=0,count1=0, count2=0;        int temp = 0;        iter1=nums1.begin();        for(count1=0;count1&lt;m;count1++)&#123;            nums3.push_back(*iter1);            iter1++;        &#125;        iter1=nums1.begin();        iter2=nums2.begin();        iter3=nums3.begin();        count1=0;         for(;iter2&lt;nums2.end()&amp;&amp;iter3&lt;nums3.end();)&#123;            cout&lt;&lt;*iter3&lt;&lt;&quot; &quot;&lt;&lt;*iter2&lt;&lt;endl;            if(*iter3 &lt;= *iter2)&#123;                *iter1 = *iter3;                iter1 ++;                iter3 ++;            &#125;            else&#123;                *iter1 = *iter2;                iter1 ++;                iter2 ++;            &#125;        &#125;        while(iter2&lt;nums2.end())&#123;            *iter1 = *iter2;            iter1++;            iter2++;        &#125;        while(iter3&lt;nums3.end())&#123;            *iter1 = *iter3;            iter1++;            iter3++;        &#125;    &#125;&#125;;// The code under blow is used for testint main()&#123;    vector&lt;int&gt; nums1;    vector&lt;int&gt; nums2;    vector&lt;int&gt;::iterator iter;    Solution s;    nums1.push_back(2);    nums1.push_back(0);    nums2.push_back(1);    s.merge(nums1,1,nums2,1);    for(iter=nums1.begin();iter&lt;nums1.end();++iter)&#123;        cout&lt;&lt;*iter&lt;&lt;endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To simplify the problem, I copy the useful values from nums1 to nums3. Then, compare the nums2 and nums3, and using “merge sort” algorithm to get the sorted array nums1. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Remove Duplicates from Sorted Array</title>
    <link href="/2015/06/19/leetcode_remove_duplicates_from_sorted_array/"/>
    <url>/2015/06/19/leetcode_remove_duplicates_from_sorted_array/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this in place with constant memory.</p><p>For example,<br>Given input array nums = [1,1,2],</p><p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p><p>The original problem is <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RemoveDuplicatesFromSortedArray.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Remove Duplicates from Sorted Array *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()==0)            return 0;        vector&lt;int&gt; nums1;        vector&lt;int&gt;::iterator iter,iter1;        int last_num;        int total_num = 0;        for(iter=nums.begin();iter&lt;nums.end();++iter) &#123;            nums1.push_back(*iter);        &#125;        iter = nums.begin();        last_num = *iter;        iter ++;        total_num ++;        for(iter1=nums1.begin();iter1&lt;nums1.end();++iter1)&#123;            if(*iter1 != last_num)&#123;                last_num = *iter1;                *iter = last_num;                iter ++;                total_num ++;            &#125;        &#125;        return total_num;    &#125;&#125;;// The code under blow is used for testint main() &#123;    vector&lt;int&gt; nums;    vector&lt;int&gt;::iterator iter;    nums.push_back(1);    nums.push_back(2);    nums.push_back(2);    nums.push_back(3);        Solution s;    int total_num = s.removeDuplicates(nums);    cout&lt;&lt;&quot;total_num=&quot;&lt;&lt;total_num&lt;&lt;endl;    for(iter=nums.begin();iter&lt;nums.end();++iter)&#123;        cout&lt;&lt;*iter&lt;&lt;endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To simplify the problem, I copy the useful values from nums to nums1. Then, traverse the nums1, copy the value which is differet from the last one to nums. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Remove Duplicates from Sorted Array</title>
    <link href="/2015/06/19/leetcode_remove_duplicates_from_sorted_array2/"/>
    <url>/2015/06/19/leetcode_remove_duplicates_from_sorted_array2/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most twice?</p><p>For example,<br>Given sorted array nums = [1,1,1,2,2,3],</p><p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.</p><p>The original problem is <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RemoveDuplicatesFromSortedArray2.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Remove Duplicates from Sorted Array 2*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        if(size &lt;= 2)            return size;        vector&lt;int&gt; result;        int lastNum = nums[0];        int totalNum = 1;        int repeatNum = 0;                result.push_back(nums[0]);        for(int i=1;i&lt;size;i++)&#123;            if(nums[i] == lastNum)&#123;                repeatNum ++;                if(repeatNum &lt;= 1)&#123;                    result.push_back(nums[i]);                    totalNum ++;                &#125;            &#125;            else&#123;                repeatNum = 0;                lastNum = nums[i];                result.push_back(nums[i]);                totalNum ++;            &#125;        &#125;        nums =  result;        return totalNum;    &#125;&#125;;// The code under blow is used for testint main() &#123;    vector&lt;int&gt; nums;    vector&lt;int&gt;::iterator iter;    nums.push_back(1);    nums.push_back(1);    nums.push_back(1);    //nums.push_back(1);        Solution s;    int total_num = s.removeDuplicates(nums);    cout&lt;&lt;&quot;total_num=&quot;&lt;&lt;total_num&lt;&lt;endl;    for(iter=nums.begin();iter&lt;nums.end();++iter)&#123;        cout&lt;&lt;*iter&lt;&lt;endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>A new array is used to save the valid numbers. Then, traverse the nums, copy the value which is differet from the last two to the new array. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2015/04/14/hello-world/"/>
    <url>/2015/04/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Excel Sheet Column Number</title>
    <link href="/2015/04/05/leetcode_excel_sheet_column_number/"/>
    <url>/2015/04/05/leetcode_excel_sheet_column_number/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Related to question Excel Sheet Column Title</p><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p><p>For example:</p><pre><code class="hljs">A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 </code></pre><p>The original problem is <a href="https://leetcode.com/problems/excel-sheet-column-number/" title="Problem">here</a>.</p><p>My code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/ExcelSheetColumnNumber.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Excel Sheet Column Number *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    int titleToNumber(string s) &#123;        int num = 0;        int bit_num = 0;        int len = s.size();        for(int count=len-1;count&gt;=0;count--,bit_num ++)        &#123;            int diff = s[count]-&#39;A&#39; + 1;            num += diff * pow(26,bit_num);        &#125;         return num;    &#125;&#125;; //the codes below is used for testint main()&#123;        string str(&quot;AB&quot;);    Solution s;    int num = s.titleToNumber(str);    cout&lt;&lt;num&lt;&lt;endl;    system(&quot;pause&quot;);&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>This problem is similar to conver  binary to decimal.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Swap Nodes in Pairs</title>
    <link href="/2015/04/04/leetcode_swap_nodes_in_pairs/"/>
    <url>/2015/04/04/leetcode_swap_nodes_in_pairs/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p><p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p><p>The original problem is <a href="https://leetcode.com/problems/swap-nodes-in-pairs/" title="Problem">here</a>.</p><p>My code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/SwapNodesInPairs.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Swap Nodes in Pairs*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*//** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *swapPairs(ListNode *head) &#123;        if(head == NULL)            return head;        if(head-&gt;next == NULL)            return head;                ListNode * currentNode = head-&gt;next;        ListNode * lastNode = head;        ListNode * tempNode;        if(head-&gt;next != NULL)        &#123;            tempNode = head;            head = head-&gt;next;            tempNode-&gt;next = head-&gt;next;             head-&gt;next = tempNode;            lastNode = head-&gt;next;            currentNode = lastNode-&gt;next;        &#125;        while(currentNode != NULL )        &#123;            if(currentNode-&gt;next == NULL)                break;            tempNode = currentNode;            currentNode = currentNode-&gt;next;            tempNode-&gt;next = currentNode-&gt;next;            currentNode-&gt;next = tempNode;                        lastNode-&gt;next = currentNode;                        lastNode    = currentNode-&gt;next;            currentNode = lastNode-&gt;next;        &#125;        return head;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><ol><li>We must swap the nodes instead of values.</li><li>When swap two nodes, we must assign the next value of the last node to  the current node.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Number of 1 Bits</title>
    <link href="/2015/04/03/leetcode_number_of_1bits/"/>
    <url>/2015/04/03/leetcode_number_of_1bits/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p><p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p><p>The original problem is <a href="https://leetcode.com/problems/number-of-1-bits/" title="Problem">here</a>.</p><p>My code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Numberof1Bits.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Number of 1 Bits*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/class Solution &#123;public:    int hammingWeight(uint32_t n) &#123;        int bitNum = 0;                while(n &gt; 1)        &#123;            if(n % 2 == 1)                bitNum ++;                        n = n/2;        &#125;        if(n%2 == 1)            bitNum ++;        return bitNum;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>It is similar to convert decimal to binary.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Longest Common Prefix</title>
    <link href="/2015/04/03/leetcode_longest_common_prefix/"/>
    <url>/2015/04/03/leetcode_longest_common_prefix/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>The original problem is <a href="https://leetcode.com/problems/longest-common-prefix/" title="Problem">here</a>.<br>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/LongestCommonPrefix.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Longest Common Prefix *Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;stringstream&gt;using namespace std;class Solution &#123;public:    string longestCommonPrefix(vector&lt;string&gt; &amp;strs) &#123;        int vec_len = strs.size();        string strPrefix ;        if(vec_len &gt; 0)        &#123;            vector&lt;string&gt;::iterator iter;            iter=strs.begin();            strPrefix = *iter;            for(iter=strs.begin();iter&lt;strs.end();++iter)            &#123;                strPrefix = commonPrefix(strPrefix,*iter);            &#125;        &#125;         else        &#123;            strPrefix = &quot;&quot;;        &#125;        return strPrefix;    &#125;    string commonPrefix(string str1, string str2)    &#123;        int len = str1.size()&gt;str2.size() ? str2.size(): str1.size();        string strPrefix;        for(int count=0;count&lt;len;++count)        &#123;            if(str1[count] == str2[count])            &#123;                stringstream ss;                string str_ch;                ss.clear();                ss&lt;&lt;str1[count];                ss&gt;&gt;str_ch;                strPrefix.append(str_ch);                &#125;            else                break;        &#125;        return strPrefix;    &#125; &#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>The method is similar to compute the minimal or maximal value of one integer array. The only different is in this problem the element is string instead of integer. Additionally, we need get the common prefix of two string. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Remove Element</title>
    <link href="/2015/04/03/leetcode_remove_element/"/>
    <url>/2015/04/03/leetcode_remove_element/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array and a value, remove all instances of that value in place and return the new length.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p>The original problem is <a href="https://leetcode.com/problems/remove-element/" title="Problem">here</a>.<br>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/RemoveElement.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Remove Element*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/class Solution &#123;public:    int removeElement(int A[], int n, int elem) &#123;        int new_len = 0;        for(int count=0;count&lt;n;++count)        &#123;            if(A[count] != elem)            &#123;                A[new_len] = A[count];                new_len ++;                &#125;        &#125;        return new_len;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Just keep patient!</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Divide Two Integers</title>
    <link href="/2015/04/03/leetcode_divide_two_integers/"/>
    <url>/2015/04/03/leetcode_divide_two_integers/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Divide two integers without using multiplication, division and mod operator.</p><p>If it is overflow, return MAX_INT.</p><p>The original problem is <a href="https://leetcode.com/problems/divide-two-integers/" title="Problem">here</a>.<br>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/DivideTwoIntegers.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;class Solution &#123;public:    int divide(int dividend, int divisor) &#123;        int res  = 0, move = 0;        int MIN_VALUE = -2147483648;        int MAX_VALUE = 2147483647;        if(divisor == 0)            return MAX_VALUE;                if(dividend == MIN_VALUE)        &#123;            if(divisor == -1)                return MAX_VALUE;                        dividend += abs(divisor);            res ++;         &#125;        if(divisor == MIN_VALUE)          &#123;              return res;          &#125;          int flag = sign(dividend,divisor);        dividend = abs(dividend);        divisor  = abs(divisor);        int divid = dividend &gt;&gt; 1;        int divis = divisor;        cout&lt;&lt;&quot;dividend=&quot;&lt;&lt;divid&lt;&lt;endl;        cout&lt;&lt;&quot;divis=&quot;&lt;&lt;divis&lt;&lt;endl;        while(divid &gt;= divis)        &#123;            move +=1;            divis = divis &lt;&lt; 1;                     &#125;        while(move &gt;= 0)        &#123;            if(dividend &gt;= divis)            &#123;                res += 1&lt;&lt;move;                dividend =  dividend - divis;            &#125;             divis = divis &gt;&gt; 1;            move --;        &#125;        if(flag == 1)            return res;        else            return -res;    &#125;    int sign(int num1, int num2)    &#123;        if((num1 &gt; 0 &amp;&amp; num2&gt;0) || (num1 &lt; 0 &amp;&amp; num2&lt;0))            return 1;        else            return -1;    &#125;&#125;;int main()&#123;    Solution s;    //int dividend = 2147483647;    int dividend = 9;    int divisor  = 1;    int res = s.divide(dividend,divisor);    cout&lt;&lt;res&lt;&lt;endl;    //int a = dividend &lt;&lt; 1;    //cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;    //cout&lt;&lt;&quot;dividend=&quot;&lt;&lt;dividend&lt;&lt;endl;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>At first, we should judge whether the dividend and divisor are Max Value or Min Value. If divisor is zero, directly return the Max value.<br>Because we can’t use multiplication, division and mod operator, so we use bit and minus operator. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Balanced Binary Tree</title>
    <link href="/2015/04/01/leetcode_balanced_binary_tree/"/>
    <url>/2015/04/01/leetcode_balanced_binary_tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>The original problem is <a href="https://leetcode.com/problems/balanced-binary-tree/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/BalancedBinaryTree.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/** * Definition for binary tree * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ #include&lt;iostream&gt; #include&lt;math&gt; using namespace std; class Solution &#123;public:    bool isBalanced(TreeNode *root) &#123;        int theDepth;        return isTreeBalanced(root, &amp;theDepth);     &#125;    bool isTreeBalanced(TreeNode *theRoot, int *theDepth)     &#123;        if(theRoot == NULL)        &#123;            *theDepth = 0;            return true;        &#125;        int leftDepth, rightDepth;        if(isTreeBalanced(theRoot-&gt;left, &amp;leftDepth) &amp;&amp; isTreeBalanced(theRoot-&gt;right, &amp;rightDepth))        &#123;            int diffDepth = abs(leftDepth - rightDepth);            if(diffDepth &lt;= 1)            &#123;                *theDepth = 1 + (leftDepth &gt; rightDepth ? leftDepth : rightDepth);                return true;            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To reduce the time complexity, I put the depth as the function parameter and recursively judge whether the left and right of the tree is the balanced tree and the difference of depth of two subtrees is less or equal to 1.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统环境下使用iconv实现文件编码格式的转换</title>
    <link href="/2015/03/31/linux_iconv/"/>
    <url>/2015/03/31/linux_iconv/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Linux系统环境下，有很多处理文件编码格式的方法，比如vim中，使用“set fileencoding=utf-8”可以实现编码格式到UTF8格式的转换。但是个人觉得iconv更加好用些，下面就介绍下如何使用。</p><h1 id="iconv使用方法"><a href="#iconv使用方法" class="headerlink" title="iconv使用方法"></a>iconv使用方法</h1><p>下面是iconv的使用方法，比较重要的参数就是 “-f”：给出输入文件的编码格式，比如GBK； “-t”：指定输出文件的编码格式； “-o”：指定输出文件的文件名。</p><span id="more"></span><pre><code class="hljs">Usage: iconv [OPTION...] [FILE...]Convert encoding of given files from one encoding to another. Input/Output format specification:  -f, --from-code=NAME       encoding of original text  -t, --to-code=NAME         encoding for output Information:  -l, --list                 list all known coded character sets Output control:  -c                         omit invalid characters from output  -o, --output=FILE          output file  -s, --silent               suppress warnings      --verbose              print progress information  -?, --help                 Give this help list      --usage                Give a short usage message  -V, --version              Print program versionMandatory or optional arguments to long options are also mandatory or optionalfor any corresponding short options.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/libc/bugs.html&gt;.</code></pre><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>如何确定文件的格式呢，使用“file”来查看文件的编码格式，比如：<br>    file train.data</p><p>举个例子，一个编码格式为GBK的文件train.data，如果要对该文件转换成UTF8格式的文件，可以这样来实现：</p><pre><code class="hljs">iconv -f GBK -t UTF-8 train.data -o train_utf8.data</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Find Peak Element</title>
    <link href="/2015/03/30/leetcode_find_peak_element/"/>
    <url>/2015/03/30/leetcode_find_peak_element/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that num[-1] = num[n] = -∞.</p><p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p><p>The original problem is <a href="https://leetcode.com/problems/find-peak-element/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Find_Peak_Element.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Find Peak Element*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public:    int findPeakElement(const vector&lt;int&gt; &amp;num) &#123;        int count = 0;        if(num.size() &gt; 1)        &#123;            for(count=0;count&lt;num.size();++count)            &#123;                if(count == 0)                &#123;                    if(num[count] &gt; num[count+1])                        return count;                &#125;                else if(count == num.size()-1)                &#123;                    if(num[count] &gt; num[count-1])                        return count;                &#125;                else                &#123;                    if(num[count] &gt; num[count-1] &amp;&amp; num[count] &gt; num[count+1])                         return count;                &#125;            &#125;        &#125;        else            return count;    &#125;&#125;;int main() &#123;    Solution s;    int array[] = &#123;1,2,3,1&#125;;    vector&lt;int&gt; num;    for(int count=0;count&lt;4;++count)    &#123;        num.push_back(array[count]);    &#125;    vector&lt;int&gt;::iterator iter;    for(iter=num.begin();iter&lt;num.end();++iter)        cout&lt;&lt;*iter&lt;&lt;endl;    int index = s.findPeakElement(num);    cout&lt;&lt;&quot;index=&quot;&lt;&lt;index&lt;&lt;endl;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h1><p>This problem is easy, the only thing we need to note is the begining and end of the number;</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Compare Version Numbers</title>
    <link href="/2015/03/30/leetcode_compare_version_numbers/"/>
    <url>/2015/03/30/leetcode_compare_version_numbers/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Compare two version numbers version1 and version2.<br>If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0.</p><p>You may assume that the version strings are non-empty and contain only digits and the . character.<br>The . character does not represent a decimal point and is used to separate number sequences.<br>For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p><p>Here is an example of version numbers ordering:</p><p>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</p><p>The original problem is <a href="https://leetcode.com/problems/factorial-trailing-zeroes/" title="Problem">here</a>.<br>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Factorial_Trailing_Zeroes.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Compare Version Numbers*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;vector&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;class Solution &#123;public:    int compareVersion(string version1, string version2) &#123;        vector&lt;string&gt; vec1 = str2Vector(version1);        vector&lt;string&gt; vec2 = str2Vector(version2);        int strLarger;        int addSize = 0;        if(vec1.size() &gt; vec2.size())        &#123;            addSize = vec1.size() - vec2.size();            vectorRaise(vec2,addSize);         &#125;        else if(vec1.size() &lt; vec2.size())        &#123;            addSize = vec2.size() - vec1.size();            vectorRaise(vec1,addSize);         &#125;        vector&lt;string&gt;::iterator iter1,iter2;        for(iter1=vec1.begin(),iter2=vec2.begin();iter1&lt;vec1.end()&amp;&amp;iter2&lt;vec2.end();++iter1,++iter2)        &#123;            strLarger = strCompare(*iter1,*iter2);            if(strLarger == 1)                return 1;            else if(strLarger == -1)                return -1;            else if(iter1==vec1.end()-1 &amp;&amp; iter2==vec2.end()-1)            &#123;                if(strLarger == 0)                    return 0;            &#125;        &#125;     &#125;    int strCompare(string str1, string str2)    &#123;        int num1=str2Integer(str1);        int num2=str2Integer(str2);        if(num1&gt;num2)            return 1;        else if(num1&lt;num2)            return -1;        else            return 0;    &#125;    int str2Integer(string str)    &#123;        stringstream ss;        int num;        ss.clear();        ss.str(&quot;&quot;);        ss&lt;&lt;str;        ss&gt;&gt;num;        return num;    &#125;    vector&lt;string&gt; str2Vector(string str)    &#123;        string strNum, strTemp;        stringstream ss;        vector&lt;string&gt; strVec;        for(int count=0;count&lt;str.size();++count)        &#123;            if(count == str.size()-1)            &#123;                ss.clear();                ss&lt;&lt;str[count];                ss&gt;&gt;strTemp;                strNum.append(strTemp);                strVec.push_back(strNum);            &#125;            if(str[count] == &#39;.&#39;)            &#123;                strVec.push_back(strNum);                strNum.clear();            &#125;            else            &#123;                ss.clear();                 ss&lt;&lt;str[count];                ss&gt;&gt;strTemp;                strNum.append(strTemp);            &#125;        &#125;        return strVec;    &#125;    void vectorRaise(vector&lt;string&gt; &amp; vec,int addSize)    &#123;        for(int count=0;count&lt;addSize;count++)            vec.push_back(&quot;0&quot;);    &#125;&#125;;//The code below is used for testint main()&#123;    string str1 = &quot;1.0&quot;;    string str2 = &quot;0.1&quot;;    Solution s;    int res = s.compareVersion(str1,str2);    cout&lt;&lt;&quot;res=&quot;&lt;&lt;res&lt;&lt;endl;    //system(&quot;pause&quot;);&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Many situations should be considered, such as there are more than one “.”, the two versions have differet number of subversion and so on.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Factorial Trailing Zeroes</title>
    <link href="/2015/03/30/leetcode_factorial_trailing_zeroes/"/>
    <url>/2015/03/30/leetcode_factorial_trailing_zeroes/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an integer n, return the number of trailing zeroes in n!.</p><p>Note: Your solution should be in logarithmic time complexity.</p><p>The original problem is <a href="https://leetcode.com/problems/factorial-trailing-zeroes/" title="Problem">here</a>.</p><p>The original code is <a href="https://github.com/shuaijiang/LeetCode/blob/master/Factorial_Trailing_Zeroes.cpp" title="Code">here</a>.</p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">/**Factorial Trailing Zeroes*Author: shuaijiang*Email: zhaoshuaijiang8@gmail.com*/#include&lt;iostream&gt;using namespace std;class Solution &#123;public:    int trailingZeroes(int n)     &#123;        int zeros = 0;        int factor = 5;        while(n)        &#123;                        zeros = zeros + n/factor;            n = n/factor;        &#125;        return zeros;    &#125;    /* The code below exceed the time    int trailingZeroes(int n)     &#123;        int zeros = 0;        int factor = 5;        while(factor &lt;= n)        &#123;                    zeros = zeros + n/factor;            factor = factor * 5;            if(factor &gt;= 2147483647)                return zeros;        &#125;        return zeros;    &#125;    */&#125;;//The code under below is used for testint main()&#123;    Solution s;    int n = 2147483647;    cout&lt;&lt;&quot;n=&quot;&lt;&lt;n&lt;&lt;endl;    int zeros = s.trailingZeroes(n);    cout&lt;&lt;zeros&lt;&lt;endl;    system(&quot;pause&quot;); &#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>One thing need to be noted is the time complexity. Because the trailing zeros are produced by 5 * 2, and the number of 5 is more than 2, so we just need point the number of 5. N=|_ 5^j _|, we just need compute the j.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Largest Number</title>
    <link href="/2015/03/29/leetcode_largest_number/"/>
    <url>/2015/03/29/leetcode_largest_number/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.</p><p>Note: The result may be very large, so you need to return a string instead of an integer.</p><p>The original problem is <a href="https://leetcode.com/problems/largest-number/" title="here">here</a>:  </p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in C++, as below:</p><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;sstream&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;using namespace std;class Solution &#123;public:    string largestNumber(vector&lt;int&gt; &amp;num) &#123;        vector&lt;int&gt;::iterator iter,iterI,iterJ;        int temp;        stringstream ss;        string str;         bool first_num = true;        for(iterI=num.end()-1;iterI&gt;=num.begin()+1;iterI--)        &#123;            iterJ=iterI-1;            do            &#123;                if(largerNumber(*iterI,*iterJ))                &#123;                    temp = *iterJ;                    *iterJ = *iterI;                    *iterI = temp;                &#125;                iterJ--;            &#125;while(iterJ&gt;=num.begin());        &#125;        for(iter=num.begin();iter&lt;num.end();++iter)        &#123;            if(first_num == true &amp;&amp; *iter == 0)            &#123;                ss&lt;&lt;*iter;                break;            &#125;else            &#123;                ss&lt;&lt;*iter;                first_num = false;            &#125;        &#125;         str=(ss.str());        return str;    &#125;    vector&lt;int&gt; number2vector(int num)&#123;        vector&lt;int&gt; vec;        int remainder;        if(num &gt;0)&#123;            while(num&gt;0)&#123;                remainder = num%10;                num = num/10;                vec.push_back(remainder);            &#125;            reverse(vec.begin(),vec.end());        &#125;else&#123;            vec.push_back(num);        &#125;        return vec;    &#125;    void vectorRaise(vector&lt;int&gt; &amp; vec,int addSize)    &#123;        vector&lt;int&gt;::iterator iter;                for(int count=0;count&lt;addSize;count++)        &#123;            iter = vec.begin();            //cout&lt;&lt;&quot;iter=&quot;&lt;&lt;*iter&lt;&lt;endl;            vec.push_back(*iter);        &#125;                &#125;    bool largerNumber(int a, int b)&#123;        vector&lt;int&gt; vecA = number2vector(a);        vector&lt;int&gt; vecB = number2vector(b);        double ab = (double)a*pow(10,vecB.size()) + b;        double ba = (double)b*pow(10,vecA.size()) + a;        if(ab&gt;ba)            return true;        else            return false;         /*vector&lt;int&gt;::iterator iterA;        vector&lt;int&gt;::iterator iterB;        if(vecA.size() &gt; vecB.size())        &#123;            int num = vecA.size()-vecB.size();            vectorRaise(vecB,num);        &#125;        else&#123;            int num = vecB.size()-vecA.size();            vectorRaise(vecA,num);        &#125;        for(iterA=vecA.begin(),iterB=vecB.begin();iterA&lt;vecA.end()&amp;&amp;iterB&lt;vecB.end();++iterA,++iterB)        &#123;            if(*iterA &gt; *iterB)                return true;            else if(*iterA &lt; *iterB)                return false;        &#125;        if(vecA.size() &gt; vecB.size())            return false;        else            return true;        */    &#125;&#125;;//The code below is used for testint main()&#123;    //int a[] = &#123;3, 30, 34, 5, 9&#125;;    //int a[] = &#123;1440,7548,4240,6616,733,4712,883,8,9576&#125;;    int a[] = &#123;121,12&#125;;    int arrayNum = 2;    Solution s;    vector&lt;int&gt; vec;    int numA = 8;    int numB = 883;    for(int count=0;count&lt;arrayNum;count++)        vec.push_back(a[count]);            //vector&lt;int&gt;::iterator iter;    string str = s.largestNumber(vec);    cout&lt;&lt;&quot;largest number is &quot;&lt;&lt;str&lt;&lt;endl;    bool larger = s.largerNumber(numA, numB);    cout&lt;&lt;&quot;larger=&quot;&lt;&lt;larger&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;    &#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>To find the largest number, we just sort the numbers according to descending order and then join them together. But one important thing need to be noted is how to select the larger number of any two numbers. We can’t compare the two numbers as usual,  os we need to compare them after join them together at different order.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Reverse Bits</title>
    <link href="/2015/03/22/leetcode_reverse_bits/"/>
    <url>/2015/03/22/leetcode_reverse_bits/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Reverse bits of a given 32 bits unsigned integer.</p><p>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).</p><p>The original problem is <a href="https://leetcode.com/problems/reverse-bits/" title="here">here</a>:  </p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in Python, as below:</p><pre><code class="hljs">class Solution:    # @param n, an integer    # @return an integer    def reverseBits(self, n):        bits = [0] * 32;        rev_bits = [0] * 32;        bits = self.integer2binary(n)        for i in range(len(bits)):            rev_bits[i] = bits[31-i]        rev_n = self.binary2integer(rev_bits)        return rev_n    def integer2binary(self,n):        bits = [0]*32        i = 31        while(n&gt;0):            bits[i] = n % 2            n = n/2            i -=1        return bits    def binary2integer(self,bits):        n = 0        bits_len = len(bits)        for i in range(len(bits)):            n += bits[i]*pow(2,bits_len-i-1)        return n#The code under below is used for test#n=43261596#S = Solution()#print S.reverseBits(n)</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>This problem can be parted as two parts: one is integer2binary and the other is binary2integer. Then it is easy to solve this problem.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Rotate Array</title>
    <link href="/2015/03/20/leetcode_rotate_array/"/>
    <url>/2015/03/20/leetcode_rotate_array/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Rotate an array of n elements to the right by k steps.</p><p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p><p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p><p>The original problem is <a href="https://leetcode.com/problems/rotate-array/" title="here">here</a>:  </p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in Python, as below:</p><pre><code class="hljs">class Solution:    # @param nums, a list of integer    # @param k, num of steps    # @return nothing, please modify the nums list in-place.    def rotate(self, nums, k):        total_num = len(nums)        temp_nums = nums[:]        if(total_num &lt;= k):            k =  k % total_num        begin_count = total_num - k        for i in range(0,k):            nums[i] = temp_nums[begin_count+i]        for i in range(k,total_num):            nums[i] = temp_nums[i-k]        #return nums    #The codes Under below is used for running    #Don&#39;t submit them    #nums = [1,2,3,4,5]    #k = 3    #S = Solution()    #S.rotate(nums,k)    #print nums</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>One point should be noted is when k is larger than the length of the array, we should compute the modulus of k to the array length.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Reverse Integer</title>
    <link href="/2015/03/15/leetcode_reverse_integer/"/>
    <url>/2015/03/15/leetcode_reverse_integer/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Reverse digits of an integer.</p><p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p><p>The original problem is <a href="https://leetcode.com/problems/reverse-integer/" title="here">here</a>:  </p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in Python, as below:</p><pre><code class="hljs">class Solution:    # @return an integer    def reverse(self, x):        max_int =  2147483647        min_int = -2147483648        y = &quot;0&quot;        flag = &quot;&quot;;        if x &lt; 0:            flag = &quot;-&quot;            x =-x        else:            flag = &quot;&quot;        while(x &gt; 0) :            y += str(x%10)            x = x/10        y = flag + y        y = int(y)        if(y&gt;max_int):            y = 0        if(y&lt;min_int):            y = 0        return y</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>There maybe only one problem should be noted is “overflow”. The integer is 32-bit number, we should ensure the result is not beyond the scope -2147483648 ~ 2147483647. If so, the result should be zero.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode ZigZag Conversion</title>
    <link href="/2015/03/15/leetcode_zigzag/"/>
    <url>/2015/03/15/leetcode_zigzag/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>And then read line by line: “PAHNAPLSIIGYIR”<br>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string text, int nRows);<br>convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.</p><p>The original problem is <a href="https://leetcode.com/problems/zigzag-conversion/" title="here">here</a>:  </p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in Python, as below:</p><pre><code class="hljs">class Solution:    # @return a string    def convert(self, s, nRows):        new_str = [&quot;&quot;]* nRows        count = 0        direct = 1        for i in range(len(s)):            if(direct == 1):                new_str[count] += s[i]                if count == nRows-1:                    direct = 0                    count -= 1                    if count&lt;=0:                        count = 0                else:                    count += 1            else:                new_str[count] += s[i]                if count == 0:                    direct = 1                    count += 1                    if count&gt;=nRows:                        count = nRows-1                else:                    count -= 1        new_s=&quot;&quot;        for j in range(len(new_str)):            new_s += new_str[j]        return new_s</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>First of all, you should know what is “ZigZag”. In this problem, we can consider it as one person runs between two “point”: run from start to end, and then run back.</p><p>Secondly, when we convert the string to “ZigZag”, how to deal the begin and end of each column should under the consider. </p><p>And other special conditions should also be considered, such as when nRows=1, and so on.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Longest Substring Without Repeating Characters</title>
    <link href="/2015/01/25/leetcode_longest_substring/"/>
    <url>/2015/01/25/leetcode_longest_substring/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p><p>The original problem is <a href="https://oj.leetcode.com/problems/longest-substring-without-repeating-characters/" title="here">here</a>:  </p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><pre><code class="hljs">import java.util.HashMap;public class Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        HashMap&lt;Integer,Integer&gt; substr = new HashMap&lt;Integer,Integer&gt;();        HashMap&lt;Integer,Integer&gt; lengthHash = new HashMap&lt;Integer,Integer&gt;();        int count = 0 , start = 0;        int length = 0;        int max = 0;        for(count=0;count&lt;s.length();count++)        &#123;            char ch_real = s.charAt(count);            int ch = (int)ch_real;            if(substr.get(ch) == null || substr.get(ch) &lt; start)            &#123;                length += 1;                substr.put(ch,count);            &#125;            else            &#123;                lengthHash.put(length,1);                length = count - substr.get(ch);                start = substr.get(ch) + 1;                substr.put(ch,count);            &#125;        &#125;        lengthHash.put(length,1);        for(Object obj:lengthHash.keySet())        &#123;            Object key = obj;            Integer value = (Integer)key;            if(value &gt; max)                max = value;        &#125;        return max;    &#125;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>In my solution, I traversal the string once. During the traversal, we can find each substring and the length of it. Finally, we can get maximum of the lengths. </p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Add Two Numbers</title>
    <link href="/2015/01/24/leetcode_addtwonumbers/"/>
    <url>/2015/01/24/leetcode_addtwonumbers/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p><p>The original problem is <a href="https://oj.leetcode.com/problems/add-two-numbers/" title="here">here</a>:  </p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in Java, as below:</p><pre><code class="hljs"> /** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        int carry = 0;        int value = 0;        int count = 0;        ListNode result = null, l3 = null;        while(l1 != null || l2 != null)        &#123;            if(l1 == null)                l1 = new ListNode(0);            if(l2 == null)                l2 = new ListNode(0);                        if(count == 0)            &#123;                l3 = new ListNode(0);                result = l3;            &#125;            else            &#123;                l3.next = new ListNode(0);                l3 = l3.next;            &#125;            if(carry == 1)            &#123;                l3.val = 1;            &#125;            value = l1.val + l2.val + carry;            if(value &gt;= 10)            &#123;                value = value%10;                carry = 1;            &#125;            else                carry = 0;            l3.val = value;            if(carry == 1)            &#123;                l3.next = new ListNode(1);            &#125;            l1 = l1.next;            l2 = l2.next;            count ++;        &#125;        return result;    &#125;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>Because of the two numbers are stored in two Linked lists, the addition is computed for each digit, so don’t foget the carry(进位). Additionly, the two linked lists may have different lengths!</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Two Sum</title>
    <link href="/2015/01/20/leetcode_twosum/"/>
    <url>/2015/01/20/leetcode_twosum/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p><p>You may assume that each input would have exactly one solution.</p><p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p><p>The original problem is <a href="https://oj.leetcode.com/problems/two-sum/" title="here">here</a>:  </p><span id="more"></span><h1 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h1><p>I solve this problem in Java, as below:</p><pre><code class="hljs">import java.util.HashMap; public class Solution &#123;    public int[] twoSum(int[] numbers, int target) &#123;        int[] index = new int[2];        index[0] = -1;        index[1] = -1;        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();        int len = numbers.length;        for(int i=0;i&lt;len;i++)        &#123;            Integer value = target - numbers[i];            map.put(value,i+1);        &#125;        for(int i=0;i&lt;len;i++)        &#123;            Integer gap = target - numbers[i];            Integer index2 = map.get(gap);            if(index2 != null &amp;&amp; index2 != i + 1)            &#123;                index[0]=i+1;                index[1]=index2;                return index;            &#125;        &#125;        return index;    &#125;&#125;</code></pre><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>One more ‘simple’ solution is just traversal the array in two nests, but it will take about $O(N^2)$, which exceeds the time. So another way is using Hash(or HashMap in java), keep the difference value between target and number, then you can get it without costing many time. This way just take about $O(N)$.</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感知机</title>
    <link href="/2015/01/13/ml_perceptron/"/>
    <url>/2015/01/13/ml_perceptron/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>1957年Rosenblatt提出感知机（perceptron），成为神经网络和支持向量机的基础。感知机是二类分类的线性分类模型，输入是实例的特征向量，输出是实例的类别。感知机学习的目标是求出将训练数据进行线性划分的分离超平面，感知机属于判别模型。</p><span id="more"></span><h1 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h1><p>输入空间是$X \subseteq R^n$,输出空间是$y={+1,-1}$。由输入空间到输出空间的函数$f(x)=sign(w \cdot x+b)$,称为感知机。其中，$w$和$b$是感知机模型参数，$w\in R^n $叫做权重或者权重向量，$b\in R$叫做偏置。sign是符号函数，即$sign(x)= +1, x\ge 0$;$sign(x)= -1, x&lt;0$</p><p><img src="/image/perceptron.png" alt="感知机模型"></p><h1 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h1><p>感知机学习的策略是在假设空间中选取使损失函数最小的模型参数。</p><p>假设训练数据集是线性可分的，感知机学习的目标是求得一个能够将训练集正实例点和负实例点完全正确分开的分离超平面。</p><p>为了找出这样的超平面，确定感知机模型参数，需要确定一个学习策略，也就是定义经验损失函数并将损失函数极小化。自然地，损失函数的一个选择是误分类点的总数。但是，这样的损失函数不是参数$w,b$的连续可导函数，不易优化。损失函数的另一个选择是误分类点到超平面的总距离，这也是感知机所采用的。</p><p>感知机学习的损失函数定义为$L(w,b)=-\sum_{x_i \in M} y_i (w \cdot x_i +b)$<br>其中，$M$是误分类点的集合。这个损失函数就是感知机学习的经验风险函数。</p><h1 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h1><p>感知机学习算法是误分类驱动的，具体是采用随机梯度下降法。</p><h2 id="感知机学习算法的原始形式"><a href="#感知机学习算法的原始形式" class="headerlink" title="感知机学习算法的原始形式"></a>感知机学习算法的原始形式</h2><p>给定一个训练数据集，求参数$w,b$,使其成为损失函数极小化的解：    $min L(w,b)=-\sum_{x_i \in M} y_i (w \cdot x_i +b)$,其中$M$为误分类点的集合。</p><p>感知机学习算法是误分类驱动的，具体是采用随机梯度下降法。首先，任意选取一个超平面$w_0,b_0$，然后用梯度下降法不断极小化目标函数。极小化过程中不是一次使$M$中所有的误分类点的梯度下降，而是一次随机选取一个误分类点使其梯度下降。</p><p>假设误分类点集合$M$是固定的，那么损失函数$L(w,b)$的梯度为：</p><ol><li>$\nabla _w L(w,b) = -\sum_x y_i x_i$ </li><li>$\nabla_b L(w,b) = -\sum_x y_i$</li></ol><p>随机选取一个误分类点$(x_i,y_i)$，对$w,b$进行更新：</p><ol><li>$w \leftarrow w + \eta y_i x_i$</li><li>$b\leftarrow \eta y_i$<br>其中，$\eta(0&lt;\eta \ge 1)$是步长，又称为学习率。这样，通过迭代以期损失函数$L(w,b)$不断减小，直到0为止。</li></ol><p><strong>感知机学习算法</strong><br>输入：训练数据集<br>输出：$w,b$;感知机模型$f(x)=sign(w \cdot x+b)$</p><ol><li>选取初值</li><li>在训练集中选取数据</li><li>如果 $y_i(w \cdot x_i + b) \le 0$:     $w \leftarrow w + \eta y_i x_i$;$b\leftarrow \eta y_i$</li><li>转至2，直至训练集中没有误分类点。</li></ol><p>该学习算法的直观解释是：当一个实例点被误分类，即位于分离超平面的错误一侧时，则调整$w,b$的值，使分离超平面向该误分类点的一侧移动，以减少误分类点与超平面间的距离，直至超平面越过该误分类点使其被正确分类。</p><h2 id="算法的收敛性"><a href="#算法的收敛性" class="headerlink" title="算法的收敛性"></a>算法的收敛性</h2><ol><li>好的</li><li>电话                                                            </li></ol><p>误分类的次数是有上界的，经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。也就是说，当训练数据集线性可分时，感知机学习算法原始形式迭代时收敛的。</p><h2 id="感知机学习算法的对偶形式"><a href="#感知机学习算法的对偶形式" class="headerlink" title="感知机学习算法的对偶形式"></a>感知机学习算法的对偶形式</h2>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习概述</title>
    <link href="/2015/01/09/ml_introduction/"/>
    <url>/2015/01/09/ml_introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>机器学习就是将数据转变成信息。机器学习一般采用统计方法，由数据驱动，从数据中提取特征、抽象出模型、发现数据中的知识，最终应用到数据的分析和预测。</p><p>统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。</p><span id="more"></span><h1 id="统计学习的三要素"><a href="#统计学习的三要素" class="headerlink" title="统计学习的三要素"></a>统计学习的三要素</h1><ol><li>模型</li><li>策略</li><li>算法</li></ol><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>学习什么样的模型是统计学习首先考虑的问题。在监督学习过程中，模型就是所要学习的条件概率分布或决策函数。模型的假设空间包含所有可能的条件概率分布或决策函数。</p><p>模型空间可以定义为条件概率的集合，也可以定义为决策函数的集合。</p><p>用S表示模型空间，条件概率的集合可以表示为$S=\lbrace P|P(Y|X)\rbrace$，其中，X和Y分别是定义在输入空间和输出空间的随机变量。这时$S$通常是由一个参数向量决定的条件概率分布族：$S=\lbrace P|P_{\theta} (Y|X),\theta \in R^n \rbrace$，参数向量$\theta$取决于n维欧式空间$R^n$，也称为参数空间。</p><p>类似的，决策函数的集合可以表示为$S=\lbrace f|Y=f(X)\rbrace$，其中，X和Y分别是定义在输入空间和输出空间的变量。这时$S$通常是由一个参数向量决定的函数族：$S=\lbrace f|f_{\theta} (X),\theta \in R^n \rbrace$，参数向量$\theta$取决于n维欧式空间$R^n$，也称为参数空间。</p><p>由决策函数表示的模型称为非概率模型，由条件概率表示的模型称为概率模型。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>选择最优模型是统计学习的目标，策略是选择最优模型的准则。损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。</p><h3 id="损失函数和风险函数"><a href="#损失函数和风险函数" class="headerlink" title="损失函数和风险函数"></a>损失函数和风险函数</h3><p>常用的损失函数有下面的几种：</p><ol><li>0-1损失函数：<br> $L(Y,f(X))= 1, Y \ne f(X) $ ; $ L(Y,f(X))= 0, Y = f(X)$</li><li>平方损失函数:<br> $L(Y,f(X)) = (Y-f(X))^2$</li><li>绝对损失函数：<br> $L(Y,f(X)) = |Y-f(X)|$</li><li>对数损失函数：<br> $L(Y,f(X)) = - \lg P(Y|X)$</li></ol><p>风险函数（或称期望损失），是模型$f(X)$关于联合分布$P(X,Y)$的平均意义下的损失:<br>    $R(f) = E_p [L(Y,f(X))]= \int L(y,f(x)) P(x,y) dxdy$</p><p>学习的目标就是选择期望风险最小的模型。但是联合分布$P(X,Y)$是未知的，所以不能直接计算期望风险。<br>经验风险（或称经验损失），是模型$f(X)$关于训练数据集的平均损失：<br>    $R(f) =  \frac{1}{N} \sum L(y_i,f(x_i))$</p><p>期望风险是模型关于联合分布的期望损失，经验风险是模型关于训练样本集的平均损失。根据大数定律，当样本容量$N$趋于无穷时，经验风险趋于期望风险，所以可以用经验风险来估计期望风险。</p><h3 id="经验风险最小化与结构风险最小化"><a href="#经验风险最小化与结构风险最小化" class="headerlink" title="经验风险最小化与结构风险最小化"></a>经验风险最小化与结构风险最小化</h3><p>经验风险最小化的策略认为，经验风险最小的模型是最优的模型。经验风险最小化也就是求解最优化问题：<br>    $\min_{f \in F} \frac{1}{N} \sum L(y_i,f(x_i))$<br>极大似然估计是经验风险最小化的一个例子。但是，当样本容量很小时，经验风险最小化学习的效果不一定会好，会产生过拟合现象。</p><p>为了防止过拟合提出结构风险最小化策略，其等价于正则化，结构风险在经验风险上增加了表示模型复杂度的正则化项。结构风险的定义是：<br>    $R(f) =  \frac{1}{N} \sum L(y_i,f(x_i)) + \lambda J(f)$<br>结构风险最小化的策略认为，结构风险最小的模型是最优的模型。最大后验概率估计是结构风险最小化的一个例子。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法是学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。</p><p>也就是，统计学习问题归结为最优化问题，统计学习的算法成为求解最优化问题的算法。</p><h1 id="模型评估与模型选择"><a href="#模型评估与模型选择" class="headerlink" title="模型评估与模型选择"></a>模型评估与模型选择</h1><p>统计学习的目的是使学到的模型不仅对已知的数据而且对未知数据都能有很好的预测能力。一般而言，使用训练误差和测试误差分别来衡量对已知和未知数据的预测能力。</p><h2 id="训练误差和测试误差"><a href="#训练误差和测试误差" class="headerlink" title="训练误差和测试误差"></a>训练误差和测试误差</h2><p>当损失函数给定时，基于损失函数的模型的训练误差和模型的测试误差就成为学习方法评估的标准。</p><p>假设已经学习到的模型是$Y=\hat{f}(X)$，训练误差是模型关于训练数据集的平均损失:<br>$R_{emp} (\hat{f}) = \frac{1}{N} \sum_i ^{N} L(y_i,\hat{f}(x_i))$</p><p>测试误差是模型关于测试数据集的平均损失:<br>$e_{test} = \frac{1}{N’} \sum_i ^{N’} L(y_i,\hat{f}(x_i))$</p><p>训练误差的大小，对判断问题是不是一个容易学习的问题是有意义的，但是本质上并不重要。测试误差反映了学习方法对未知的测试数据集的预测的能力，是学习中的重要概念。给定不同的学习方法，测试误差小的方法具有更好的预测能力，是更有效的方法。</p><h2 id="过拟合与模型选择"><a href="#过拟合与模型选择" class="headerlink" title="过拟合与模型选择"></a>过拟合与模型选择</h2><p>当参数空间有不同复杂度的模型时，就要面临模型选择的问题。我们希望选择或者学习到一个合适的模型，应该逼近真模型。也就是，所选择的模型要与真模型的参数个数相同、参数向量相近。</p><p>如果一味追求提高对训练数据的预测能力，所选模型复杂度则往往会比真实模型要高，这种现象就是过拟合（over-fitting）。具体来说，过拟合是指学习时选择的模型所包含的参数过多，以致于出现模型对已知数据预测得很好，但对未知数据预测得很差的现象。</p><p>下图描述了训练误差和测试误差与模型复杂度的关系：当模型的复杂度增大时，训练误差会逐渐减小并趋于0；而测试误差会先减小，达到最小值之后又增大。当选择的模型复杂度过大时，过拟合现象就会发生。<br><img src="/image/%E8%AE%AD%E7%BB%83%E8%AF%AF%E5%B7%AE%E5%92%8C%E6%B5%8B%E8%AF%95%E8%AF%AF%E5%B7%AE%E4%B8%8E%E6%A8%A1%E5%9E%8B%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="训练误差和测试误差与模型复杂度的关系"></p><h1 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h1><p>监督学习方法可以分为：生成方法（generative approach）和判别方法（discriminative approach），所学到的模型分别称为生成模型和判别模型。<br>生成方法有数据学习联合概率分布$P(X,Y)$，然后求出条件概率分布最为预测的模型，即生成模型： $P(Y|X) = \frac{P(X,Y)}{P(X)}$。</p><p>典型的生成方法包括：朴素贝叶斯法和隐马尔科夫模型。</p><p>生成方法的特点： </p><ol><li>生成方法可以还原出联合概率分布$P(X,Y)$， 而判别方法则不能；</li><li>生成方法的学习收敛速度更快，即当样本容量增加的时候，学到的模型可以更快地收敛于真实的模型；</li><li>当存在隐变量的时候，仍可以用生成方法学习，此时判别方法就不能用。</li></ol><p>判别方法由数据直接学习决策函数$f(X)$或者条件概率分布$P(Y|X)$作为预测的模型，即判别模型。</p><p>典型的判别方法包括：k近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、<br>提升方法和条件随机场等。</p><p>判别方法的特点：</p><ol><li>判别方法学习的是条件概率$P(Y|X)$或决策函数$f(X)$,直接面对预测，往往学习的准确率更高；</li><li>由于直接学习$P(Y|X)$或$f(X)$，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</li></ol><h1 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h1><p>分类是监督学习的一个核心问题。在监督学习中，当输出变量Y取有限个离散值时，预测问题便成为分类问题。<br>可以用于分类的统计学习方法包括：k近邻法、感知机、朴素贝叶斯法、决策树、决策列表、逻辑斯蒂回归模型、支持向量机、提升方法、贝叶斯网络、神经网络等。</p><h1 id="标注问题"><a href="#标注问题" class="headerlink" title="标注问题"></a>标注问题</h1><p>标注问题的输入是一个观测序列，输出是一个标记序列或状态序列。</p><p>标注常用的统计学习方法有：隐马尔科夫模型、条件随机场。</p><h1 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h1><p>回归（regression）用于预测输入变量和输出变量之间的关系。回归问题的学习等价于函数拟合：选择一条函数曲线使其很好地拟合已知数据且很好地预测未知数据。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>李航.统计学习方法.清华大学出版社.2012</li><li>Peter Harrington.机器学习实战.人民邮电出版社.2013</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paper Reading:《MINIMUM GENERATION ERROR TRAINING FOR HMM-BASED SPEECH SYNTHESIS》</title>
    <link href="/2014/12/30/paper_mge_based_traing_for_tts/"/>
    <url>/2014/12/30/paper_mge_based_traing_for_tts/</url>
    
    <content type="html"><![CDATA[<h1 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h1>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paper Reading：《TTS Synthesis with Bidirectional LSTM based Recurrent Neural Networks》</title>
    <link href="/2014/12/15/paper_rnn_tts/"/>
    <url>/2014/12/15/paper_rnn_tts/</url>
    
    <content type="html"><![CDATA[<h1 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h1><ul><li>作者：Yuchen Fan, Yao Qian, Fenglong Xie, Frank K. Soong</li><li>单位：上海交通大学，MSRA</li><li>会议：INTERSPEECH</li><li>发表日期： 2014</li><li>论文链接：<a href="https://mazsola.iit.uni-miskolc.hu/~czap/letoltes/IS14/IS2014/PDF/AUTHOR/IS140552.PDF" title="https://mazsola.iit.uni-miskolc.hu/~czap/letoltes/IS14/IS2014/PDF/AUTHOR/IS140552.PDF">https://mazsola.iit.uni-miskolc.hu/~czap/letoltes/IS14/IS2014/PDF/AUTHOR/IS140552.PDF</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>采用双向LSTM单元的RNN能够捕捉参数式语音合成中一个语音句子中的任意两时刻的相关性。</p><span id="more"></span><h1 id="DBLSTM-RNN"><a href="#DBLSTM-RNN" class="headerlink" title="DBLSTM RNN"></a>DBLSTM RNN</h1><p>LSTM（Long Short Term Memory）的结构如下图所示。LSTM能够解决传统RNN中的梯度消失问题。<br><img src="/paper_image/LSTM.png" alt="LSTM"><br>下图是双向RNN的结构，其能够访问前向和后向的上下文。<br><img src="/paper_image/Bidirectional_RNN.png" alt="Bidirectional RNN"></p><p>深层双向LSTM是深层双向RNN和LSTM的结合。</p><h1 id="基于RNN的语音合成"><a href="#基于RNN的语音合成" class="headerlink" title="基于RNN的语音合成"></a>基于RNN的语音合成</h1><p>下图是基于DBLSTM-RNN的语音合成系统框图。<br><img src="/paper_image/DBLSTM_RNN_TTS.png" alt="基于RNN的语音合成系统框图"></p><p>基于DBLSTM-RNN的语音合成系统中，丰富的上下文作为输入特征，包括二值特征（例如音子标记、词性标记等）和数值特征（例如短语中词的数目、当前帧在当前音子的位置）；输出特征就是声学特征，例如谱包络、基频。输入特征和输出特征是通过训练好的HMM做时间上帧级别的对齐。</p><p>在RNN的训练过程中，训练的准则是最小化输出特征和目标之间的均方根误差。BPTT（Back-propagation through time）是常用的算法。</p><p>在合成阶段，输入文本首先通过文本分析转换成输入特征向量，然后输入特征向量通过训练好的DBLSTM-RNN映射到输出特征向量。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><ul><li>数据：专业女性，美式英语语音数据，5000句（大约5小时）</li><li>输入特征：355维特征，其中319维是二值特征，其余是数值特征。</li><li>输出特征：清浊音标记、基频、LSP、增益，及其动态特征，共127维。</li><li>模型配置：<ul><li>HMM:MDL=1用于LSP和F0决策树生成</li><li>DNN：6个隐藏层，每个隐藏层512个节点</li><li>DNN_B：3个隐藏层，每个隐藏层1024个节点</li><li>Hybrid_A：DNN和BLSTM-RNN的混合，4个隐藏层，每个隐藏层512个节点，其中底部的3个隐藏层是利用sigmoid作为激活函数的前馈网络，上部的隐藏层是具有LSTM的双向RNN（256个前向节点和256个反向节点）</li><li>Hybrid_B：混合结构和Hybrid_A类似，但是底部的2层隐藏层是前馈结构，上部的2层隐藏层是BLSTM-RNN（256个前向节点和256个反向节点）</li></ul></li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h2 id="客观评价"><a href="#客观评价" class="headerlink" title="客观评价"></a>客观评价</h2><p>下表是客观评价的结果。<br><img src="/paper_image/RNN_object_evaluation.png" alt="客观评价结果"></p><h2 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h2><p><img src="/paper_image/RNN_subject_evaluation.png" alt="主观评价结果"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>实验结果表明，BLSTM-RNN和DNN的混合系统要优于基于HMM的系统和基于DNN的系统，主要原因是该混合系统能够捕捉到一个句子中的深层信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paper Reading： 《DEEP MIXTURE DENSITY NETWORKS FOR ACOUSTIC MODELING IN STATISTICAL PARAMETRIC SPEECH SYNTHESIS》</title>
    <link href="/2014/12/13/paper_mdn_speech_synthesis/"/>
    <url>/2014/12/13/paper_mdn_speech_synthesis/</url>
    
    <content type="html"><![CDATA[<h1 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h1><ul><li>作者：Heiga Zen, Andrew Senior</li><li>单位：Google</li><li>会议：ICASSP</li><li>发表日期： 2014</li><li>论文链接：<a href="https://wiki.inf.ed.ac.uk/twiki/pub/CSTR/Speak13To14/p3872-zen.pdf" title="https://wiki.inf.ed.ac.uk/twiki/pub/CSTR/Speak13To14/p3872-zen.pdf">https://wiki.inf.ed.ac.uk/twiki/pub/CSTR/Speak13To14/p3872-zen.pdf</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>利用深层神经网络（DNNs）的参数语音合成（SPSS），被证明具有生成自然的合成语音的能力。然而，语音合成中基于DNN的声学建模还有不足之处，例如目标函数是单峰的、缺少预测方差的能力。<br>为了解决这些局限，本文研究了利用混合密度的输出层，它能够在给定输入特征条件下，估计输出特征的全概率密度函数。实验的客观和主观结果表明利用混合密度输出层提高了预测的声学特征的准确性、以及合成语音的自然度。</p><span id="more"></span><p>然而，语音合成中基于DNN的声学建模有一些局限，本文解决了DNN的以下两个局限：</p><ol><li>基于DNN的声学模型，利用均方误差（Mean Squared Error，MSE）作为它的目标函数，不具有对比单高斯分布更复杂分布的建模能力。</li><li>一个人工神经网络（ANN）输出只提供了均值。统计参数语音合成中所使用的参数生成算法，需要声学特征的均值和方差，在静态和动态特征的约束下，来得到声学特征最大可能的轨迹。</li></ol><p>为了解决这些局限，本文研究了利用混合密度函数作为SPSS的声学模型。MSD能够在输入特征的条件下，给出输出特征的概率密度函数。MSD可以是多峰的回归，并且可以预测方差。</p><h1 id="基于MDN的语音合成"><a href="#基于MDN的语音合成" class="headerlink" title="基于MDN的语音合成"></a>基于MDN的语音合成</h1><p>MDN联合了一个混合模型和一个人工神经网络。本文利用了一个基于高斯混合模型的MDN。一个MDN M 将输入特征x映射到GMM的参数，这样就就给出了在输入特征条件下，输出特征y的全概率密度函数。<br><img src="/paper_image/MDN_pdf.png" alt="MDN"></p><p><img src="/paper_image/MDN_parameter.png" alt="MDN参数"><br>其中，$z_m^(w)$,$z_m^(\sigma)$,$z_m^(\mu)$是MDN输出层参数，分别是GMM中第m个分量的混合权重、方差、均值。</p><p>训练MDN的过程就是在给定数据条件下，最大化M的对数似然：<br><img src="/paper_image/MDN_model.png" alt="MDN的训练目标"></p><p>下图是基于深层MDN的语音合成的框图。首先，将输入文本转换成文本特征序列；第二，每个语音单元的时长通过一个时长预测模块得到；然后，在给定文本特征的条件下，利用训练好的DMDN，预测包括谱参数和激励参数以及它们的差分在内的声学特征的GMM；利用预测的GMM序列，使用语音参数生成算法，可以得到平滑的声学特征轨迹；最后，波形生成模块，对给定的声学特征输出合成的语音波形<br><img src="/paper_image/MDN_based_speech_synthesis.png" alt="基于MDN的语音合成"></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><ul><li>数据：专业女性，英语语音数据，33000句</li><li>输入特征：342维二值特征，用于类别上下文信息（例如音子ID、重音标记）；25维的数值特征，用于数值上下文信息（例如词中的音节数目、当前音节在短语中的位置）</li><li>输出特征：40维梅尔倒谱、对数基频、5带宽的非周期分量，以及他们的一阶、二阶差分，共3*（40+1+5）=138维</li><li>MDN：基于DNN系统的权重，通过最小化输出特征和预测值之间的均方误差来训练得到；基于MDN系统的权重，通过最大化给定训练数据条件下的模型对数似然来得到。</li></ul><h2 id="客观评价"><a href="#客观评价" class="headerlink" title="客观评价"></a>客观评价</h2><p><img src="/paper_image/MDN_object_evaluation.png" alt="客观指标"></p><h2 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h2><p><img src="/paper_image/MDN_subject_evaluation.png" alt="主观指标"></p><p>从表格中可以看到，具有方差对预测倒谱以及非周期分量有帮助，并且可以提高合成语音的自然度。GMM的多个分量，有助于基频的预测、以及提高合成语音的自然度。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文通过混合密度模型（MDNs）扩展了基于DNN的SPSS。基于DMDN的方法可以缓解语音合成中基于DNN的声学建模的局限：缺少方差，目标函数的单峰特性。客观和主观评价表明，具有方差和多个混合分量的混合密度输出层有助于提高预测声学特征的准确性，并且显著提高合成语音的自然度。</p><p>下一步工作包括探索更好的网络结构以及训练网络的优化算法。利用参数生成算法的DMDN的评价，也需要考虑到global variance。</p>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paper Reading:《STATISTICAL PARAMETRIC SPEECH SYNTHESIS USING DEEP NEURAL NETWORKS》</title>
    <link href="/2014/12/10/paper_dnn_speech_synthesis/"/>
    <url>/2014/12/10/paper_dnn_speech_synthesis/</url>
    
    <content type="html"><![CDATA[<h1 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h1><ul><li>作者：Heiga Zen, Andrew Senior, Mike Schuster</li><li>单位：Google</li><li>会议：ICASSP</li><li>发表日期： 2013</li><li>论文链接：<a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6639215" title="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6639215">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6639215</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>利用深层神经网络（Deep Neural Network,DNN）取代基于隐马尔科夫模型（Hidden Markov Models，HMMs）的语音合成中的决策树聚类和高斯混合模型（Guassian Mixture Models, GMMs），以提高声学建模的准确性。</p><span id="more"></span><p>参数式语音合成中影响语音合成质量的三个因素：</p><ul><li>声码器自身的局限</li><li>声学模型的准确性</li><li>过平滑问题</li></ul><p>该文章关注声学模型的准确性。</p><h1 id="决策树与DNN特性的比较"><a href="#决策树与DNN特性的比较" class="headerlink" title="决策树与DNN特性的比较"></a>决策树与DNN特性的比较</h1><ul><li>决策树不能有效表达文本特征中的复杂函数；DNN可以表示。</li><li>决策树依赖输入空间的分区，并且分别使用一组参数来对应一个分区；DNN有更好的泛化能力，它的权重是从所有的训练数据中训练得到的。</li><li>在训练阶段，利用反向传播算法训练DNN的计算量要远远大于构建决策树；在预测阶段，DNN需要在每一层做矩阵的乘法，决策树只需要从根节点遍历到叶子节点。</li><li>决策树可以提高可以解释的规则，而DNN中的权重则很难解释。</li></ul><h1 id="基于DNN的语音合成"><a href="#基于DNN的语音合成" class="headerlink" title="基于DNN的语音合成"></a>基于DNN的语音合成</h1><p><img src="/paper_image/DNN_based_speech_synthesis.png" alt="基于DNN的语音合成系统框图"></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><ul><li>数据：专业女性，英语语音数据，33000句</li><li>输入特征：342维二值特征，用于类别上下文信息（例如音子ID、重音标记）；25维的数值特征，用于数值上下文信息（例如词中的音节数目、当前音节在短语中的位置）</li><li>输出特征：40维梅尔倒谱、对数基频、5带宽的非周期分量，以及他们的一阶、二阶差分，共3*（40+1+5）=138维</li><li>DNN：权重随机初始化、基于小批量随机梯度下降（minibatch stochastic gradient descent，SGD）的反向传播算法、sigmoid作为激活函数<h2 id="客观评价"><a href="#客观评价" class="headerlink" title="客观评价"></a>客观评价</h2>客观指标包括：</li><li>Mel-cepstral distortion：谱参数的距离</li><li>Voiced/Unvoiced Error Rate：清浊音判断错误率</li><li>RMSE in log F0:基频在对数域上的均方误差</li><li>Aperiodicity distortion:非周期分量的距离</li></ul><p>下图分别展示出了在不同模型条件下的客观指标。<br><img src="/paper_image/object_evaluation.png" alt="客观评价"></p><h2 id="主观评价"><a href="#主观评价" class="headerlink" title="主观评价"></a>主观评价</h2><p><img src="/paper_image/subject_evaluation.png" alt="主观评价"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这篇文章利用DNN实现了语音合成。基于DNN的语音合成具有解决基于HMM的方法中决策树聚类的局限的潜力。</p><p>客观评价证明利用深层的结构提高了基于神经网络的系统的性能。另外，在相似的模型参数条件下，在主观的测听中，基于DNN的系统要比基于HMM的系统有更好的性能。</p><p>基于HMM的系统相比于基于DNN的系统的其中一个优点就是小的计算量。在合成阶段，基于HMM的系统遍历决策树来查找每个状态的统计量；另一方面，基于DNN的系统从输入到输出的映射包括在每一帧都有大量算术运算。</p><p>下一步的工作包括：减少基于DNN的系统的计算量；增加更多的输入特征，包括重音等这些弱特征；以及探索一个更好的对基频的建模方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习——在信号与信息处理中的应用</title>
    <link href="/2014/11/03/deep_learning/"/>
    <url>/2014/11/03/deep_learning/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>自从2006以来，深层结构学习，或者通常叫做深度学习（deep learning）、层次化学习（hierarchical learning），已经作为一个新的领域从机器学习中分离出来。</p><p><strong>深度学习有很多不同的定义：</strong></p><span id="more"></span><ul><li>定义1：一类利用多层非线性信息处理的机器学习技术，用于监督的和非监督的特征抽取和转换，以及模式分析和分类。</li><li>定义2：机器学习的一个子领域，基于学习多层次表示的算法，用于对数据中复杂的关系建模。</li><li>定义3：机器学习的一个子领域，基于学习不同层次的表示，与一个层次化的特征或因子或概念相关；其中，高层的概念定义于低层的，相同的低层次的概念有助于定义高层次的概念。</li><li>定义4：深度学习是机器学习研究的新领域，使得机器学习更加接近它最初的目标：人工智能。</li></ul><p><strong>现在，深度学习流行的三个重要的原因：</strong></p><ol><li>快速提升的芯片处理能力（比如通用图像处理单元，GPGPU）；</li><li>低成本的计算硬件；</li><li>机器学习和信号信息处理研究的最新进展。</li></ol><p><strong>深度学习成功应用的领域：</strong></p><ul><li>计算机视觉</li><li>音子识别</li><li>语音研究</li><li>传统的语音识别</li><li>语音和图像特征的编码</li><li>语义分类</li><li>手写体识别</li><li>信息检索</li><li>机器人</li><li>生物医药中的分子分析</li></ul><h1 id="深度学习的发展历程"><a href="#深度学习的发展历程" class="headerlink" title="深度学习的发展历程"></a>深度学习的发展历程</h1><p>到目前为止，大多的机器学习和信号处理技术都是利用浅层的结构。这些浅层结构最多包含1层或者2层的非线性特征转换。</p><p><strong>这些浅层结构包括：</strong></p><ul><li>高斯混合模型(Gaussian Mixture Models, GMMs)</li><li>条件随机场(Conditional Random Fields, CRFs)</li><li>最大熵模型(Maximum Entropy Models, MaxEnt)</li><li>支持向量机(Support Vector Machines, SVMs)</li><li>逻辑回归(Logistic Regression)</li><li>核回归(Kernel Regression)</li><li>多层感知机(Multi-Layer Preceptrons, MLPs)</li><li>极限学习机(Extreme Learning Machine, ELMs)</li></ul><p>人类的信息处理机制（比如视觉、听觉），都需要利用深层的体系结构来抽取复杂的结构，并且从丰富的感知输入中构建内在表示。</p><p>从历史角度来看，深度学习的概念最初是从人工神经网络的研究发展而来的。前馈神经网络、多层感知机含有多个隐层，都被认为是深层神经网络（DNNs），也是深层结构的典型代表。</p><p><strong>深层模型中优化难题的解决，依靠三种技术：</strong></p><ul><li>更大数目的隐藏层节点数目；</li><li>更好的学习算法；</li><li>更好的参数初始化技术。</li></ul><p>DNN中使用更多节点的隐藏层，可以显著地提升模型能力并且能够具有更多接近最优的参数配置。即便参数学习陷入局部最优，DNN的结果仍然表现得很好，因为陷入较差的局部最优的机会要比神经网络中使用少量神经元的时候小。但是，使用更深层、更宽的神经网络会在训练阶段要求更多的计算量，这也是为什么直到最近，研究人员才开始认真地探索研究更深、更宽的神经网络。</p><p>更好的学习算法有助于DNN的成功。比如，随机BP算法现在取代了批量模式的BP算法，用于DNN的训练。一部分原因是，当训练时在一台机器上进行、并且训练集很大的时候，随机梯度下降（SGD）算法是最有效的算法。但是，更为重要的是，随机梯度算法能够从局部最优跳出来，这得益于从单个样本或者一组样本中估计出来的噪声梯度（noisy gradients）。其他的算法，比如Hessian Free或者Krylov subspace 方法具有类似的能力。</p><p>对于DNN的非凸优化问题，显然更好的参数优化技术会得到更好的模型，因为优化是从初始化模型开始的。DNN参数初始化技术中最引人注目的是Hinton在2006年提出的无监督的预训练技术。这一类论文中，深层贝叶斯概率生成模型，叫做深度置信网络（DBN）被提出来。除了非监督预训练方法，监督预训练，有时候也称为区分式预训练也被证明是有效的。</p><h1 id="深度学习的三类结构"><a href="#深度学习的三类结构" class="headerlink" title="深度学习的三类结构"></a>深度学习的三类结构</h1><h2 id="深层结构的三种类型："><a href="#深层结构的三种类型：" class="headerlink" title="深层结构的三种类型："></a>深层结构的三种类型：</h2><ul><li>生成式深层结构：旨在捕获观测、可视数据的高阶关系，用于模式分析或者合成；或者刻画可视数据以及它们相关的类别的联合统计分布。在后一种情况下，贝叶斯规则的使用能够将该类型的结构转变成判别式。</li><li>判别式深层结构：旨在直接提供用于模式分类的判别能力。</li><li>混合式深层结构：目标是判别，并且在通过更好的优化或者正则化的生成式结构的帮助下。或者是，在上面的第一种类型的任何深层结构中，判别准则用来学习参数。</li></ul><p><strong>基本的深度学习术语：</strong></p><ul><li>深度置信网络(Deep Belief Network, DBN)：包含多个隐藏层的统计生成模型。最高的两层之间是无向、对称的连接。较低的低层从高层接收从上到下的有向连接。</li><li>玻尔兹曼机(Boltzmann Machine, BM)：一种对称连接的网络，像神经元那样，随机决定是开启还是关闭。</li><li>受限玻尔兹曼机(Restricted Boltzmann Machine, RBM)：一种特殊的BM，包含一个可见层、一个隐藏层，可见层单元之间、隐藏层单元之间没有连接。</li><li>深度神经网络(Deep Neural Network, DNN):一种多层感知机，具有多个隐藏层，权重全连接，使用无监督或者有监督的预训练技术。</li><li>深层自编码(Deep auto-encoder)</li><li>分布表示(Distributed representation)</li></ul><h2 id="生成式深层结构"><a href="#生成式深层结构" class="headerlink" title="生成式深层结构"></a>生成式深层结构</h2><p>在生成式深层结构的不同子类中，基于能量的深层模型是最常见的。</p><p>另一种典型的生成式模型是深层玻尔兹曼机，简称为DBM。DBM包含多个隐层，并且相同层的变量之间没有连接。</p><p>另一个有代表性的深层生成式结构是sum-product network(SPN)。</p><p>循环神经网络（RNNs）也是另外一中重要的深层生成式结构，它的深度可以和输入数据序列的长度一样大。RNNs对于序列数据有很好的建模能力，但是直到最近才被广泛应用，一部分原因是他们由于“梯度爆炸”问题而十分地难以训练。</p><h2 id="判别式深层结构"><a href="#判别式深层结构" class="headerlink" title="判别式深层结构"></a>判别式深层结构</h2><p>大多数信号和信息处理的判别式技术是浅层结构，比如隐马尔科夫模型、条件随机场。</p><p>就像之前讨论过的那样，RNNs已经被成功用作生成式模型。RNNs也可以用于判别式模型，其中输出是和输入数据序列相关的标记序列。</p><p>另一种判别式深层结构是卷积神经网络（CNN），其中的每个模块都包含一个卷积层和一个pooling层。CNN已经被发现是很有效的，并且已经被广泛应用在计算机视觉和图像识别中。</p><h2 id="混合式深层结构"><a href="#混合式深层结构" class="headerlink" title="混合式深层结构"></a>混合式深层结构</h2><p>混合式主要是指深层结构同时包含或者利用了生成式和判别式的模型。在已经发表的关于混合式深层结构中，生成式部分大都被用来帮助判别，这也是混合式结构的最终目标。生成式建模是如何帮助、为什么会帮助判别，可以从两种角度来看：</p><ul><li>从优化的角度来看，生成式模型可以为非线性问题提高很好的初始点，也是这个原因，深度学习中经常会使用预训练。</li><li>从正则化的角度看，生成式模型可以有效地控制模型的复杂度。</li></ul><p>DBN，作为生成式深度结构，可以转换、用于具有相同网络结构的DNN的初始模型，DNN进一步进行判别式训练或者调优。</p><p>另外一个混合式深层结构的例子是，DNN的权重也是从生成式的DBN初始化而来，但是使用序列级别的判别准则，而不是常用的帧级别的准则。</p><p>更进一步的混合式深层结构的例子是利用生成式模型对深层卷积神经网络（deep CNNs）做预训练。就像全连接的DNN，预训练相比于随机初始化，会帮助提高深层CNN的性能。</p><p>混合式深度结构的最后一个例子是语音翻译，其中，一个任务是判别式的（语音识别），得到的输出（文本）作为输入服务于第二个判别任务（机器翻译）。整个系统实现了语音翻译：从一种语言的语音翻译到另外一种语言的文本，这是一个包含生成式和判别式的两个阶段的深层结构。语音识别和机器翻译的模型都是生成式的，但是，他们学习到的参数都是用来做判别。</p><h1 id="生成式：深层自编码"><a href="#生成式：深层自编码" class="headerlink" title="生成式：深层自编码"></a>生成式：深层自编码</h1><p>深层自编码是DNN的一种特例，他的输出和输入有相同的维度，在隐藏层可以有效地编码和表示原始的数据。值得注意的是，自编码是非线性的特征提取方法，并且不需要使用类别标记。特征提取旨在保存信息而不是完成分类任务，尽管有时候这两种目标是相关的。</p><h2 id="深层自编码抽取语音特征"><a href="#深层自编码抽取语音特征" class="headerlink" title="深层自编码抽取语音特征"></a>深层自编码抽取语音特征</h2><h2 id="堆栈去噪自编码"><a href="#堆栈去噪自编码" class="headerlink" title="堆栈去噪自编码"></a>堆栈去噪自编码</h2><p>在大多数的应用中，自编码中的编码层的维度要比输入层的小。但是，在一些应用中，我们期望编码层比输入层宽，在这种情况下就是要防止神经网络学习微小特征的映射函数。</p><p>举例来说，在堆栈去噪自编码中，在输入数据中加入了随机噪声。这样做有几个目的：第一，通过强制将输出与原始不失真的输入数据匹配，能够避免模型学习到微小特征的答案；第二，由于加入了随机噪声，模型的学习会对测试数据中相同的失真鲁棒；第三，由于每个失真的输入样本是不同的，这就很大程度上增加了训练集，这样能够消除过拟合问题。</p><h2 id="转换自编码"><a href="#转换自编码" class="headerlink" title="转换自编码"></a>转换自编码</h2><h1 id="混合式：预训练深层神经网络"><a href="#混合式：预训练深层神经网络" class="headerlink" title="混合式：预训练深层神经网络"></a>混合式：预训练深层神经网络</h1><h1 id="判别式：深层堆网络及其变体"><a href="#判别式：深层堆网络及其变体" class="headerlink" title="判别式：深层堆网络及其变体"></a>判别式：深层堆网络及其变体</h1><p>虽然DNN已经证明在识别和分类任务上，包括语音识别和图像分类，有非常强的能力，但是训练一个DNN模型在计算量上是非常大的。特别地，传统训练DNN的技术，在调优阶段利用随机梯度下降算法，这在机器上进行并行计算是非常困难的。这里，我们提出了一个新的深度学习结构，深层堆栈网络（Deep Stacking Network,DSN），用来解决学习可扩展性问题。</p><p>DSN设计的核心思想和堆栈的概念相关，最初在（Wolpert,1992）提出，就是说函数或者分类器的简单模块首先组合，然后相互之间的顶端堆栈起来，用来学习复杂的函数和分类器。</p><h1 id="在语音识别中的应用"><a href="#在语音识别中的应用" class="headerlink" title="在语音识别中的应用"></a>在语音识别中的应用</h1><p>传统的神经网络已经在语音识别中使用了很多年了。单独使用神经网络的时候，它的性能远不如性能先进的利用GMM对观测概率近似的HMM系统。</p><p>有实验已证明三音子的DNN-HMM的性能显著优于最先进的HMM系统。三个因素帮助DNN成功：使用三音子作为DNN的建模单元，使用可靠的三音子GMM-HMM生成每个状态的边界，调整跳转概率。</p><p>除了RBM、DNN和DSN，其他一些深层模型也被用来做语音处理和相关的应用。比如，深层CRF，堆叠了很多层CRF，已经成功应用于语言的辨别、音子识别、自然语言处理中的序列标注、语音识别中的置信校准等任务。更进一步，RNN早就成功应用到了音子识别，因为训练的复杂度，它不容易被复现到语音识别任务中。之后，RNN的学习算法得到了显著的提升，最近利用RNN也取得了更好的结果。RNN也被用到了音乐处理中，其中利用“rectified linear”隐藏层单元，取代了“logistic”和“tanh”非线性单元。Rectified linear units计算函数y=max(x,0),这就可以产生稀疏的梯度，减少了RNN中不利因素的扩散，并且可以更快地训练。</p><h1 id="在语言模型中的应用"><a href="#在语言模型中的应用" class="headerlink" title="在语言模型中的应用"></a>在语言模型中的应用</h1><p>语言模型使用浅层神经网络已经有很长的历史了，语言模型是语音识别、机器翻译、文本信息检索、以及自然语言处理的重要组成成分。语言模型是一个捕获自然语言中词序列分布的显著统计特性的函数。一个基于神经网络语言模型利用神经网络的能力来学习分布表示，从而减少维度灾难带来的影响。</p><p>统计语言模型的优点：对没有出现在训练序列中的序列有较好的泛化能力。因为神经网络趋向于将相近的输入映射到相近的输出，对具有相似特征的词序列的预测会映射到相似的预测。</p><p>利用RNN构建大尺度的语言模型，在训练RNN的过程中获取了不断增加的梯度，实现了训练过程的稳定和快速收敛。</p><h1 id="在自然语言处理中的应用"><a href="#在自然语言处理中的应用" class="headerlink" title="在自然语言处理中的应用"></a>在自然语言处理中的应用</h1><p>在自然语言处理的出名的或者有争议的工作中，Collobert和Weston (2008)实现一个卷积DBN作为通用模型，来解决一系列经典问题，包括词性标注、分词、命名实体识别、语义角色标注、相似词判断。</p><p>前人的工作中一个重要的方面是，通过神经网络的子层，实现从具有很高维度的稀疏向量的原始的词表示到一个低维的、实数向量表示的转换。这就是“word embedding”：目前广泛应用到自然语言处理和语言建模中。</p><p>最近一项有趣的利用深度学习实现自然语言处理的工作出现在(Socher et al., 2011)，一个递归神经网络（recursive neural network）用来构建深层结构。这种深度学习方法提供了在自然语言分析上的极好的表现。</p><h1 id="在信息检索中的应用"><a href="#在信息检索中的应用" class="headerlink" title="在信息检索中的应用"></a>在信息检索中的应用</h1><p>这里我们讨论DBN在文档索引和信息检索中很有趣的应用（Salakhutdinov and Hinton, 2007; Hinton and Salakhutdinov, 2010）。DBN的最后一层不仅容易推断，并且相比于信息检索中已经广泛使用的潜在语义分析和传统的TF-IDF方法，能够给出每个文档一个基于词频特征的更好的表示。一个深层的生成模型DBN用于上述目的。简而言之，DBN中最低的层表示词频的向量，高的层次表示文档的紧凑的二值编码。</p><p>模型训练好之后，检索的过程开始于将每个查询文档映射到一个128bit的二值编码，通过模型的前馈、根据门限而得到。之后，计算查询二值编码和所有其他文档的128比特二值编码的汉明距离。</p><p>上述信息检索中对于文本文档编码的想法，已经在音频文档和语音特征编码问题上开始探索。</p><h1 id="在图像、视觉、多任务处理的经典应用"><a href="#在图像、视觉、多任务处理的经典应用" class="headerlink" title="在图像、视觉、多任务处理的经典应用"></a>在图像、视觉、多任务处理的经典应用</h1><p>原始的DBN和深层自编码被成功应用到图像识别和降维（编码）任务上（MNIST）。两种策略用来提高DBN的鲁棒性：第一，DBN的第一次以稀疏方式连接，作为正则化模型的一种方式；第二，概率去噪算法的发展。DBN也被成功应用到对图像创建紧致并且有意义的表示，用来进行检索。</p><p>具有卷积结构的深层结构，已经被发现能够有效、并且广泛应用在计算机视觉和图像识别中。</p><p>具有多任务学习能力的DNN应用到多语种语音识别。这些结构背后的想法是：DNN中的隐藏层，进行适当地学习后，在不同语言的声学数据中共享隐藏层因子的条件下，可以作为复杂特征的转换。多任务学习方法能够完全不需要无监督预训练步骤，能够用更少的轮数来训练DNN。<br><img src="/image/multi-task_learning.png" alt="多任务学习的DNN结构"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>深度学习是一种新兴的技术。尽管已经有令人兴奋的结果报告出来，但是还有很多需要去做。重要的是，还没有深度学习的研究人员的经验表明，单一的深度学习算法能够成功应用到所有的分类任务中。</p><p>最近几年，机器学习越来越依赖于大规模数据集。深度学习算法表现的好坏将依赖于数据的数量和计算能力。</p><p>DNN的使用以及相关的深度模型的一个主要障碍是：它们需要相当的知识和技巧去选择超参数，比如学习率、正则化的力度、隐藏层数目、每层的节点数等等。</p><p>最后，需要在很多方面建立深度学习的坚实的理论基础。比如说，深度学习在无监督学习中的成功应用还没有像有监督学习那样得到证明。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>Li Deng and Dong Yu. Deep Learning for Signal and Information Processing. 2013</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>朴素贝叶斯（naive Bayes）</title>
    <link href="/2014/10/28/ml_naive_bayes/"/>
    <url>/2014/10/28/ml_naive_bayes/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。其基本的思路是：对于给定的训练数据集，首先基于特征条件独立假设学习输入和输出的联合概率分布，然后基于该模型，对于给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。<br>朴素贝叶斯法实现简单，学习和预测的效率都很高，是一种比较常用的方法。</p><h1 id="朴素贝叶斯法"><a href="#朴素贝叶斯法" class="headerlink" title="朴素贝叶斯法"></a>朴素贝叶斯法</h1><p>朴素贝叶斯法是典型的生成学习方法。<br>输入空间$X$，输出空间$Y$，由训练数据学习联合概率分布$P(X,Y)$，然后求得后验概率分布$P(Y|X)$</p><h2 id="条件独立性假设"><a href="#条件独立性假设" class="headerlink" title="条件独立性假设"></a>条件独立性假设</h2><p>条件概率分布<br>$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},\ldots,X^{(n)}=x^{(n)}|Y=c_k), k=1,2,\ldots,K$</p><p>朴素贝叶斯法对条件概率分布作了条件独立性的假设：<br>$P(X=x|Y=c_k)$</p><p>$=P(X^{(1)}=x^{(1)},\ldots,X^{(n)}=x^{(n)}|Y=c_k)$</p><p>$=\prod^n_{j=1} P(X^{(j)}|Y=c_k)$<br>由于这一假设，模型的条件概率的数量大为减少，朴素贝叶斯法的学习与预测就简化了很多，并且容易实现。然而，这也导致分类的性能不是很高。</p><h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2><p>朴素贝叶斯法利用贝叶斯定理与学到的联合概率模型进行分类预测。</p><p>$P(Y|X) = \frac{P(X,Y)}{P(X)}=\frac{P(Y)P(X|Y)}{\sum_YP(P(Y)P(X|Y))}$</p><p>对输入x得到后验概率最大的类y</p><p>$y=\arg \max_{c_k}P(Y=c_k)P(X_j=x^{(j)}|Y=c_k)$</p><p>$y=\arg \max_{c_k}P(Y=c_k) \prod_j P(X_j=x^{(j)}|Y=c_k)$</p><span id="more"></span><h1 id="朴素贝叶斯法的参数估计"><a href="#朴素贝叶斯法的参数估计" class="headerlink" title="朴素贝叶斯法的参数估计"></a>朴素贝叶斯法的参数估计</h1><p>概率估计方法有两种：极大似然估计；贝叶斯估计。</p><h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><p>先验概率$P(Y=c_k)$的极大似然估计<br>$P(Y=c_k)=\frac{\sum^N_i I(y_i=c_i)}{N},k=1,2,\ldots,K$</p><h2 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h2><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>已知若干人的性别、身高和体重，给定身高和体重判断性别。考虑使用朴素贝叶斯法实现性别的分类。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据集合：<a href="https://github.com/shuaijiang/FemaleMaleDatabase" title="https://github.com/shuaijiang/FemaleMaleDatabase">https://github.com/shuaijiang/FemaleMaleDatabase</a></p><p>该数据集包含了训练数据集和测试数据集，考虑在该数据集上利用朴素贝叶斯法实现性别的分类。</p><p>将训练数据展示到图中，可以更加直观地观察到数据样本之间的联系和差异，以及不同性别之间的差异。<br><img src="/image/male_female.png" alt="数据展示"></p><h2 id="朴素贝叶斯的分类结果"><a href="#朴素贝叶斯的分类结果" class="headerlink" title="朴素贝叶斯的分类结果"></a>朴素贝叶斯的分类结果</h2><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>朴素贝叶斯源代码：<a href="https://github.com/shuaijiang/naive_bayes">https://github.com/shuaijiang/naive_bayes</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>李航. 统计学习方法.清华大学出版社.2012</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K近邻法与k-means</title>
    <link href="/2014/10/18/knn_kmeans/"/>
    <url>/2014/10/18/knn_kmeans/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>K近邻法（knn）是一种基本的分类与回归方法。k-means是一种简单而有效的聚类方法。虽然两者用途不同、解决的问题不同，但是在算法上有很多相似性，于是将二者放在一起，这样能够更好地对比二者的异同。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><h2 id="knn"><a href="#knn" class="headerlink" title="knn"></a>knn</h2><p>算法思路：<br>如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p><p>k近邻模型的三个基本要素：</p><ol><li>k值的选择：k值的选择会对结果产生重大影响。较小的k值可以减少近似误差，但是会增加估计误差；较大的k值可以减小估计误差，但是会增加近似误差。一般而言，通常采用交叉验证法来选取最优的k值。</li><li>距离度量：距离反映了特征空间中两个实例的相似程度。可以采用欧氏距离、曼哈顿距离等。</li><li>分类决策规则：往往采用多数表决。</li></ol><h2 id="k-means"><a href="#k-means" class="headerlink" title="k-means"></a>k-means</h2><p>算法步骤：</p><ol><li>从n个数据中随机选择 k 个对象作为初始聚类中心；</li><li>根据每个聚类对象的均值（中心对象），计算每个数据点与这些中心对象的距离；并根据最小距离准则，重新对数据进行划分；</li><li>重新计算每个有变化的聚类簇的均值，选择与均值距离最小的数据作为中心对象；</li><li>循环步骤2和3，直到每个聚类簇不再发生变化为止。</li></ol><p>k-means方法的基本要素：</p><ol><li>k值的选择：也就是类别的确定，与K近邻中k值的确定方法类似。</li><li>距离度量：可以采用欧氏距离、曼哈顿距离等。<span id="more"></span></li></ol><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>已知若干人的性别、身高和体重，给定身高和体重判断性别。考虑使用k近邻算法实现性别的分类，使用k-means实现性别的聚类。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据集合：<a href="https://github.com/shuaijiang/FemaleMaleDatabase" title="https://github.com/shuaijiang/FemaleMaleDatabase">https://github.com/shuaijiang/FemaleMaleDatabase</a></p><p>该数据集包含了训练数据集和测试数据集，考虑在该数据集上利用k近邻算法和k-means方法分别实现性别的分类和聚类。</p><p>将训练数据展示到图中，可以更加直观地观察到数据样本之间的联系和差异，以及不同性别之间的差异。<br><img src="/image/male_female.png" alt="数据展示"></p><h2 id="KNN的分类结果"><a href="#KNN的分类结果" class="headerlink" title="KNN的分类结果"></a>KNN的分类结果</h2><p>KNN算法中的基本设置</p><ul><li>k=5</li><li>距离度量：欧氏距离</li><li>分类决策规则：多数投票</li><li>测试集：<a href="https://github.com/shuaijiang/FemaleMaleDatabase/blob/master/test0.txt" title="test0">https://github.com/shuaijiang/FemaleMaleDatabase/blob/master/test0.txt</a></li></ul><p>利用KNN算法，在测试集上的结果如下混淆矩阵表所示。从表中可以看出，测试集中的男性全部分类正确，测试集中的女性有一个被错误分类，其他都分类正确。</p><blockquote><table border="1" align="center" valign="center">  <tr><th>混淆矩阵</th><td>Test:male</td><td>Test:female</td></tr>    <tr><td>Result:male</td><td align="center">20</td><td align="center" >1</td></tr>  <tr><td>Result:female</td><td align="center">0</td><td align="center">14</td></tr> </table></blockquote><p>（表注：Test:male、Test:female分别表示测试集中的男性和女性，Result:male和Result:female分别表示结果中的男性和女性。表格中第一个元素：即Test:male列、Result：male行，表示测试集中为男性、并且结果中也为男性的数目。表格中其他元素所代表的含义以此类推）<br>由上表可以计算分类的正确率：(20+14)/(20+14+1) = <strong>97.14%</strong></p><h2 id="K-means的聚类结果"><a href="#K-means的聚类结果" class="headerlink" title="K-means的聚类结果"></a>K-means的聚类结果</h2><p>K-means算法的基本设置</p><ul><li>k=2</li><li>距离度量：欧氏距离</li><li>最大聚类次数：200</li><li>类别决策规则：根据每个聚类簇中的多数决定类别</li><li>测试集：<a href="https://github.com/shuaijiang/FemaleMaleDatabase/blob/master/test0.txt">https://github.com/shuaijiang/FemaleMaleDatabase/blob/master/test0.txt</a></li></ul><blockquote><table border="1" align="center" valign="center">  <tr><th>混淆矩阵</th><td>Test:male</td><td>Test:female</td></tr>    <tr><td>Result:male</td><td align="center">20</td><td align="center" >1</td></tr>  <tr><td>Result:female</td><td align="center">0</td><td align="center">14</td></tr> </table></blockquote><p>（表注：该表与上表内容一致）</p><p>由于选择初始中心点是随机的，所以每次的聚类结果都不相同，最好的情况下能够完全聚类正确，最差的情况下两个聚类簇没有分开，根据多数投票决定类别时，被标记为同一个类别。</p><h1 id="KNN-VS-K-means"><a href="#KNN-VS-K-means" class="headerlink" title="KNN VS K-means"></a>KNN VS K-means</h1><p>二者的相同点:</p><ul><li>k的选择类似</li><li>思路类似：根据最近的样本来判断某个样本的属性</li></ul><p>二者的不同点：</p><ul><li>应用场景不同：前者是分类或者回归问题，后者是聚类问题;</li><li>算法复杂度： 前者O（n^2）,后者O（kmn）;（k是聚类类别数，m是聚类次数）</li><li>稳定性：前者稳定，后者不稳定。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文概括地描述了K近邻算法和K-means算法，具体比较了二者的算法步骤。在此基础上，通过将两种方法应用到实际问题中，更深入地比较二者的异同，以及各自的优劣。本文作者还分别实现了K近邻算法和K-means算法，并且应用到了具体问题上，最后得到了结果。<br>以上内容难免有所纰漏和错误，欢迎指正。</p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><ul><li>KNN: <a href="https://github.com/shuaijiang/KNN">https://github.com/shuaijiang/KNN</a></li><li>k-means: <a href="https://github.com/shuaijiang/k-means">https://github.com/shuaijiang/k-means</a></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>李航. 统计学习方法.清华大学出版社.2012</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Perl过滤、复制文件</title>
    <link href="/2014/10/16/perl_filter_file/"/>
    <url>/2014/10/16/perl_filter_file/</url>
    
    <content type="html"><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>从指定的目录中，根据文件列表，将文件复制到指定的目录中。</p><p>注意：文件列表没有指定文件后缀，输入参数中要指定文件后缀。</p><h1 id="核心部分：复制文件"><a href="#核心部分：复制文件" class="headerlink" title="核心部分：复制文件"></a>核心部分：复制文件</h1><h2 id="样例（demo）"><a href="#样例（demo）" class="headerlink" title="样例（demo）"></a>样例（demo）</h2><pre><code class="hljs">use File::Copy;copy(&quot;sourcefile&quot;,&quot;destinationfile&quot;) or die &quot;Copy failed: $!&quot;;</code></pre><h2 id="介绍（description）"><a href="#介绍（description）" class="headerlink" title="介绍（description）"></a>介绍（description）</h2><p>copy函数需要两个参数:复制源文件和复制目标文件。每个参数都可以是字符串，也可以是文件句柄引用或者文件句柄。</p><p>原文：（<a href="http://perldoc.perl.org/File/Copy.html">http://perldoc.perl.org/File/Copy.html</a>）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>源代码文件下载：<a href="https://github.com/shuaijiang/PerlScript/blob/master/filter.pl">https://github.com/shuaijiang/PerlScript/blob/master/filter.pl</a></p><pre><code class="hljs">#!/bin/perl#This Perl script is copy files from given source directory to #given target directory according to given scp#Author: shuaijiang#Email: zhaoshuaijiang8@gmail.comuse strict;use File::Copy;if($#ARGV != 3)&#123;    print &quot;Usage: perl file.pl scp source_path target_path suffix\n&quot;;    exit;&#125;my $scp = $ARGV[0];my $source_path = $ARGV[1];my $target_path = $ARGV[2];my $suffix = $ARGV[3];open(SCP,&quot;&lt;$scp&quot;) or die &quot;Can&#39;t open $!\n&quot;;while (&lt;SCP&gt;) &#123;    chomp;    my $file = $_;    my $source_file = $source_path . &#39;/&#39; . $file . $suffix;    my $target_file = $target_path . &#39;/&#39; . $file . $suffix;    print &quot;source_file=$source_file target_file=$target_file\n&quot;;    copy(&quot;$source_file&quot;,&quot;$target_file&quot;) or die &quot;Copy file failed!\n&quot;;&#125;close(SCP);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Perl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《信息简史》读书笔记</title>
    <link href="/2014/06/04/the_information/"/>
    <url>/2014/06/04/the_information/</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>之前就有人推荐《信息简史》这本书，趁京东周年庆打折，就买了下来。作为计算机方向的小硕，自然不能错过了这方面的好书。<br>有很多业内知名人士推荐，有的还做了序，但是这些都掩盖不了原作者的低调和内涵。</p><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>从香农的信息论开始说起。香农提出了比特这一概念，是用来测量信息的基本单位。从此之后，人类社会与以往任何时候大大不同了，人类迈入了影响至今的信息时代。<br><img src="/mindmap/information.png" alt="思维导图-信息"></p><span id="more"></span><h1 id="会说话的鼓——似是而非的编码"><a href="#会说话的鼓——似是而非的编码" class="headerlink" title="会说话的鼓——似是而非的编码"></a>会说话的鼓——似是而非的编码</h1><p>用鼓来传递信息，在古老的非洲大地，鼓就是“音乐通信的工具”。鼓和移动电话都是传递着声音，传递着信息，但是鼓却渐渐没落，渐渐被移动电话所取代。<br><img src="/mindmap/chapter1.png" alt="思维导图-会说话的鼓"></p><h1 id="持久的文字"><a href="#持久的文字" class="headerlink" title="持久的文字"></a>持久的文字</h1><p>文字作为一种载体，传承着人类千百年不断发展的文化，承载着人类智慧和创造的结晶，也见证了历史的兴衰起伏。即便是在信息技术发达的今天，文字依然具有其特有的活力和不可取代的地位。在这一章中，作者以其宽广的视角和独特的见解，向我们展示了文字的故事。<br><img src="/mindmap/chapter2.png" alt="思维导图-持久的文字"></p><hr><p>未完，持续更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>信息浪潮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈语音合成方法</title>
    <link href="/2014/05/21/speech_synthesis_methods/"/>
    <url>/2014/05/21/speech_synthesis_methods/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>从整个语音合成的发展历史来看，早期的机械式语音合成器反映了人们对语音产生机理了解得比较粗略，现代语音合成方法基本上都是采用一种语音模型来合成语音。近期的语音合成方法可以归纳为四种：1.物理机理语音合成；2.源-滤波器语音合成；3.基于波形拼接技术的语音合成；4.可训练的语音合成。5.基于神经网络的语音合成。</p><span id="more"></span><h1 id="物理机理语音合成"><a href="#物理机理语音合成" class="headerlink" title="物理机理语音合成"></a>物理机理语音合成</h1><p>物理机理语音合成方法是通过对人产生语音的物理结构进行建模，从而产生语音，比如，对发音过程中嘴唇、牙齿、下巴等运动进行建模。</p><p>近来，因为难以将它在现阶段推向实用，物理机理语音合成的研究受到制约。主要原因在于两个方面：一是对语音产生过程中发声器官的运动和变换进行度量非常困难；第二个原因是模型复杂、计算量非常大，相比于源-滤波器的语音合成模型，对声道气流特征和运动轨迹的数学建模非常复杂而且计算量非常大。</p><h1 id="源-滤波器语音合成"><a href="#源-滤波器语音合成" class="headerlink" title="源-滤波器语音合成"></a>源-滤波器语音合成</h1><p>源-滤波器语音合成基于这样一种声学理论，这种理论认为声音由激励和相应的滤波器形成。其中激励主要分为两种：一种是类似噪声的激励，主要形成非浊音语音信号；另一种是周期性的激励，主要生产浊音信号。</p><p>在该方式里，音库中预先存放各种语音合成单元的声道参数，这些参数根据控制规则的要求进行修正，以合成出各种语言环境下的语音。源-滤波器语音合成的结构框图，如下图所示。<br><img src="/image/source_fliter_synthesis.png" alt="源-滤波器语音合成结构框图"></p><p>在基于源-滤波器的参数合成中，合成器的工作流程可以分为三步：</p><ol><li>首先根据待合成音节的声调特性构造出相应的声门波激励源；</li><li>然后再根据协同发音、速度变换（时长参数）等音变信息在原始声道的基础上构造出新的声道参数模型；</li><li>最后将声门波激励源送入新的声道模型中，其输出就是符合给定韵律特性的合成语音。</li></ol><p>LPC（线性预测分析）合成器和共振峰合成器是基于源-滤波器的参数合成器中最常用的两种方法。</p><h2 id="LPC合成器"><a href="#LPC合成器" class="headerlink" title="LPC合成器"></a>LPC合成器</h2><p>线性预测合成（LPC）以线性预测误差滤波器为基础来模拟声道。</p><h2 id="共振峰合成器"><a href="#共振峰合成器" class="headerlink" title="共振峰合成器"></a>共振峰合成器</h2><p>把人的声道模型看成一个谐振波，语音信号的共振峰特性由这个腔体的谐振频率来表征，这种合成方法叫做共振峰合成。</p><h1 id="基于波形拼接技术的语音合成"><a href="#基于波形拼接技术的语音合成" class="headerlink" title="基于波形拼接技术的语音合成"></a>基于波形拼接技术的语音合成</h1><p>波形拼接合成方法的基本原理就是根据输入文本分析得到的信息，从预先录制和标注好的语音库中挑选合成的单元，进行少量的调整（也可以不调整），然后拼接得到最终的合成语音。其中用来进行单元挑选的信息可以是前端分析得到的韵律文本，也可以是生成的声学参数，或者二者兼有。由于最终合成语音中的单元都是直接从音库中复制过来的，其最大优势就是在于保持了原始发音人的音质。</p><h1 id="可训练的语音合成"><a href="#可训练的语音合成" class="headerlink" title="可训练的语音合成"></a>可训练的语音合成</h1><p>可训练的语音合成（Trainable TTS）的基本思想就是基于一套自动化的流程，根据输入的语音数据进行训练，并形成一个相应的合成系统。</p><p>在语音信号处理中，最普遍有效的建模方式就是隐马尔科夫模型（Hidden Markov Models, HMM），它在语音识别中已经有非常成熟的应用，目前的Trainable TTS也都是基于HMM进行参数建模。</p><h1 id="基于神经网络的语音合成"><a href="#基于神经网络的语音合成" class="headerlink" title="基于神经网络的语音合成"></a>基于神经网络的语音合成</h1><p>2006年，Hinton等人提出深度学习的概念，深度学习在不同领域得到了很好的应用，并且也取得了不错的效果。2012年，Hinton等人就利用深度神经网络对语音识别进行声学建模。2013年，Zen等人实现了基于深度神经网络的参数式语音合成。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随着计算机处理能力的不断提高，目前主要流行的是可训练的语音合成，并且为了提高合成语音的音质，一般会采用混合式语音合成方法，即基于HMM的单元挑选和波形拼接语音合成。将统计建模的思想引入到单元挑选和波形拼接中，结合了两种方法的优点，也取得了不错的效果。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>吴义坚. 基于隐马尔科夫模型的语音合成技术研究[D]. 中国科学技术大学, 2006.</li><li>Ze H, Senior A, Schuster M. Statistical parametric speech synthesis using deep neural networks[C]//Acoustics, Speech and Signal Processing (ICASSP), 2013 IEEE International Conference on. IEEE, 2013: 7962-7966.</li></ol><p>2014/5/21 21:12:59 Version 1</p><p>2014/5/29 22:37:52 Version 2</p>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于DTW的孤立词语音识别</title>
    <link href="/2014/05/20/dtw_based_speech_recognition/"/>
    <url>/2014/05/20/dtw_based_speech_recognition/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>近年来，语音识别已经成为一个非常活跃的研究领域。目前，语音识别技术已经作为一种重要的人机交互手段，辅助传统的键盘、鼠标等输入设备，在个人计算机上进行文字录入和操作控制。而在平板电脑、智能家电、工业现场控制等应用场合，语音识别技术则有更为广阔的发展前景。</p><p>在特定人孤立词语音识别中，最为简单有效的方法是采用动态时间规整(Dynamic Time Warping,DTW) 算法，该算法基于动态规划的思想,解决了语音长短不一的模板匹配问题，是语音识别中出现最早、较为经典的一种算法。</p><p>本文首先介绍基于DTW的孤立词语音识别系统，然后分别介绍系统各个部分的具体实现，最后介绍基于该系统进行的孤立数字识别实验和结果。</p><span id="more"></span><h1 id="基于DTW的孤立词语音识别系统"><a href="#基于DTW的孤立词语音识别系统" class="headerlink" title="基于DTW的孤立词语音识别系统"></a>基于DTW的孤立词语音识别系统</h1><p>下图是基于DTW的孤立词语音识别的系统框图。<br><img src="/image/DTW_bsed_speech_recognition.png" alt="基于DTW的孤立词语音识别的系统框图"></p><p>系统包括两个部分：训练部分和测试部分。训练部分包括：预处理、端点检测、Mel倒谱分析、语音模板库的构建；训练部分包括：预处理、端点检测、Mel倒谱分析、DTW算法分析、得到识别结果。下面就分别介绍系统所涉及到的各个部分。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理包括预加重、分帧和加窗三个步骤。</p><ul><li>预加重通过滤波提升高频分量并消除工频干扰。预加重采用具有6dB/倍频程的提升高频特性的一阶数字滤波器实现。</li><li>语音信号具有短时平稳特性，因此可以对语音信号进行分帧处理。同时为了便于计算 FFT，本系统选取帧长N为256个语音点，帧移M为128点。</li><li>窗函数采用了汉明窗。因为汉明窗与矩形窗和汉宁窗相比具有最低旁瓣，可以有效地克服泄漏现象，具有更平滑的低通特性，故本文采用汉明窗对语音信号进行分帧处理。</li></ul><h3 id="端点检测"><a href="#端点检测" class="headerlink" title="端点检测"></a>端点检测</h3><p>端点检测是语音识别的第一步，也是非常关键的一步。端点检测是根据语音的特点及其参数的统计规律，将语音信号从背景噪声中分离出来。端点检测采用基于短时能量和短时平均过零率法，利用已知为“静态”的最初十帧信号为短时能量设置2个门限ampl 和amph，以及过零率阀值zcr。</p><p>语音结束点的检测方法与检测起点相似，但此时从后向前搜索。</p><h3 id="Mel倒谱分析"><a href="#Mel倒谱分析" class="headerlink" title="Mel倒谱分析"></a>Mel倒谱分析</h3><p>语音特征参数提取是语音识别的关键问题，特征参数的好坏对于语音识别精度和识别时间有很大影响。研究表明，倒谱特征参数所含的信息量比其他参数多，能较好地表现语音信号。本文选取能够反映人对语音的感知特性的 Mel 频率倒谱系数 (MFCC) 作为特征参数，阶数为 12。</p><p>MFCC的计算流程如下：</p><ol><li>根据 Mel(f) = 2595lg(1+f/700)，将实际频率尺度装换为Mel频谱尺度。</li><li>在 Mel频率轴上配置L个三角形的滤波器组，L的个数由信号的截止频率决定。</li><li>根据语音信号幅度谱求每一个三角形滤波器的输出。</li><li>对所有滤波器输出做对数运算，再进行离散余弦变换得到MFCC。</li></ol><h3 id="DTW算法分析"><a href="#DTW算法分析" class="headerlink" title="DTW算法分析"></a>DTW算法分析</h3><p>动态时间规整(Dynamic Time Warping，DTW)是把时间规整和距离测度计算结合起来的一种非线性规整技术。DTW可以有效解决测试模板与参考模板语音时间长度不等的问题。</p><p>下图利用DTW计算序列T和S之间的距离的示意图<br><img src="/image/dtw.png" alt="利用DTW计算序列T和S之间的距离"></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>这一部分介绍利用孤立数字语音识别系统所做的实验，首先介绍实验的配置，然后列出了该实验的结果。</p><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><ul><li>录制环境：安静条件下利用 PC录制</li><li>数据参数：16kHz 频率、16bit量化、单声道</li><li>训练数据：数字0-9，10段语音</li><li>测试数据：数字0-9，10段语音</li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><ul><li>识别准确率100%</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文首先介绍了孤立词语音识别，然后设计并实现了孤立数字语音识别系统，并利用该系统做了数字识别的实验。实验结果证明了该系统具有较好的识别性能。DTW 算法虽然在实现小词汇量孤立词识别系统中具有很有的效果、并得到了广泛的应用，但是 DTW 算法也有很多缺点，例如，端点检测精度的敏感性、语音识别的精度和效率并不是很高。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>源代码：<a href="https://github.com/shuaijiang/DTW_based_Isolated_Word_Recognition">https://github.com/shuaijiang/DTW_based_Isolated_Word_Recognition</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>万春, 黄杰圣, 曹煦晖. 基于 DTW 的孤立词语音识别研究和算法改进[J]. 计算机与现代化, 2004 (11): 4-6.</li><li>林波, 吕明. 基于 DTW 改进算法的孤立词识别系统的仿真与分析 [J].信息技术, 2006, 30(4): 56-59.</li></ul><br>----------Version0 2014/05/20 23:37:52<br>Version1 2014/06/23 10:56:55<br>Version2 2014/06/23 20:20:19<br>]]></content>
    
    
    
    <tags>
      
      <tag>语音识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人性之恶</title>
    <link href="/2014/05/16/human_evil/"/>
    <url>/2014/05/16/human_evil/</url>
    
    <content type="html"><![CDATA[<p>昨天晚上在百讲看了北大爱雅玛雅剧团《请君入瓮》，不说是精彩纷呈，也算是发人深省；几位学生演员虽不是最专业，却一定是最投入的。当然，其中所揭示的道理，简单而又深刻，不得不引起大家的共鸣和反思。</p><p>戏剧中的游戏是对一个人的审判，更是对人性的审判，让我们每个人都反思自己的人性，反思整个人类的丑与恶。我不想加入“人之初，性本善”与“人之初，性本恶”的争论之中，也不想惊叹人类千年所创造的文明。我只想反思人性之恶，反思人类的丑恶。</p><p>太多的悲剧，太多的冷漠，无不显现人性之恶。从千年来与人类文明一直共存，甚至可以称为兄弟的残酷战争；到现在职场上，尔虞我诈的明争暗斗。人性之恶从来没有离我们远去，反而有过之而无不及。甚至自己明明知道这样做是丑恶的，但还是为了自己的利益而放弃了人之善。</p><p>我不知道离开了善，是否还能够在这个社会上好好生存。但是，与恶为伍，终究会得到正义法庭的审判。</p><p>2014/5/16 23:57:19 </p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于HMM的参数式语音合成</title>
    <link href="/2014/04/01/hmm_based_speech_synthesis/"/>
    <url>/2014/04/01/hmm_based_speech_synthesis/</url>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>20世纪90年代中期，参数式语音合成得到人们的关注；基于HMM的参数式语音合成快速发展，并成为主流。</p><h1 id="隐马尔科夫模型（Hidden-Markov-Models-HMM）"><a href="#隐马尔科夫模型（Hidden-Markov-Models-HMM）" class="headerlink" title="隐马尔科夫模型（Hidden Markov Models, HMM）"></a>隐马尔科夫模型（Hidden Markov Models, HMM）</h1><p>20世纪60年代末，Baum在理论上给出了关于隐马尔科夫模型的数学推理。一直到80年代，才有人用来解释语音信号的产生过程。经过30多年的发展，HMM已经被广泛应用到语音识别、说话人识别和语音合成等领域，并取得了巨大的成功。</p><span id="more"></span><h1 id="基于HMM的参数式语音合成"><a href="#基于HMM的参数式语音合成" class="headerlink" title="基于HMM的参数式语音合成"></a>基于HMM的参数式语音合成</h1><h2 id="系统框图"><a href="#系统框图" class="headerlink" title="系统框图"></a>系统框图</h2><p>下图是基于HMM的参数式语音合成系统的框图。包括两个阶段：训练阶段，合成阶段。<br><img src="/image/hmm_based_speech_synthesis.png"></p><h2 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h2><p>首先从训练语音数据库中提取特征参数，然后训练上下文相关的HMM模型，并且依据上下文相关的问题集利用决策树对模型聚类，最后训练得到模型。</p><h2 id="合成阶段"><a href="#合成阶段" class="headerlink" title="合成阶段"></a>合成阶段</h2><p>先将输入文本经过文本前端分析得到上下文标注，然后根据相应的决策树为上下文标注生成合适的HMM状态序列，并利用时长模型预测出相应的状态时长，最后通过最大似然准则约束下的参数生成算法得到谱参数和基频，并采用合适的参数合成器生成语音。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>可以方便地实现声音特点、说话方式和感情的转换。这也是参数式语音合成的主要优点。</li><li>声学空间的有效覆盖。相比于基于单元挑选的波形拼接式语音合成，依赖于单元库的大小；参数式语音合成利用统计方法生成语音，从而比基于单元挑选的语音合成有更大的声学空间。</li><li>多语言支持。基于单元挑选的波形拼接式语音合成，对于每种语言都需要相应的单元库。参数式语音合成对于不同的语言，只要相应的改变训练数据，并进行训练即可。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>声码器。基于HMM的参数式语音合成利用梅尔倒谱声码器，听起来会比较闷（buzzy）</li><li>声学建模的准确性。</li><li>过拟合问题。相比于自然语音，合成的语音听起来会明显地沉闷（muffled），这主要就是因为生成的语音参数总是过拟合的。在建模过程中语音的细节特征被忽略了，在合成过程中不能被恢复。</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li>YoshimuraÝ T, TokudaÝ K, MasukoÝÝ T, et al. Simultaneous modeling of spectrum, pitch and duration in HMM-based speech synthesis[J]. 1999.</li><li>于延锁.语音合成中韵律建模方法研究[D]. Ph.D. thesis, 北京大学, 2013</li><li>Zen H, Tokuda K, Black A W. Statistical parametric speech synthesis[J]. Speech Communication, 2009, 51(11): 1039-1064.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于单元挑选的波形拼接式语音合成</title>
    <link href="/2014/03/05/unit_selection_synthesis/"/>
    <url>/2014/03/05/unit_selection_synthesis/</url>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>自20世纪50年代，开始出现波形拼接式的语音合成。<br/><br>1992年，ATR的v-talk系统首次证明了自动单元挑选的有效性。<br/><br>基于单元挑选的波形拼接式语音合成的基本假设是，通过从语音数据库中挑选相近的子词单元，可以合成新的听起来自然的句子。</p><span id="more"></span><h1 id="单元挑选"><a href="#单元挑选" class="headerlink" title="单元挑选"></a>单元挑选</h1><h2 id="单元挑选的准则"><a href="#单元挑选的准则" class="headerlink" title="单元挑选的准则"></a>单元挑选的准则</h2><p>被挑选的单元，需要具备以下几点要求：</p><ul><li>较低的拼接失真</li><li>较低的韵律失真</li><li>具有泛化能力</li><li>具有可训练性</li></ul><p>现实的挑战是，如何去平衡这些准则。</p><h2 id="可选择的单元"><a href="#可选择的单元" class="headerlink" title="可选择的单元"></a>可选择的单元</h2><ol><li>上下文无关的音素<br/><br> 把每个音素看做单元，不考虑前后相邻的音素。这样具有较好泛化能力，能够生成任意的词或者句子。假如一种语言有N个音素，只需要N个单元，这是很容易训练的。其缺点是，利用这样的单元生成的语音不连贯。</li><li>双音素<br/><br> 双音素是可训练的、具有泛化能力，并且相比于上下文无关的音素，其合成的语音有更好的质量。</li><li>上下文相关的音素</li><li>子音素单元</li><li>音节</li><li>词和短语</li></ol><h2 id="单元挑选的代价"><a href="#单元挑选的代价" class="headerlink" title="单元挑选的代价"></a>单元挑选的代价</h2><p>基于单元挑选的语音合成包括两种基本的技术操作。第一，目标代价，用来衡量数据库中的候选单元与目标单元的匹配程度。第二，连接代价，用来衡量两个被挑选的单元间的连接平滑程度。</p><p><img src="/image/unit_select_cost.png"></p><p>由于是从原始的语音库中挑选单元，然后拼接生成语音，基于单元挑选的波形拼接式语音合成保持了原始语音自然的特点，具有较高的自然度。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Huang X, Acero A, Hon H W. Spoken language processing[M]. Englewood Cliffs: Prentice Hall, 2001.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>语音合成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北京的雪</title>
    <link href="/2014/02/13/myfirstblog/"/>
    <url>/2014/02/13/myfirstblog/</url>
    
    <content type="html"><![CDATA[<p>今天是2014年02月13日，北京有小雪，景色很美。<br>北京，北京，什么时候才能摆脱雾霾。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
